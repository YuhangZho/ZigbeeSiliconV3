<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zigbee Application Framework API Reference: Non-Cluster Callbacks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Zigbee Application Framework API Reference
   &#160;<span id="projectnumber">EmberZNet 6.8.1.0</span>
   </div>
   <div id="projectbrief">For the EFR32 and EM3xx Platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__nonClustercallback.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Non-Cluster Callbacks<div class="ingroups"><a class="el" href="group__appframework.html">Zigbee Application Framework API Reference</a> &raquo; <a class="el" href="group__callback.html">Application Framework Callback Interface</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Non-Cluster Related Callbacks</h2></td></tr>
<tr class="memitem:gada2e4d46a29d5f8203cac97485ed1155"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gada2e4d46a29d5f8203cac97485ed1155">emberAfAddToCurrentAppTasksCallback</a> (<a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a> tasks)</td></tr>
<tr class="memdesc:gada2e4d46a29d5f8203cac97485ed1155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add To Current App Tasks.  <a href="#gada2e4d46a29d5f8203cac97485ed1155">More...</a><br /></td></tr>
<tr class="separator:gada2e4d46a29d5f8203cac97485ed1155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd87f592ea24868bf30988b24d2f3f5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga6bbb7962d8ea86644b36c6f64e7868f2">EmberAfAttributeWritePermission</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gadd87f592ea24868bf30988b24d2f3f5d">emberAfAllowNetworkWriteAttributeCallback</a> (int8u endpoint, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, <a class="el" href="group__aftypes.html#ga6f3b7c4757642dc04d42b880720416db">EmberAfAttributeId</a> attributeId, int8u mask, int16u manufacturerCode, int8u *value, int8u type)</td></tr>
<tr class="memdesc:gadd87f592ea24868bf30988b24d2f3f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow Network Write Attribute.  <a href="#gadd87f592ea24868bf30988b24d2f3f5d">More...</a><br /></td></tr>
<tr class="separator:gadd87f592ea24868bf30988b24d2f3f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9ff8b57ad46e090fc6608495cc72e1"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaba9ff8b57ad46e090fc6608495cc72e1">emberAfAttributeReadAccessCallback</a> (int8u endpoint, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int16u manufacturerCode, int16u attributeId)</td></tr>
<tr class="memdesc:gaba9ff8b57ad46e090fc6608495cc72e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute Read Access.  <a href="#gaba9ff8b57ad46e090fc6608495cc72e1">More...</a><br /></td></tr>
<tr class="separator:gaba9ff8b57ad46e090fc6608495cc72e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa5adf715ba15f73bd85075309524ab5"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gafa5adf715ba15f73bd85075309524ab5">emberAfAttributeWriteAccessCallback</a> (int8u endpoint, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int16u manufacturerCode, int16u attributeId)</td></tr>
<tr class="memdesc:gafa5adf715ba15f73bd85075309524ab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attribute Write Access.  <a href="#gafa5adf715ba15f73bd85075309524ab5">More...</a><br /></td></tr>
<tr class="separator:gafa5adf715ba15f73bd85075309524ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac561b5bbe5962927104f2c50254c9672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gac561b5bbe5962927104f2c50254c9672">emberAfClearReportTableCallback</a> (void)</td></tr>
<tr class="memdesc:gac561b5bbe5962927104f2c50254c9672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Report Table.  <a href="#gac561b5bbe5962927104f2c50254c9672">More...</a><br /></td></tr>
<tr class="separator:gac561b5bbe5962927104f2c50254c9672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14f2d278e2382436b9b137037b3e9e11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga14f2d278e2382436b9b137037b3e9e11">emberAfClusterInitCallback</a> (int8u endpoint, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId)</td></tr>
<tr class="memdesc:ga14f2d278e2382436b9b137037b3e9e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster Init.  <a href="#ga14f2d278e2382436b9b137037b3e9e11">More...</a><br /></td></tr>
<tr class="separator:ga14f2d278e2382436b9b137037b3e9e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9793f3bf26e77340737889b380cf4fa8"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga9793f3bf26e77340737889b380cf4fa8">emberAfClusterSecurityCustomCallback</a> (<a class="el" href="group__aftypes.html#ga03537dfe99c3854a75a922ac1974dd29">EmberAfProfileId</a> profileId, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, boolean incoming, int8u commandId)</td></tr>
<tr class="memdesc:ga9793f3bf26e77340737889b380cf4fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster Security Custom.  <a href="#ga9793f3bf26e77340737889b380cf4fa8">More...</a><br /></td></tr>
<tr class="separator:ga9793f3bf26e77340737889b380cf4fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08d06c3736c24a5219b79dce5fac2625"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga08d06c3736c24a5219b79dce5fac2625">emberAfConfigureReportingCommandCallback</a> (const <a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *cmd)</td></tr>
<tr class="memdesc:ga08d06c3736c24a5219b79dce5fac2625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Reporting Command.  <a href="#ga08d06c3736c24a5219b79dce5fac2625">More...</a><br /></td></tr>
<tr class="separator:ga08d06c3736c24a5219b79dce5fac2625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0a55474c85defe672362d389e86c25e"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gad0a55474c85defe672362d389e86c25e">emberAfConfigureReportingResponseCallback</a> (<a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int8u *buffer, int16u bufLen)</td></tr>
<tr class="memdesc:gad0a55474c85defe672362d389e86c25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure Reporting Response.  <a href="#gad0a55474c85defe672362d389e86c25e">More...</a><br /></td></tr>
<tr class="separator:gad0a55474c85defe672362d389e86c25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a6479692f3576295179d7e73d22de2b"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga6a6479692f3576295179d7e73d22de2b">emberAfDefaultResponseCallback</a> (<a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int8u commandId, <a class="el" href="group__enums.html#ga6047361ca88bd5c16bb7bb759fa6da9d">EmberAfStatus</a> status)</td></tr>
<tr class="memdesc:ga6a6479692f3576295179d7e73d22de2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Response.  <a href="#ga6a6479692f3576295179d7e73d22de2b">More...</a><br /></td></tr>
<tr class="separator:ga6a6479692f3576295179d7e73d22de2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ff04fb23a01713b32f93ecef7b75219"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga4ff04fb23a01713b32f93ecef7b75219">emberAfDiscoverAttributesResponseCallback</a> (<a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, boolean discoveryComplete, int8u *buffer, int16u bufLen, boolean extended)</td></tr>
<tr class="memdesc:ga4ff04fb23a01713b32f93ecef7b75219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover Attributes Response.  <a href="#ga4ff04fb23a01713b32f93ecef7b75219">More...</a><br /></td></tr>
<tr class="separator:ga4ff04fb23a01713b32f93ecef7b75219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4b18cdfc674465ee99579be3a4705c"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga3c4b18cdfc674465ee99579be3a4705c">emberAfDiscoverCommandsGeneratedResponseCallback</a> (<a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int16u manufacturerCode, boolean discoveryComplete, int8u *commandIds, int16u commandIdCount)</td></tr>
<tr class="memdesc:ga3c4b18cdfc674465ee99579be3a4705c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover Commands Generated Response.  <a href="#ga3c4b18cdfc674465ee99579be3a4705c">More...</a><br /></td></tr>
<tr class="separator:ga3c4b18cdfc674465ee99579be3a4705c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24dad599cde20a8b880219fceb426154"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga24dad599cde20a8b880219fceb426154">emberAfDiscoverCommandsReceivedResponseCallback</a> (<a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int16u manufacturerCode, boolean discoveryComplete, int8u *commandIds, int16u commandIdCount)</td></tr>
<tr class="memdesc:ga24dad599cde20a8b880219fceb426154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover Commands Received Response.  <a href="#ga24dad599cde20a8b880219fceb426154">More...</a><br /></td></tr>
<tr class="separator:ga24dad599cde20a8b880219fceb426154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf48005d565f5abffc5ce5a0ce4cc05e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaaf48005d565f5abffc5ce5a0ce4cc05e">emberAfEepromInitCallback</a> (void)</td></tr>
<tr class="memdesc:gaaf48005d565f5abffc5ce5a0ce4cc05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eeprom Init.  <a href="#gaaf48005d565f5abffc5ce5a0ce4cc05e">More...</a><br /></td></tr>
<tr class="separator:gaaf48005d565f5abffc5ce5a0ce4cc05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b375707c38ee7249fd596d005421c46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga1b375707c38ee7249fd596d005421c46">emberAfEepromNoteInitializedStateCallback</a> (boolean state)</td></tr>
<tr class="memdesc:ga1b375707c38ee7249fd596d005421c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eeprom Note Initialized State.  <a href="#ga1b375707c38ee7249fd596d005421c46">More...</a><br /></td></tr>
<tr class="separator:ga1b375707c38ee7249fd596d005421c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff17ea7400eb202922146e331369c5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaaff17ea7400eb202922146e331369c5d">emberAfEepromShutdownCallback</a> (void)</td></tr>
<tr class="memdesc:gaaff17ea7400eb202922146e331369c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eeprom Shutdown.  <a href="#gaaff17ea7400eb202922146e331369c5d">More...</a><br /></td></tr>
<tr class="separator:gaaff17ea7400eb202922146e331369c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga285ae4ec5dd0f5f02ebea0adb498c92b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga285ae4ec5dd0f5f02ebea0adb498c92b">emberAfEnergyScanResultCallback</a> (int8u channel, int8s rssi)</td></tr>
<tr class="memdesc:ga285ae4ec5dd0f5f02ebea0adb498c92b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Energy Scan Result.  <a href="#ga285ae4ec5dd0f5f02ebea0adb498c92b">More...</a><br /></td></tr>
<tr class="separator:ga285ae4ec5dd0f5f02ebea0adb498c92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b8273646fe8af6e86913263b3b0f3ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga6047361ca88bd5c16bb7bb759fa6da9d">EmberAfStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga0b8273646fe8af6e86913263b3b0f3ae">emberAfExternalAttributeReadCallback</a> (int8u endpoint, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, <a class="el" href="structEmberAfAttributeMetadata.html">EmberAfAttributeMetadata</a> *attributeMetadata, int16u manufacturerCode, int8u *buffer, int16u maxReadLength)</td></tr>
<tr class="memdesc:ga0b8273646fe8af6e86913263b3b0f3ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">External Attribute Read.  <a href="#ga0b8273646fe8af6e86913263b3b0f3ae">More...</a><br /></td></tr>
<tr class="separator:ga0b8273646fe8af6e86913263b3b0f3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga049a2804a5d9cc3ce7c96884f4160adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga6047361ca88bd5c16bb7bb759fa6da9d">EmberAfStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga049a2804a5d9cc3ce7c96884f4160adf">emberAfExternalAttributeWriteCallback</a> (int8u endpoint, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, <a class="el" href="structEmberAfAttributeMetadata.html">EmberAfAttributeMetadata</a> *attributeMetadata, int16u manufacturerCode, int8u *buffer)</td></tr>
<tr class="memdesc:ga049a2804a5d9cc3ce7c96884f4160adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">External Attribute Write.  <a href="#ga049a2804a5d9cc3ce7c96884f4160adf">More...</a><br /></td></tr>
<tr class="separator:ga049a2804a5d9cc3ce7c96884f4160adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad64a82720250a4cb542f3c0d1e79049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaad64a82720250a4cb542f3c0d1e79049">emberAfFindUnusedPanIdAndFormCallback</a> (void)</td></tr>
<tr class="memdesc:gaad64a82720250a4cb542f3c0d1e79049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find Unused Pan Id And Form.  <a href="#gaad64a82720250a4cb542f3c0d1e79049">More...</a><br /></td></tr>
<tr class="separator:gaad64a82720250a4cb542f3c0d1e79049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad27b880ce5817815221cf83ecd9e3da7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gad27b880ce5817815221cf83ecd9e3da7">emberAfGetCurrentAppTasksCallback</a> (void)</td></tr>
<tr class="memdesc:gad27b880ce5817815221cf83ecd9e3da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Current App Tasks.  <a href="#gad27b880ce5817815221cf83ecd9e3da7">More...</a><br /></td></tr>
<tr class="separator:gad27b880ce5817815221cf83ecd9e3da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90ac907c3a64dc77d0f7ec0d3c0a10f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#gab3daa30a7fe8edc180c38c109be2551e">EmberAfEventPollControl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga90ac907c3a64dc77d0f7ec0d3c0a10f2">emberAfGetCurrentPollControlCallback</a> (void)</td></tr>
<tr class="memdesc:ga90ac907c3a64dc77d0f7ec0d3c0a10f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Current Poll Control.  <a href="#ga90ac907c3a64dc77d0f7ec0d3c0a10f2">More...</a><br /></td></tr>
<tr class="separator:ga90ac907c3a64dc77d0f7ec0d3c0a10f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aba1d55e86c965f4fa76b575dae313c"><td class="memItemLeft" align="right" valign="top">int32u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga1aba1d55e86c965f4fa76b575dae313c">emberAfGetCurrentPollIntervalMsCallback</a> (void)</td></tr>
<tr class="memdesc:ga1aba1d55e86c965f4fa76b575dae313c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Current Poll Interval Ms.  <a href="#ga1aba1d55e86c965f4fa76b575dae313c">More...</a><br /></td></tr>
<tr class="separator:ga1aba1d55e86c965f4fa76b575dae313c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac081eb47e842287eee9660f9ee543774"><td class="memItemLeft" align="right" valign="top">int32u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gac081eb47e842287eee9660f9ee543774">emberAfGetCurrentPollIntervalQsCallback</a> (void)</td></tr>
<tr class="memdesc:gac081eb47e842287eee9660f9ee543774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Current Poll Interval Qs.  <a href="#gac081eb47e842287eee9660f9ee543774">More...</a><br /></td></tr>
<tr class="separator:gac081eb47e842287eee9660f9ee543774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6de87a6b44a1b6377dbbc0eccfffa53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="af-ncp_8h.html#a4a612352f4b32cb9713cc3150a04c776">EmberAfEventSleepControl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gae6de87a6b44a1b6377dbbc0eccfffa53">emberAfGetCurrentSleepControlCallback</a> (void)</td></tr>
<tr class="memdesc:gae6de87a6b44a1b6377dbbc0eccfffa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Current Sleep Control.  <a href="#gae6de87a6b44a1b6377dbbc0eccfffa53">More...</a><br /></td></tr>
<tr class="separator:gae6de87a6b44a1b6377dbbc0eccfffa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9047584e5724c02c98ad08a370c217bf"><td class="memItemLeft" align="right" valign="top">int32u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga9047584e5724c02c98ad08a370c217bf">emberAfGetCurrentTimeCallback</a> (void)</td></tr>
<tr class="memdesc:ga9047584e5724c02c98ad08a370c217bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Current Time.  <a href="#ga9047584e5724c02c98ad08a370c217bf">More...</a><br /></td></tr>
<tr class="separator:ga9047584e5724c02c98ad08a370c217bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16f7d8b1edf54a45f9323f979a895eb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#gab3daa30a7fe8edc180c38c109be2551e">EmberAfEventPollControl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga16f7d8b1edf54a45f9323f979a895eb2">emberAfGetDefaultPollControlCallback</a> (void)</td></tr>
<tr class="memdesc:ga16f7d8b1edf54a45f9323f979a895eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Default Poll Control.  <a href="#ga16f7d8b1edf54a45f9323f979a895eb2">More...</a><br /></td></tr>
<tr class="separator:ga16f7d8b1edf54a45f9323f979a895eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55813ba4f0b9cfd4d460155ae63adfc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="af-ncp_8h.html#a4a612352f4b32cb9713cc3150a04c776">EmberAfEventSleepControl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga55813ba4f0b9cfd4d460155ae63adfc0">emberAfGetDefaultSleepControlCallback</a> (void)</td></tr>
<tr class="memdesc:ga55813ba4f0b9cfd4d460155ae63adfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Default Sleep Control.  <a href="#ga55813ba4f0b9cfd4d460155ae63adfc0">More...</a><br /></td></tr>
<tr class="separator:ga55813ba4f0b9cfd4d460155ae63adfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecbe09af36f195d4787bac0cefb867d7"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaecbe09af36f195d4787bac0cefb867d7">emberAfGetEndpointByIndexCallback</a> (int8u index, int8u *endpointReturn)</td></tr>
<tr class="memdesc:gaecbe09af36f195d4787bac0cefb867d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Endpoint By Index.  <a href="#gaecbe09af36f195d4787bac0cefb867d7">More...</a><br /></td></tr>
<tr class="separator:gaecbe09af36f195d4787bac0cefb867d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8847c3f3662832ec22b9a9b0da9c3a46"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga8847c3f3662832ec22b9a9b0da9c3a46">emberAfGetEndpointDescriptionCallback</a> (int8u endpoint, EmberEndpointDescription *result)</td></tr>
<tr class="memdesc:ga8847c3f3662832ec22b9a9b0da9c3a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Endpoint Description.  <a href="#ga8847c3f3662832ec22b9a9b0da9c3a46">More...</a><br /></td></tr>
<tr class="separator:ga8847c3f3662832ec22b9a9b0da9c3a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d56d65056d17cabc9167d7ace9d3db3"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga1d56d65056d17cabc9167d7ace9d3db3">emberAfGetEndpointInfoCallback</a> (int8u endpoint, int8u *returnNetworkIndex, <a class="el" href="structEmberAfEndpointInfoStruct.html">EmberAfEndpointInfoStruct</a> *returnEndpointInfo)</td></tr>
<tr class="memdesc:ga1d56d65056d17cabc9167d7ace9d3db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Endpoint Info.  <a href="#ga1d56d65056d17cabc9167d7ace9d3db3">More...</a><br /></td></tr>
<tr class="separator:ga1d56d65056d17cabc9167d7ace9d3db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4963bce5e4b1e6a51f8edbb3542c0cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gad4963bce5e4b1e6a51f8edbb3542c0cc">emberAfGetFormAndJoinExtendedPanIdCallback</a> (int8u *resultLocation)</td></tr>
<tr class="memdesc:gad4963bce5e4b1e6a51f8edbb3542c0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Form And Join Extended Pan Id.  <a href="#gad4963bce5e4b1e6a51f8edbb3542c0cc">More...</a><br /></td></tr>
<tr class="separator:gad4963bce5e4b1e6a51f8edbb3542c0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95c58910c26f2c9728a10b5c5d3aa4a2"><td class="memItemLeft" align="right" valign="top">int32u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga95c58910c26f2c9728a10b5c5d3aa4a2">emberAfGetLongPollIntervalMsCallback</a> (void)</td></tr>
<tr class="memdesc:ga95c58910c26f2c9728a10b5c5d3aa4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Long Poll Interval Ms.  <a href="#ga95c58910c26f2c9728a10b5c5d3aa4a2">More...</a><br /></td></tr>
<tr class="separator:ga95c58910c26f2c9728a10b5c5d3aa4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21da48d0b8d8a3e58160e8e5d7d43d48"><td class="memItemLeft" align="right" valign="top">int32u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga21da48d0b8d8a3e58160e8e5d7d43d48">emberAfGetLongPollIntervalQsCallback</a> (void)</td></tr>
<tr class="memdesc:ga21da48d0b8d8a3e58160e8e5d7d43d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Long Poll Interval Qs.  <a href="#ga21da48d0b8d8a3e58160e8e5d7d43d48">More...</a><br /></td></tr>
<tr class="separator:ga21da48d0b8d8a3e58160e8e5d7d43d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86641927dacac3b5f6227de7e75a5f35"><td class="memItemLeft" align="right" valign="top">int16u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga86641927dacac3b5f6227de7e75a5f35">emberAfGetShortPollIntervalMsCallback</a> (void)</td></tr>
<tr class="memdesc:ga86641927dacac3b5f6227de7e75a5f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Short Poll Interval Ms.  <a href="#ga86641927dacac3b5f6227de7e75a5f35">More...</a><br /></td></tr>
<tr class="separator:ga86641927dacac3b5f6227de7e75a5f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41f57211501e91e893fbd3a6e728c1e2"><td class="memItemLeft" align="right" valign="top">int16u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga41f57211501e91e893fbd3a6e728c1e2">emberAfGetShortPollIntervalQsCallback</a> (void)</td></tr>
<tr class="memdesc:ga41f57211501e91e893fbd3a6e728c1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Short Poll Interval Qs.  <a href="#ga41f57211501e91e893fbd3a6e728c1e2">More...</a><br /></td></tr>
<tr class="separator:ga41f57211501e91e893fbd3a6e728c1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5d6c02856c3a52e6945c3718713c10e"><td class="memItemLeft" align="right" valign="top">int8u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaf5d6c02856c3a52e6945c3718713c10e">emberAfGetSourceRouteOverheadCallback</a> (EmberNodeId destination)</td></tr>
<tr class="memdesc:gaf5d6c02856c3a52e6945c3718713c10e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Source Route Overhead.  <a href="#gaf5d6c02856c3a52e6945c3718713c10e">More...</a><br /></td></tr>
<tr class="separator:gaf5d6c02856c3a52e6945c3718713c10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cebec7e54db6fd3860aec29ac786f16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga1cebec7e54db6fd3860aec29ac786f16">emberAfGetWakeTimeoutBitmaskCallback</a> (void)</td></tr>
<tr class="memdesc:ga1cebec7e54db6fd3860aec29ac786f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Wake Timeout Bitmask.  <a href="#ga1cebec7e54db6fd3860aec29ac786f16">More...</a><br /></td></tr>
<tr class="separator:ga1cebec7e54db6fd3860aec29ac786f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae45b4348db2a4d7d574573d6e54419a8"><td class="memItemLeft" align="right" valign="top">int16u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gae45b4348db2a4d7d574573d6e54419a8">emberAfGetWakeTimeoutMsCallback</a> (void)</td></tr>
<tr class="memdesc:gae45b4348db2a4d7d574573d6e54419a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Wake Timeout Ms.  <a href="#gae45b4348db2a4d7d574573d6e54419a8">More...</a><br /></td></tr>
<tr class="separator:gae45b4348db2a4d7d574573d6e54419a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc660fe69cb3b4e7d1948d19e1a17f30"><td class="memItemLeft" align="right" valign="top">int16u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gadc660fe69cb3b4e7d1948d19e1a17f30">emberAfGetWakeTimeoutQsCallback</a> (void)</td></tr>
<tr class="memdesc:gadc660fe69cb3b4e7d1948d19e1a17f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Wake Timeout Qs.  <a href="#gadc660fe69cb3b4e7d1948d19e1a17f30">More...</a><br /></td></tr>
<tr class="separator:gadc660fe69cb3b4e7d1948d19e1a17f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07ac11dfc464999bb2fd9bf6bbe124e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga07ac11dfc464999bb2fd9bf6bbe124e8">emberAfHalButtonIsrCallback</a> (int8u button, int8u state)</td></tr>
<tr class="memdesc:ga07ac11dfc464999bb2fd9bf6bbe124e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hal Button Isr.  <a href="#ga07ac11dfc464999bb2fd9bf6bbe124e8">More...</a><br /></td></tr>
<tr class="separator:ga07ac11dfc464999bb2fd9bf6bbe124e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90859f0856e4de645eea2d79c15d4125"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga90859f0856e4de645eea2d79c15d4125">emberAfIncomingPacketFilterCallback</a> (<a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a> packetType, int8u *packetData, int8u *size_p, void *data)</td></tr>
<tr class="memdesc:ga90859f0856e4de645eea2d79c15d4125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incoming Packet Filter.  <a href="#ga90859f0856e4de645eea2d79c15d4125">More...</a><br /></td></tr>
<tr class="separator:ga90859f0856e4de645eea2d79c15d4125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafec49d348615c7d4e1306772f35ed58c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gafec49d348615c7d4e1306772f35ed58c">emberAfInitiateInterPanKeyEstablishmentCallback</a> (EmberPanId panId, const EmberEUI64 eui64)</td></tr>
<tr class="memdesc:gafec49d348615c7d4e1306772f35ed58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate Inter Pan Key Establishment.  <a href="#gafec49d348615c7d4e1306772f35ed58c">More...</a><br /></td></tr>
<tr class="separator:gafec49d348615c7d4e1306772f35ed58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0357d8f4c0ee7997c85279ac5c739615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga0357d8f4c0ee7997c85279ac5c739615">emberAfInitiateKeyEstablishmentCallback</a> (EmberNodeId nodeId, int8u endpoint)</td></tr>
<tr class="memdesc:ga0357d8f4c0ee7997c85279ac5c739615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate Key Establishment.  <a href="#ga0357d8f4c0ee7997c85279ac5c739615">More...</a><br /></td></tr>
<tr class="separator:ga0357d8f4c0ee7997c85279ac5c739615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37af6af4db874e472aebaa7552c9bb2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga37af6af4db874e472aebaa7552c9bb2f">emberAfInitiatePartnerLinkKeyExchangeCallback</a> (EmberNodeId target, int8u endpoint, <a class="el" href="group__aftypes.html#gaca9dd969e62b8b79b29282e161c94449">EmberAfPartnerLinkKeyExchangeCallback</a> *callback)</td></tr>
<tr class="memdesc:ga37af6af4db874e472aebaa7552c9bb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiate Partner Link Key Exchange.  <a href="#ga37af6af4db874e472aebaa7552c9bb2f">More...</a><br /></td></tr>
<tr class="separator:ga37af6af4db874e472aebaa7552c9bb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d413fe9794946636b8af3c82058e027"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga5d413fe9794946636b8af3c82058e027">emberAfInterPanKeyEstablishmentCallback</a> (<a class="el" href="group__aftypes.html#ga908101ba54b5ff8c36bc1129995e8d0d">EmberAfKeyEstablishmentNotifyMessage</a> status, boolean amInitiator, EmberPanId panId, const EmberEUI64 eui64, int8u delayInSeconds)</td></tr>
<tr class="memdesc:ga5d413fe9794946636b8af3c82058e027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inter Pan Key Establishment.  <a href="#ga5d413fe9794946636b8af3c82058e027">More...</a><br /></td></tr>
<tr class="separator:ga5d413fe9794946636b8af3c82058e027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3819468a166d47024d99f513f4f1f7bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga3819468a166d47024d99f513f4f1f7bf">emberAfInterpanSendMessageCallback</a> (<a class="el" href="structEmberAfInterpanHeader.html">EmberAfInterpanHeader</a> *header, int16u messageLength, int8u *message)</td></tr>
<tr class="memdesc:ga3819468a166d47024d99f513f4f1f7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpan Send Message.  <a href="#ga3819468a166d47024d99f513f4f1f7bf">More...</a><br /></td></tr>
<tr class="separator:ga3819468a166d47024d99f513f4f1f7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64e4318554deac14d8f6e82458b4985c"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga64e4318554deac14d8f6e82458b4985c">emberAfKeyEstablishmentCallback</a> (<a class="el" href="group__aftypes.html#ga908101ba54b5ff8c36bc1129995e8d0d">EmberAfKeyEstablishmentNotifyMessage</a> status, boolean amInitiator, EmberNodeId partnerShortId, int8u delayInSeconds)</td></tr>
<tr class="memdesc:ga64e4318554deac14d8f6e82458b4985c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key Establishment.  <a href="#ga64e4318554deac14d8f6e82458b4985c">More...</a><br /></td></tr>
<tr class="separator:ga64e4318554deac14d8f6e82458b4985c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65064a46ee99097caee378717b53a39c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga65064a46ee99097caee378717b53a39c">emberAfMainInitCallback</a> (void)</td></tr>
<tr class="memdesc:ga65064a46ee99097caee378717b53a39c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main Init.  <a href="#ga65064a46ee99097caee378717b53a39c">More...</a><br /></td></tr>
<tr class="separator:ga65064a46ee99097caee378717b53a39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529b1928a29111f30ad6dd715e4f4436"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga529b1928a29111f30ad6dd715e4f4436">emberAfMainStartCallback</a> (int *returnCode, int argc, char **argv)</td></tr>
<tr class="memdesc:ga529b1928a29111f30ad6dd715e4f4436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main Start.  <a href="#ga529b1928a29111f30ad6dd715e4f4436">More...</a><br /></td></tr>
<tr class="separator:ga529b1928a29111f30ad6dd715e4f4436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fd5c4d349ee7d830a2c151e9bba0abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga5fd5c4d349ee7d830a2c151e9bba0abb">emberAfMainTickCallback</a> (void)</td></tr>
<tr class="memdesc:ga5fd5c4d349ee7d830a2c151e9bba0abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main Tick.  <a href="#ga5fd5c4d349ee7d830a2c151e9bba0abb">More...</a><br /></td></tr>
<tr class="separator:ga5fd5c4d349ee7d830a2c151e9bba0abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f95da0a54225b10a2de6306e339e1ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga7f95da0a54225b10a2de6306e339e1ec">emberAfMarkBuffersCallback</a> (void)</td></tr>
<tr class="memdesc:ga7f95da0a54225b10a2de6306e339e1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark Buffers.  <a href="#ga7f95da0a54225b10a2de6306e339e1ec">More...</a><br /></td></tr>
<tr class="separator:ga7f95da0a54225b10a2de6306e339e1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5173eae666ae910581d9aa151bdd155"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gab5173eae666ae910581d9aa151bdd155">emberAfMessageSentCallback</a> (<a class="el" href="group__ember__types.html#gab77dd07ca7af23a832974d3cc20c94f3">EmberOutgoingMessageType</a> type, int16u indexOrDestination, <a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, int16u msgLen, int8u *message, <a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> status)</td></tr>
<tr class="memdesc:gab5173eae666ae910581d9aa151bdd155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message Sent.  <a href="#gab5173eae666ae910581d9aa151bdd155">More...</a><br /></td></tr>
<tr class="separator:gab5173eae666ae910581d9aa151bdd155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf844d0651d3c1f8bfe18a582156b5429"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaf844d0651d3c1f8bfe18a582156b5429">emberAfNcpInitCallback</a> (boolean memoryAllocation)</td></tr>
<tr class="memdesc:gaf844d0651d3c1f8bfe18a582156b5429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ncp Init.  <a href="#gaf844d0651d3c1f8bfe18a582156b5429">More...</a><br /></td></tr>
<tr class="separator:gaf844d0651d3c1f8bfe18a582156b5429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76fb07fda58f8c8533089fbc8dfc5bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga76fb07fda58f8c8533089fbc8dfc5bc7">emberAfNcpIsAwakeIsrCallback</a> (void)</td></tr>
<tr class="memdesc:ga76fb07fda58f8c8533089fbc8dfc5bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ncp Is Awake Isr.  <a href="#ga76fb07fda58f8c8533089fbc8dfc5bc7">More...</a><br /></td></tr>
<tr class="separator:ga76fb07fda58f8c8533089fbc8dfc5bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae510f585bbce12a45e47b7b20cdf5336"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gae510f585bbce12a45e47b7b20cdf5336">emberAfNetworkFoundCallback</a> (<a class="el" href="structEmberZigbeeNetwork.html">EmberZigbeeNetwork</a> *networkFound, int8u lqi, int8s rssi)</td></tr>
<tr class="memdesc:gae510f585bbce12a45e47b7b20cdf5336"><td class="mdescLeft">&#160;</td><td class="mdescRight">Network Found.  <a href="#gae510f585bbce12a45e47b7b20cdf5336">More...</a><br /></td></tr>
<tr class="separator:gae510f585bbce12a45e47b7b20cdf5336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a38e497a6db04a44609ef264c72a78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gae6a38e497a6db04a44609ef264c72a78">emberAfNetworkKeyUpdateCompleteCallback</a> (<a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> status)</td></tr>
<tr class="memdesc:gae6a38e497a6db04a44609ef264c72a78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Network Key Update Complete.  <a href="#gae6a38e497a6db04a44609ef264c72a78">More...</a><br /></td></tr>
<tr class="separator:gae6a38e497a6db04a44609ef264c72a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac00c12a70f9aaab0c932ba0979a9f15"><td class="memItemLeft" align="right" valign="top">int8u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaac00c12a70f9aaab0c932ba0979a9f15">emberAfOtaBootloadCallback</a> (const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *id, int16u ncpUpgradeTagId)</td></tr>
<tr class="memdesc:gaac00c12a70f9aaab0c932ba0979a9f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Bootload.  <a href="#gaac00c12a70f9aaab0c932ba0979a9f15">More...</a><br /></td></tr>
<tr class="separator:gaac00c12a70f9aaab0c932ba0979a9f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4b66d2d410fd5a2b5034e2254fe2766"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gac4b66d2d410fd5a2b5034e2254fe2766">emberAfOtaClientBootloadCallback</a> (const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *id)</td></tr>
<tr class="memdesc:gac4b66d2d410fd5a2b5034e2254fe2766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Client Bootload.  <a href="#gac4b66d2d410fd5a2b5034e2254fe2766">More...</a><br /></td></tr>
<tr class="separator:gac4b66d2d410fd5a2b5034e2254fe2766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4308f5dbfaf9d2920282836536a9c040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga1507d91e2449d9042f5b94e044914fc2">EmberAfImageVerifyStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga4308f5dbfaf9d2920282836536a9c040">emberAfOtaClientCustomVerifyCallback</a> (boolean newVerification, const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *id)</td></tr>
<tr class="memdesc:ga4308f5dbfaf9d2920282836536a9c040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Client Custom Verify.  <a href="#ga4308f5dbfaf9d2920282836536a9c040">More...</a><br /></td></tr>
<tr class="separator:ga4308f5dbfaf9d2920282836536a9c040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae53bc95b5d5b8ed99af3278ac3067ca2"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gae53bc95b5d5b8ed99af3278ac3067ca2">emberAfOtaClientDownloadCompleteCallback</a> (<a class="el" href="group__aftypes.html#gacd4e96651a3e1c8a4aafa6b5d32ee05a">EmberAfOtaDownloadResult</a> success, const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *id)</td></tr>
<tr class="memdesc:gae53bc95b5d5b8ed99af3278ac3067ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Client Download Complete.  <a href="#gae53bc95b5d5b8ed99af3278ac3067ca2">More...</a><br /></td></tr>
<tr class="separator:gae53bc95b5d5b8ed99af3278ac3067ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf58d4eb52c33e60788b507426e60696"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gadf58d4eb52c33e60788b507426e60696">emberAfOtaClientIncomingMessageRawCallback</a> (<a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *message)</td></tr>
<tr class="memdesc:gadf58d4eb52c33e60788b507426e60696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Client Incoming Message Raw.  <a href="#gadf58d4eb52c33e60788b507426e60696">More...</a><br /></td></tr>
<tr class="separator:gadf58d4eb52c33e60788b507426e60696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d84a87643c71e97075447dc2909b977"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga5d84a87643c71e97075447dc2909b977">emberAfOtaClientStartCallback</a> (void)</td></tr>
<tr class="memdesc:ga5d84a87643c71e97075447dc2909b977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Client Start.  <a href="#ga5d84a87643c71e97075447dc2909b977">More...</a><br /></td></tr>
<tr class="separator:ga5d84a87643c71e97075447dc2909b977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96fe64087e2f63603e2cd76270fe69bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga96fe64087e2f63603e2cd76270fe69bb">emberAfOtaClientVersionInfoCallback</a> (<a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *currentImageInfo, int16u *hardwareVersion)</td></tr>
<tr class="memdesc:ga96fe64087e2f63603e2cd76270fe69bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Client Version Info.  <a href="#ga96fe64087e2f63603e2cd76270fe69bb">More...</a><br /></td></tr>
<tr class="separator:ga96fe64087e2f63603e2cd76270fe69bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae935294acbb85cfaa41529133723e410"><td class="memItemLeft" align="right" valign="top">int8u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gae935294acbb85cfaa41529133723e410">emberAfOtaPageRequestServerPolicyCallback</a> (void)</td></tr>
<tr class="memdesc:gae935294acbb85cfaa41529133723e410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Page Request Server Policy.  <a href="#gae935294acbb85cfaa41529133723e410">More...</a><br /></td></tr>
<tr class="separator:gae935294acbb85cfaa41529133723e410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fdc4d4b364bb5f20e6c790d4c9d6b55"><td class="memItemLeft" align="right" valign="top">int8u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga4fdc4d4b364bb5f20e6c790d4c9d6b55">emberAfOtaServerBlockSizeCallback</a> (EmberNodeId clientNodeId)</td></tr>
<tr class="memdesc:ga4fdc4d4b364bb5f20e6c790d4c9d6b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Server Block Size.  <a href="#ga4fdc4d4b364bb5f20e6c790d4c9d6b55">More...</a><br /></td></tr>
<tr class="separator:ga4fdc4d4b364bb5f20e6c790d4c9d6b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacba65584309da13d8e719d5bcb0b87d5"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gacba65584309da13d8e719d5bcb0b87d5">emberAfOtaServerIncomingMessageRawCallback</a> (<a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *message)</td></tr>
<tr class="memdesc:gacba65584309da13d8e719d5bcb0b87d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Server Incoming Message Raw.  <a href="#gacba65584309da13d8e719d5bcb0b87d5">More...</a><br /></td></tr>
<tr class="separator:gacba65584309da13d8e719d5bcb0b87d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f4c048c2838e770f93eac2ad8f20adc"><td class="memItemLeft" align="right" valign="top">int8u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga4f4c048c2838e770f93eac2ad8f20adc">emberAfOtaServerQueryCallback</a> (const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *currentImageId, int16u *hardwareVersion, <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *nextUpgradeImageId)</td></tr>
<tr class="memdesc:ga4f4c048c2838e770f93eac2ad8f20adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Server Query.  <a href="#ga4f4c048c2838e770f93eac2ad8f20adc">More...</a><br /></td></tr>
<tr class="separator:ga4f4c048c2838e770f93eac2ad8f20adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga738a287be2c11f05f808b7633bf01acd"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga738a287be2c11f05f808b7633bf01acd">emberAfOtaServerSendImageNotifyCallback</a> (EmberNodeId dest, int8u endpoint, int8u payloadType, int8u queryJitter, const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *id)</td></tr>
<tr class="memdesc:ga738a287be2c11f05f808b7633bf01acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Server Send Image Notify.  <a href="#ga738a287be2c11f05f808b7633bf01acd">More...</a><br /></td></tr>
<tr class="separator:ga738a287be2c11f05f808b7633bf01acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e6d4c0409da86cc82d408c1977564ff"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga9e6d4c0409da86cc82d408c1977564ff">emberAfOtaServerUpgradeEndRequestCallback</a> (EmberNodeId source, int8u status, int32u *returnValue, const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *imageId)</td></tr>
<tr class="memdesc:ga9e6d4c0409da86cc82d408c1977564ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Server Upgrade End Request.  <a href="#ga9e6d4c0409da86cc82d408c1977564ff">More...</a><br /></td></tr>
<tr class="separator:ga9e6d4c0409da86cc82d408c1977564ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9d9ad4da635f6002d212c6ccdb93891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaa9d9ad4da635f6002d212c6ccdb93891">emberAfOtaStorageCheckTempDataCallback</a> (int32u *currentOffset, int32u *totalImageSize, <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *newFileInfo)</td></tr>
<tr class="memdesc:gaa9d9ad4da635f6002d212c6ccdb93891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Check Temp Data.  <a href="#gaa9d9ad4da635f6002d212c6ccdb93891">More...</a><br /></td></tr>
<tr class="separator:gaa9d9ad4da635f6002d212c6ccdb93891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a569ac68b77e7486d29f5e2e9b1afe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga2a569ac68b77e7486d29f5e2e9b1afe7">emberAfOtaStorageClearTempDataCallback</a> (void)</td></tr>
<tr class="memdesc:ga2a569ac68b77e7486d29f5e2e9b1afe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Clear Temp Data.  <a href="#ga2a569ac68b77e7486d29f5e2e9b1afe7">More...</a><br /></td></tr>
<tr class="separator:ga2a569ac68b77e7486d29f5e2e9b1afe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa67fd6ae8b12c49906915cc836dbfcc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaa67fd6ae8b12c49906915cc836dbfcc9">emberAfOtaStorageCloseCallback</a> (void)</td></tr>
<tr class="memdesc:gaa67fd6ae8b12c49906915cc836dbfcc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Close.  <a href="#gaa67fd6ae8b12c49906915cc836dbfcc9">More...</a><br /></td></tr>
<tr class="separator:gaa67fd6ae8b12c49906915cc836dbfcc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb936abe9c56adf4c5536bba25d2390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga7fb936abe9c56adf4c5536bba25d2390">emberAfOtaStorageDriverDownloadFinishCallback</a> (int32u offset)</td></tr>
<tr class="memdesc:ga7fb936abe9c56adf4c5536bba25d2390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Driver Download Finish.  <a href="#ga7fb936abe9c56adf4c5536bba25d2390">More...</a><br /></td></tr>
<tr class="separator:ga7fb936abe9c56adf4c5536bba25d2390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54348c69062a44dab273ee140401a31b"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga54348c69062a44dab273ee140401a31b">emberAfOtaStorageDriverInitCallback</a> (void)</td></tr>
<tr class="memdesc:ga54348c69062a44dab273ee140401a31b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Driver Init.  <a href="#ga54348c69062a44dab273ee140401a31b">More...</a><br /></td></tr>
<tr class="separator:ga54348c69062a44dab273ee140401a31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95dba4ca71ca2aa4936a352fa23ca07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaa95dba4ca71ca2aa4936a352fa23ca07">emberAfOtaStorageDriverInvalidateImageCallback</a> (void)</td></tr>
<tr class="memdesc:gaa95dba4ca71ca2aa4936a352fa23ca07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Driver Invalidate Image.  <a href="#gaa95dba4ca71ca2aa4936a352fa23ca07">More...</a><br /></td></tr>
<tr class="separator:gaa95dba4ca71ca2aa4936a352fa23ca07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75dac63f0e4764c9e53d3032200982d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga75dac63f0e4764c9e53d3032200982d5">emberAfOtaStorageDriverPrepareToResumeDownloadCallback</a> (void)</td></tr>
<tr class="memdesc:ga75dac63f0e4764c9e53d3032200982d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Driver Prepare To Resume Download.  <a href="#ga75dac63f0e4764c9e53d3032200982d5">More...</a><br /></td></tr>
<tr class="separator:ga75dac63f0e4764c9e53d3032200982d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5242307347b977973d18b38a609cf49"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gab5242307347b977973d18b38a609cf49">emberAfOtaStorageDriverReadCallback</a> (int32u offset, int32u length, int8u *returnData)</td></tr>
<tr class="memdesc:gab5242307347b977973d18b38a609cf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Driver Read.  <a href="#gab5242307347b977973d18b38a609cf49">More...</a><br /></td></tr>
<tr class="separator:gab5242307347b977973d18b38a609cf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f16934074c547af4aa269105d69779"><td class="memItemLeft" align="right" valign="top">int32u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gab3f16934074c547af4aa269105d69779">emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback</a> (void)</td></tr>
<tr class="memdesc:gab3f16934074c547af4aa269105d69779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Driver Retrieve Last Stored Offset.  <a href="#gab3f16934074c547af4aa269105d69779">More...</a><br /></td></tr>
<tr class="separator:gab3f16934074c547af4aa269105d69779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab9bad051d6dd80904ebc407be4ea97"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga9ab9bad051d6dd80904ebc407be4ea97">emberAfOtaStorageDriverWriteCallback</a> (const int8u *dataToWrite, int32u offset, int32u length)</td></tr>
<tr class="memdesc:ga9ab9bad051d6dd80904ebc407be4ea97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Driver Write.  <a href="#ga9ab9bad051d6dd80904ebc407be4ea97">More...</a><br /></td></tr>
<tr class="separator:ga9ab9bad051d6dd80904ebc407be4ea97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15d1ac93268f8077ca3ffb4955c44433"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga15d1ac93268f8077ca3ffb4955c44433">emberAfOtaStorageFinishDownloadCallback</a> (int32u offset)</td></tr>
<tr class="memdesc:ga15d1ac93268f8077ca3ffb4955c44433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Finish Download.  <a href="#ga15d1ac93268f8077ca3ffb4955c44433">More...</a><br /></td></tr>
<tr class="separator:ga15d1ac93268f8077ca3ffb4955c44433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50bd55a5865e13b40a35f42f5aed0f08"><td class="memItemLeft" align="right" valign="top">int8u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga50bd55a5865e13b40a35f42f5aed0f08">emberAfOtaStorageGetCountCallback</a> (void)</td></tr>
<tr class="memdesc:ga50bd55a5865e13b40a35f42f5aed0f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Get Count.  <a href="#ga50bd55a5865e13b40a35f42f5aed0f08">More...</a><br /></td></tr>
<tr class="separator:ga50bd55a5865e13b40a35f42f5aed0f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae143e396aea8e251297b7cfa61703455"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gae143e396aea8e251297b7cfa61703455">emberAfOtaStorageGetFullHeaderCallback</a> (const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *id, <a class="el" href="structEmberAfOtaHeader.html">EmberAfOtaHeader</a> *returnData)</td></tr>
<tr class="memdesc:gae143e396aea8e251297b7cfa61703455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Get Full Header.  <a href="#gae143e396aea8e251297b7cfa61703455">More...</a><br /></td></tr>
<tr class="separator:gae143e396aea8e251297b7cfa61703455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d8abe312f2023984a1ca2b5b81abd35"><td class="memItemLeft" align="right" valign="top">int32u&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga1d8abe312f2023984a1ca2b5b81abd35">emberAfOtaStorageGetTotalImageSizeCallback</a> (const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *id)</td></tr>
<tr class="memdesc:ga1d8abe312f2023984a1ca2b5b81abd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Get Total Image Size.  <a href="#ga1d8abe312f2023984a1ca2b5b81abd35">More...</a><br /></td></tr>
<tr class="separator:ga1d8abe312f2023984a1ca2b5b81abd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38af5865d93348e362d5212d96b5fffe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga38af5865d93348e362d5212d96b5fffe">emberAfOtaStorageInitCallback</a> (void)</td></tr>
<tr class="memdesc:ga38af5865d93348e362d5212d96b5fffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Init.  <a href="#ga38af5865d93348e362d5212d96b5fffe">More...</a><br /></td></tr>
<tr class="separator:ga38af5865d93348e362d5212d96b5fffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036f2ec2145a8d2e7de1b3f5c76ae195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga036f2ec2145a8d2e7de1b3f5c76ae195">emberAfOtaStorageIteratorFirstCallback</a> (void)</td></tr>
<tr class="memdesc:ga036f2ec2145a8d2e7de1b3f5c76ae195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Iterator First.  <a href="#ga036f2ec2145a8d2e7de1b3f5c76ae195">More...</a><br /></td></tr>
<tr class="separator:ga036f2ec2145a8d2e7de1b3f5c76ae195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59426f6009bccd3e59dedf122573d60e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga59426f6009bccd3e59dedf122573d60e">emberAfOtaStorageIteratorNextCallback</a> (void)</td></tr>
<tr class="memdesc:ga59426f6009bccd3e59dedf122573d60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Iterator Next.  <a href="#ga59426f6009bccd3e59dedf122573d60e">More...</a><br /></td></tr>
<tr class="separator:ga59426f6009bccd3e59dedf122573d60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8f353175b38004d23083ae0f028b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gafa8f353175b38004d23083ae0f028b9c">emberAfOtaStorageReadImageDataCallback</a> (const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *id, int32u offset, int32u length, int8u *returnData, int32u *returnedLength)</td></tr>
<tr class="memdesc:gafa8f353175b38004d23083ae0f028b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Read Image Data.  <a href="#gafa8f353175b38004d23083ae0f028b9c">More...</a><br /></td></tr>
<tr class="separator:gafa8f353175b38004d23083ae0f028b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga112cc89cd7dfcab426b28bcc776f23a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga112cc89cd7dfcab426b28bcc776f23a0">emberAfOtaStorageSearchCallback</a> (int16u manufacturerId, int16u imageTypeId, const int16u *hardwareVersion)</td></tr>
<tr class="memdesc:ga112cc89cd7dfcab426b28bcc776f23a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Search.  <a href="#ga112cc89cd7dfcab426b28bcc776f23a0">More...</a><br /></td></tr>
<tr class="separator:ga112cc89cd7dfcab426b28bcc776f23a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38fee9029d511a3486793be94e1d5c9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga38fee9029d511a3486793be94e1d5c9e">emberAfOtaStorageWriteTempDataCallback</a> (int32u offset, int32u length, const int8u *data)</td></tr>
<tr class="memdesc:ga38fee9029d511a3486793be94e1d5c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ota Storage Write Temp Data.  <a href="#ga38fee9029d511a3486793be94e1d5c9e">More...</a><br /></td></tr>
<tr class="separator:ga38fee9029d511a3486793be94e1d5c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1a0d028ffc7fa8e0ed7271eb89faf86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gac1a0d028ffc7fa8e0ed7271eb89faf86">emberAfOutgoingPacketFilterCallback</a> (<a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a> packetType, int8u *packetData, int8u *size_p, void *data)</td></tr>
<tr class="memdesc:gac1a0d028ffc7fa8e0ed7271eb89faf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outgoing Packet Filter.  <a href="#gac1a0d028ffc7fa8e0ed7271eb89faf86">More...</a><br /></td></tr>
<tr class="separator:gac1a0d028ffc7fa8e0ed7271eb89faf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5b696b64ec5291caf0d246bfce60fce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ember__types.html#gadfde62e4cdd51e13bcf9fc58a2b9d7c7">EmberZdoStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gae5b696b64ec5291caf0d246bfce60fce">emberAfPartnerLinkKeyExchangeRequestCallback</a> (EmberEUI64 partner)</td></tr>
<tr class="memdesc:gae5b696b64ec5291caf0d246bfce60fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partner Link Key Exchange Request.  <a href="#gae5b696b64ec5291caf0d246bfce60fce">More...</a><br /></td></tr>
<tr class="separator:gae5b696b64ec5291caf0d246bfce60fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga507743f1f7c9e2b825adfca4026cf7ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga507743f1f7c9e2b825adfca4026cf7ed">emberAfPartnerLinkKeyExchangeResponseCallback</a> (EmberNodeId sender, <a class="el" href="group__ember__types.html#gadfde62e4cdd51e13bcf9fc58a2b9d7c7">EmberZdoStatus</a> status)</td></tr>
<tr class="memdesc:ga507743f1f7c9e2b825adfca4026cf7ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partner Link Key Exchange Response.  <a href="#ga507743f1f7c9e2b825adfca4026cf7ed">More...</a><br /></td></tr>
<tr class="separator:ga507743f1f7c9e2b825adfca4026cf7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0c3351b2b3dbf3cb123b4238b5d947d"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gad0c3351b2b3dbf3cb123b4238b5d947d">emberAfPerformingKeyEstablishmentCallback</a> (void)</td></tr>
<tr class="memdesc:gad0c3351b2b3dbf3cb123b4238b5d947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performing Key Establishment.  <a href="#gad0c3351b2b3dbf3cb123b4238b5d947d">More...</a><br /></td></tr>
<tr class="separator:gad0c3351b2b3dbf3cb123b4238b5d947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga732594f5f2825ccc4c9ee9c6df873fba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga732594f5f2825ccc4c9ee9c6df873fba">emberAfPostAttributeChangeCallback</a> (int8u endpoint, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, <a class="el" href="group__aftypes.html#ga6f3b7c4757642dc04d42b880720416db">EmberAfAttributeId</a> attributeId, int8u mask, int16u manufacturerCode, int8u type, int8u size, int8u *value)</td></tr>
<tr class="memdesc:ga732594f5f2825ccc4c9ee9c6df873fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post Attribute Change.  <a href="#ga732594f5f2825ccc4c9ee9c6df873fba">More...</a><br /></td></tr>
<tr class="separator:ga732594f5f2825ccc4c9ee9c6df873fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed382b21c3f06529e7fd50d95e67d21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaed382b21c3f06529e7fd50d95e67d21c">emberAfPostEm4ResetCallback</a> (void)</td></tr>
<tr class="memdesc:gaed382b21c3f06529e7fd50d95e67d21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post Em4 Reset.  <a href="#gaed382b21c3f06529e7fd50d95e67d21c">More...</a><br /></td></tr>
<tr class="separator:gaed382b21c3f06529e7fd50d95e67d21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8e86c17374ab8f027eda8a7c12e4ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__enums.html#ga6047361ca88bd5c16bb7bb759fa6da9d">EmberAfStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga6a8e86c17374ab8f027eda8a7c12e4ef">emberAfPreAttributeChangeCallback</a> (int8u endpoint, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, <a class="el" href="group__aftypes.html#ga6f3b7c4757642dc04d42b880720416db">EmberAfAttributeId</a> attributeId, int8u mask, int16u manufacturerCode, int8u type, int8u size, int8u *value)</td></tr>
<tr class="memdesc:ga6a8e86c17374ab8f027eda8a7c12e4ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre Attribute Change.  <a href="#ga6a8e86c17374ab8f027eda8a7c12e4ef">More...</a><br /></td></tr>
<tr class="separator:ga6a8e86c17374ab8f027eda8a7c12e4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53c2f48693fe831e3b12dcc376b8af21"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga53c2f48693fe831e3b12dcc376b8af21">emberAfPreCliSendCallback</a> (<a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, EmberNodeId source, EmberNodeId destination, int8u *message, int16u messageLength)</td></tr>
<tr class="memdesc:ga53c2f48693fe831e3b12dcc376b8af21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre Cli Send.  <a href="#ga53c2f48693fe831e3b12dcc376b8af21">More...</a><br /></td></tr>
<tr class="separator:ga53c2f48693fe831e3b12dcc376b8af21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec152832909bba47a43ceaf009dfacc0"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaec152832909bba47a43ceaf009dfacc0">emberAfPreCommandReceivedCallback</a> (<a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *cmd)</td></tr>
<tr class="memdesc:gaec152832909bba47a43ceaf009dfacc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre Command Received.  <a href="#gaec152832909bba47a43ceaf009dfacc0">More...</a><br /></td></tr>
<tr class="separator:gaec152832909bba47a43ceaf009dfacc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec79a8993549ad42bd4fa5b7562d99fb"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaec79a8993549ad42bd4fa5b7562d99fb">emberAfPreMessageReceivedCallback</a> (<a class="el" href="structEmberAfIncomingMessage.html">EmberAfIncomingMessage</a> *incomingMessage)</td></tr>
<tr class="memdesc:gaec79a8993549ad42bd4fa5b7562d99fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre Message Received.  <a href="#gaec79a8993549ad42bd4fa5b7562d99fb">More...</a><br /></td></tr>
<tr class="separator:gaec79a8993549ad42bd4fa5b7562d99fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9ee9ee54614df2b5df3dbb8361ba587"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gae9ee9ee54614df2b5df3dbb8361ba587">emberAfPreMessageSendCallback</a> (<a class="el" href="structEmberAfMessageStruct.html">EmberAfMessageStruct</a> *messageStruct, <a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> *status)</td></tr>
<tr class="memdesc:gae9ee9ee54614df2b5df3dbb8361ba587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre Message Send.  <a href="#gae9ee9ee54614df2b5df3dbb8361ba587">More...</a><br /></td></tr>
<tr class="separator:gae9ee9ee54614df2b5df3dbb8361ba587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db43d8f532633c7d4111047c5d13967"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga3db43d8f532633c7d4111047c5d13967">emberAfPreNcpResetCallback</a> (void)</td></tr>
<tr class="memdesc:ga3db43d8f532633c7d4111047c5d13967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre Ncp Reset.  <a href="#ga3db43d8f532633c7d4111047c5d13967">More...</a><br /></td></tr>
<tr class="separator:ga3db43d8f532633c7d4111047c5d13967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga583b72f2cf688811b2599c4736385234"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga583b72f2cf688811b2599c4736385234">emberAfPreZDOMessageReceivedCallback</a> (EmberNodeId emberNodeId, <a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, int8u *message, int16u length)</td></tr>
<tr class="memdesc:ga583b72f2cf688811b2599c4736385234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pre ZDO Message Received.  <a href="#ga583b72f2cf688811b2599c4736385234">More...</a><br /></td></tr>
<tr class="separator:ga583b72f2cf688811b2599c4736385234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713ebf2fb5a83cd77bde288bac0a72b6"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga713ebf2fb5a83cd77bde288bac0a72b6">emberAfReadAttributesResponseCallback</a> (<a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int8u *buffer, int16u bufLen)</td></tr>
<tr class="memdesc:ga713ebf2fb5a83cd77bde288bac0a72b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Attributes Response.  <a href="#ga713ebf2fb5a83cd77bde288bac0a72b6">More...</a><br /></td></tr>
<tr class="separator:ga713ebf2fb5a83cd77bde288bac0a72b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad50e938adb3fe91c351527060392bf77"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gad50e938adb3fe91c351527060392bf77">emberAfReadReportingConfigurationCommandCallback</a> (const <a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *cmd)</td></tr>
<tr class="memdesc:gad50e938adb3fe91c351527060392bf77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Reporting Configuration Command.  <a href="#gad50e938adb3fe91c351527060392bf77">More...</a><br /></td></tr>
<tr class="separator:gad50e938adb3fe91c351527060392bf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86abbb10f2fd7b6ab952fd234407cc1f"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga86abbb10f2fd7b6ab952fd234407cc1f">emberAfReadReportingConfigurationResponseCallback</a> (<a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int8u *buffer, int16u bufLen)</td></tr>
<tr class="memdesc:ga86abbb10f2fd7b6ab952fd234407cc1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Reporting Configuration Response.  <a href="#ga86abbb10f2fd7b6ab952fd234407cc1f">More...</a><br /></td></tr>
<tr class="separator:ga86abbb10f2fd7b6ab952fd234407cc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177337a420868bcb18ab4ebb66e1cc65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga177337a420868bcb18ab4ebb66e1cc65">emberAfRegistrationAbortCallback</a> (void)</td></tr>
<tr class="memdesc:ga177337a420868bcb18ab4ebb66e1cc65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registration Abort.  <a href="#ga177337a420868bcb18ab4ebb66e1cc65">More...</a><br /></td></tr>
<tr class="separator:ga177337a420868bcb18ab4ebb66e1cc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedd106e7582b7e655a6f9406e44efd67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaedd106e7582b7e655a6f9406e44efd67">emberAfRegistrationCallback</a> (boolean success)</td></tr>
<tr class="memdesc:gaedd106e7582b7e655a6f9406e44efd67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registration.  <a href="#gaedd106e7582b7e655a6f9406e44efd67">More...</a><br /></td></tr>
<tr class="separator:gaedd106e7582b7e655a6f9406e44efd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ca0d1b59b5433bd839e8e3835d9b04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga41ca0d1b59b5433bd839e8e3835d9b04">emberAfRegistrationStartCallback</a> (void)</td></tr>
<tr class="memdesc:ga41ca0d1b59b5433bd839e8e3835d9b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registration Start.  <a href="#ga41ca0d1b59b5433bd839e8e3835d9b04">More...</a><br /></td></tr>
<tr class="separator:ga41ca0d1b59b5433bd839e8e3835d9b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc003c56b8ec51e55a363f4e6108cde6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gadc003c56b8ec51e55a363f4e6108cde6">emberAfRemoteDeleteBindingPermissionCallback</a> (int8u index)</td></tr>
<tr class="memdesc:gadc003c56b8ec51e55a363f4e6108cde6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote Delete Binding Permission.  <a href="#gadc003c56b8ec51e55a363f4e6108cde6">More...</a><br /></td></tr>
<tr class="separator:gadc003c56b8ec51e55a363f4e6108cde6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga511fcf6ec05c1196b3ac30f77c6a6784"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga511fcf6ec05c1196b3ac30f77c6a6784">emberAfRemoteSetBindingPermissionCallback</a> (const <a class="el" href="structEmberBindingTableEntry.html">EmberBindingTableEntry</a> *entry)</td></tr>
<tr class="memdesc:ga511fcf6ec05c1196b3ac30f77c6a6784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remote Set Binding Permission.  <a href="#ga511fcf6ec05c1196b3ac30f77c6a6784">More...</a><br /></td></tr>
<tr class="separator:ga511fcf6ec05c1196b3ac30f77c6a6784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa16a06c23b6026d1699c6882c16dfd86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaa16a06c23b6026d1699c6882c16dfd86">emberAfRemoveFromCurrentAppTasksCallback</a> (<a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a> tasks)</td></tr>
<tr class="memdesc:gaa16a06c23b6026d1699c6882c16dfd86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove From Current App Tasks.  <a href="#gaa16a06c23b6026d1699c6882c16dfd86">More...</a><br /></td></tr>
<tr class="separator:gaa16a06c23b6026d1699c6882c16dfd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4021eb950c44908616c255eb3b244ba"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gad4021eb950c44908616c255eb3b244ba">emberAfReportAttributesCallback</a> (<a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int8u *buffer, int16u bufLen)</td></tr>
<tr class="memdesc:gad4021eb950c44908616c255eb3b244ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report Attributes.  <a href="#gad4021eb950c44908616c255eb3b244ba">More...</a><br /></td></tr>
<tr class="separator:gad4021eb950c44908616c255eb3b244ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga319690719c55a7752b32d4ee6cc15eea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga319690719c55a7752b32d4ee6cc15eea">emberAfReportingAttributeChangeCallback</a> (int8u endpoint, <a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, <a class="el" href="group__aftypes.html#ga6f3b7c4757642dc04d42b880720416db">EmberAfAttributeId</a> attributeId, int8u mask, int16u manufacturerCode, <a class="el" href="group__aftypes.html#gabf10c4a79c0dc5e33c9bea77b892b177">EmberAfAttributeType</a> type, int8u *data)</td></tr>
<tr class="memdesc:ga319690719c55a7752b32d4ee6cc15eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reporting Attribute Change.  <a href="#ga319690719c55a7752b32d4ee6cc15eea">More...</a><br /></td></tr>
<tr class="separator:ga319690719c55a7752b32d4ee6cc15eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga618aeaa5c0d86fad2ad968197e2234e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga618aeaa5c0d86fad2ad968197e2234e6">emberAfScanCompleteCallback</a> (int8u channel, <a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> status)</td></tr>
<tr class="memdesc:ga618aeaa5c0d86fad2ad968197e2234e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan Complete.  <a href="#ga618aeaa5c0d86fad2ad968197e2234e6">More...</a><br /></td></tr>
<tr class="separator:ga618aeaa5c0d86fad2ad968197e2234e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a75c0ab3724ae27c2823c2e10f73648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga3a75c0ab3724ae27c2823c2e10f73648">emberAfScanErrorCallback</a> (<a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> status)</td></tr>
<tr class="memdesc:ga3a75c0ab3724ae27c2823c2e10f73648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan Error.  <a href="#ga3a75c0ab3724ae27c2823c2e10f73648">More...</a><br /></td></tr>
<tr class="separator:ga3a75c0ab3724ae27c2823c2e10f73648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc453aeea9afafefb02de0df23f4a1b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gacc453aeea9afafefb02de0df23f4a1b2">emberAfSecurityInitCallback</a> (<a class="el" href="structEmberInitialSecurityState.html">EmberInitialSecurityState</a> *state, <a class="el" href="group__ember__types.html#ga753acda7a446dffa3629ef3cfde83406">EmberExtendedSecurityBitmask</a> *extended, boolean trustCenter)</td></tr>
<tr class="memdesc:gacc453aeea9afafefb02de0df23f4a1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Security Init.  <a href="#gacc453aeea9afafefb02de0df23f4a1b2">More...</a><br /></td></tr>
<tr class="separator:gacc453aeea9afafefb02de0df23f4a1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43656aeea835ff0ac82fc419fcae30ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga43656aeea835ff0ac82fc419fcae30ba">emberAfSetDefaultPollControlCallback</a> (<a class="el" href="group__aftypes.html#gab3daa30a7fe8edc180c38c109be2551e">EmberAfEventPollControl</a> control)</td></tr>
<tr class="memdesc:ga43656aeea835ff0ac82fc419fcae30ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Default Poll Control.  <a href="#ga43656aeea835ff0ac82fc419fcae30ba">More...</a><br /></td></tr>
<tr class="separator:ga43656aeea835ff0ac82fc419fcae30ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41d64b25c22fc2c0015e0a257cd05a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga41d64b25c22fc2c0015e0a257cd05a6a">emberAfSetDefaultSleepControlCallback</a> (<a class="el" href="af-ncp_8h.html#a4a612352f4b32cb9713cc3150a04c776">EmberAfEventSleepControl</a> control)</td></tr>
<tr class="memdesc:ga41d64b25c22fc2c0015e0a257cd05a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Default Sleep Control.  <a href="#ga41d64b25c22fc2c0015e0a257cd05a6a">More...</a><br /></td></tr>
<tr class="separator:ga41d64b25c22fc2c0015e0a257cd05a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b71f4b0114b6b251d2e489cbd48fa19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga3b71f4b0114b6b251d2e489cbd48fa19">emberAfSetFormAndJoinExtendedPanIdCallback</a> (const int8u *extendedPanId)</td></tr>
<tr class="memdesc:ga3b71f4b0114b6b251d2e489cbd48fa19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Form And Join Extended Pan Id.  <a href="#ga3b71f4b0114b6b251d2e489cbd48fa19">More...</a><br /></td></tr>
<tr class="separator:ga3b71f4b0114b6b251d2e489cbd48fa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc4138cffb5f703239209d26c17608a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gadc4138cffb5f703239209d26c17608a1">emberAfSetLongPollIntervalMsCallback</a> (int32u longPollIntervalMs)</td></tr>
<tr class="memdesc:gadc4138cffb5f703239209d26c17608a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Long Poll Interval Ms.  <a href="#gadc4138cffb5f703239209d26c17608a1">More...</a><br /></td></tr>
<tr class="separator:gadc4138cffb5f703239209d26c17608a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga466f149f3ccb4f4786ade14a1337db89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga466f149f3ccb4f4786ade14a1337db89">emberAfSetLongPollIntervalQsCallback</a> (int32u longPollIntervalQs)</td></tr>
<tr class="memdesc:ga466f149f3ccb4f4786ade14a1337db89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Long Poll Interval Qs.  <a href="#ga466f149f3ccb4f4786ade14a1337db89">More...</a><br /></td></tr>
<tr class="separator:ga466f149f3ccb4f4786ade14a1337db89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96a9d103309a992615933d3e2f4d8e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gad96a9d103309a992615933d3e2f4d8e0">emberAfSetShortPollIntervalMsCallback</a> (int16u shortPollIntervalMs)</td></tr>
<tr class="memdesc:gad96a9d103309a992615933d3e2f4d8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Short Poll Interval Ms.  <a href="#gad96a9d103309a992615933d3e2f4d8e0">More...</a><br /></td></tr>
<tr class="separator:gad96a9d103309a992615933d3e2f4d8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b31476adb30b232b6382a503b6d931"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gac0b31476adb30b232b6382a503b6d931">emberAfSetShortPollIntervalQsCallback</a> (int16u shortPollIntervalQs)</td></tr>
<tr class="memdesc:gac0b31476adb30b232b6382a503b6d931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Short Poll Interval Qs.  <a href="#gac0b31476adb30b232b6382a503b6d931">More...</a><br /></td></tr>
<tr class="separator:gac0b31476adb30b232b6382a503b6d931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a04ff39b1a1f605497467d91b96b9a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga1a04ff39b1a1f605497467d91b96b9a4">emberAfSetSourceRouteOverheadCallback</a> (EmberNodeId destination, int8u overhead)</td></tr>
<tr class="memdesc:ga1a04ff39b1a1f605497467d91b96b9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Source Route Overhead.  <a href="#ga1a04ff39b1a1f605497467d91b96b9a4">More...</a><br /></td></tr>
<tr class="separator:ga1a04ff39b1a1f605497467d91b96b9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cc9adbb010577b1fd7188b9fc049c20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga8cc9adbb010577b1fd7188b9fc049c20">emberAfSetTimeCallback</a> (int32u utcTime)</td></tr>
<tr class="memdesc:ga8cc9adbb010577b1fd7188b9fc049c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Time.  <a href="#ga8cc9adbb010577b1fd7188b9fc049c20">More...</a><br /></td></tr>
<tr class="separator:ga8cc9adbb010577b1fd7188b9fc049c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3ea61cea9ce2d9db35742ee223932d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gac3ea61cea9ce2d9db35742ee223932d7">emberAfSetWakeTimeoutBitmaskCallback</a> (<a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a> tasks)</td></tr>
<tr class="memdesc:gac3ea61cea9ce2d9db35742ee223932d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Wake Timeout Bitmask.  <a href="#gac3ea61cea9ce2d9db35742ee223932d7">More...</a><br /></td></tr>
<tr class="separator:gac3ea61cea9ce2d9db35742ee223932d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84745346d7041503b20d1da84e527e75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga84745346d7041503b20d1da84e527e75">emberAfSetWakeTimeoutMsCallback</a> (int16u wakeTimeoutMs)</td></tr>
<tr class="memdesc:ga84745346d7041503b20d1da84e527e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Wake Timeout Ms.  <a href="#ga84745346d7041503b20d1da84e527e75">More...</a><br /></td></tr>
<tr class="separator:ga84745346d7041503b20d1da84e527e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3b342d09b5e4101c0b7ef95db96552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaee3b342d09b5e4101c0b7ef95db96552">emberAfSetWakeTimeoutQsCallback</a> (int16u wakeTimeoutQs)</td></tr>
<tr class="memdesc:gaee3b342d09b5e4101c0b7ef95db96552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Wake Timeout Qs.  <a href="#gaee3b342d09b5e4101c0b7ef95db96552">More...</a><br /></td></tr>
<tr class="separator:gaee3b342d09b5e4101c0b7ef95db96552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb32a03da52b0139e6eff4cb503c6ed7"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gadb32a03da52b0139e6eff4cb503c6ed7">emberAfStackStatusCallback</a> (<a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> status)</td></tr>
<tr class="memdesc:gadb32a03da52b0139e6eff4cb503c6ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack Status.  <a href="#gadb32a03da52b0139e6eff4cb503c6ed7">More...</a><br /></td></tr>
<tr class="separator:gadb32a03da52b0139e6eff4cb503c6ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0bb8331be5aae0d7098ba396436b6b5"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gab0bb8331be5aae0d7098ba396436b6b5">emberAfStartMoveCallback</a> (void)</td></tr>
<tr class="memdesc:gab0bb8331be5aae0d7098ba396436b6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start Move.  <a href="#gab0bb8331be5aae0d7098ba396436b6b5">More...</a><br /></td></tr>
<tr class="separator:gab0bb8331be5aae0d7098ba396436b6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfeca148a9f2fe7ba0ca3521bd13e010"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gadfeca148a9f2fe7ba0ca3521bd13e010">emberAfStartSearchForJoinableNetworkCallback</a> (void)</td></tr>
<tr class="memdesc:gadfeca148a9f2fe7ba0ca3521bd13e010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start Search For Joinable Network.  <a href="#gadfeca148a9f2fe7ba0ca3521bd13e010">More...</a><br /></td></tr>
<tr class="separator:gadfeca148a9f2fe7ba0ca3521bd13e010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e859ed026f8548af716446ea880659a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga4e859ed026f8548af716446ea880659a">emberAfStopMoveCallback</a> (void)</td></tr>
<tr class="memdesc:ga4e859ed026f8548af716446ea880659a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop Move.  <a href="#ga4e859ed026f8548af716446ea880659a">More...</a><br /></td></tr>
<tr class="separator:ga4e859ed026f8548af716446ea880659a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff084e30a38b15dc5ab691b4f41f35c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga5ff084e30a38b15dc5ab691b4f41f35c">emberAfTrustCenterJoinCallback</a> (EmberNodeId newNodeId, EmberEUI64 newNodeEui64, EmberNodeId parentOfNewNode, <a class="el" href="group__ember__types.html#gae85447b46d5b9eae4ebca3e656646659">EmberDeviceUpdate</a> status, <a class="el" href="group__ember__types.html#ga395f1f81009b39817c6ad771c398827b">EmberJoinDecision</a> decision)</td></tr>
<tr class="memdesc:ga5ff084e30a38b15dc5ab691b4f41f35c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trust Center Join.  <a href="#ga5ff084e30a38b15dc5ab691b4f41f35c">More...</a><br /></td></tr>
<tr class="separator:ga5ff084e30a38b15dc5ab691b4f41f35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b17b4c0e4e9dd59e5986ea1cc43d7f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga1b17b4c0e4e9dd59e5986ea1cc43d7f6">emberAfTrustCenterKeepaliveAbortCallback</a> (void)</td></tr>
<tr class="memdesc:ga1b17b4c0e4e9dd59e5986ea1cc43d7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trust Center Keepalive Abort.  <a href="#ga1b17b4c0e4e9dd59e5986ea1cc43d7f6">More...</a><br /></td></tr>
<tr class="separator:ga1b17b4c0e4e9dd59e5986ea1cc43d7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61e4377ff33ab876ea0238ea0978bac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga61e4377ff33ab876ea0238ea0978bac6">emberAfTrustCenterKeepaliveUpdateCallback</a> (boolean registrationComplete)</td></tr>
<tr class="memdesc:ga61e4377ff33ab876ea0238ea0978bac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trust Center Keepalive Update.  <a href="#ga61e4377ff33ab876ea0238ea0978bac6">More...</a><br /></td></tr>
<tr class="separator:ga61e4377ff33ab876ea0238ea0978bac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1de945082979387aa2f369b62fdc41a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gaf1de945082979387aa2f369b62fdc41a">emberAfUnusedPanIdFoundCallback</a> (EmberPanId panId, int8u channel)</td></tr>
<tr class="memdesc:gaf1de945082979387aa2f369b62fdc41a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unused Pan Id Found.  <a href="#gaf1de945082979387aa2f369b62fdc41a">More...</a><br /></td></tr>
<tr class="separator:gaf1de945082979387aa2f369b62fdc41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad71c19f4df352778fbee455d89ca91ab"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#gad71c19f4df352778fbee455d89ca91ab">emberAfWriteAttributesResponseCallback</a> (<a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a> clusterId, int8u *buffer, int16u bufLen)</td></tr>
<tr class="memdesc:gad71c19f4df352778fbee455d89ca91ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Attributes Response.  <a href="#gad71c19f4df352778fbee455d89ca91ab">More...</a><br /></td></tr>
<tr class="separator:gad71c19f4df352778fbee455d89ca91ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac3589b3b019f27f1dffe7f1231451b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nonClustercallback.html#ga0ac3589b3b019f27f1dffe7f1231451b">emberAfZigbeeKeyEstablishmentCallback</a> (EmberEUI64 partner, <a class="el" href="group__ember__types.html#ga023e020a774781d0819dd1684c9962e1">EmberKeyStatus</a> status)</td></tr>
<tr class="memdesc:ga0ac3589b3b019f27f1dffe7f1231451b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zigbee Key Establishment.  <a href="#ga0ac3589b3b019f27f1dffe7f1231451b">More...</a><br /></td></tr>
<tr class="separator:ga0ac3589b3b019f27f1dffe7f1231451b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gada2e4d46a29d5f8203cac97485ed1155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada2e4d46a29d5f8203cac97485ed1155">&#9670;&nbsp;</a></span>emberAfAddToCurrentAppTasksCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfAddToCurrentAppTasksCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a>&#160;</td>
          <td class="paramname"><em>tasks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add To Current App Tasks. </p>
<p>This function is only useful to sleepy end devices. This function will note the passed item as part of a set of tasks the application has outstanding (e.g. message sent requiring APS acknwoledgement). This will affect how the application behaves with regard to sleeping and polling. Until the outstanding task is completed, the device may poll more frequently and sleep less often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasks</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadd87f592ea24868bf30988b24d2f3f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd87f592ea24868bf30988b24d2f3f5d">&#9670;&nbsp;</a></span>emberAfAllowNetworkWriteAttributeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga6bbb7962d8ea86644b36c6f64e7868f2">EmberAfAttributeWritePermission</a> emberAfAllowNetworkWriteAttributeCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga6f3b7c4757642dc04d42b880720416db">EmberAfAttributeId</a>&#160;</td>
          <td class="paramname"><em>attributeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow Network Write Attribute. </p>
<p>This function is called by the application framework before it writes an attribute in response to a write attribute request from an external device. The value passed into this callback is the value to which the attribute is to be set by the framework. Example: In mirroring simple metering data on an Energy Services Interface (ESI) (formerly called Energy Service Portal (ESP) in SE 1.0).), a mirrored simple meter needs to write read-only attributes on its mirror. The-meter-mirror sample application, located in app/framework/sample-apps, uses this callback to allow the mirrored device to write simple metering attributes on the mirror regardless of the fact that most simple metering attributes are defined as read-only by the ZigBee specification. Note: The ZCL specification does not (as of this writing) specify any permission-level security for writing writeable attributes. As far as the ZCL specification is concerned, if an attribute is writeable, any device that has a link key for the device should be able to write that attribute. Furthermore if an attribute is read only, it should not be written over the air. Thus, if you implement permissions for writing attributes as a feature, you MAY be operating outside the specification. This is unlikely to be a problem for writing read-only attributes, but it may be a problem for attributes that are writeable according to the specification but restricted by the application implementing this callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">attributeId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">mask</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">value</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">type</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba9ff8b57ad46e090fc6608495cc72e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba9ff8b57ad46e090fc6608495cc72e1">&#9670;&nbsp;</a></span>emberAfAttributeReadAccessCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfAttributeReadAccessCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>attributeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attribute Read Access. </p>
<p>This function is called whenever the Application Framework needs to check access permission for an attribute read.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">attributeId</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafa5adf715ba15f73bd85075309524ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa5adf715ba15f73bd85075309524ab5">&#9670;&nbsp;</a></span>emberAfAttributeWriteAccessCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfAttributeWriteAccessCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>attributeId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attribute Write Access. </p>
<p>This function is called whenever the Application Framework needs to check access permission for an attribute write.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">attributeId</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac561b5bbe5962927104f2c50254c9672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac561b5bbe5962927104f2c50254c9672">&#9670;&nbsp;</a></span>emberAfClearReportTableCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfClearReportTableCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Report Table. </p>
<p>This function is called by the framework when the application should clear the report table. </p>

</div>
</div>
<a id="ga14f2d278e2382436b9b137037b3e9e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14f2d278e2382436b9b137037b3e9e11">&#9670;&nbsp;</a></span>emberAfClusterInitCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfClusterInitCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cluster Init. </p>
<p>This function is called when a specific cluster is initialized. It gives the application an opportunity to take care of cluster initialization procedures. It is called exactly once for each endpoint where cluster is present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9793f3bf26e77340737889b380cf4fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9793f3bf26e77340737889b380cf4fa8">&#9670;&nbsp;</a></span>emberAfClusterSecurityCustomCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfClusterSecurityCustomCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga03537dfe99c3854a75a922ac1974dd29">EmberAfProfileId</a>&#160;</td>
          <td class="paramname"><em>profileId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>incoming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>commandId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cluster Security Custom. </p>
<p>This callback is fired when determining if APS encryption is required for a cluster outside of the specification's required clusters. In other words, for the Smart Energy profile this would be a cluster beyond the list that normally requires APS encryption.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">profileId</td><td>The profile ID Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>The cluster ID Ver.: always </td></tr>
    <tr><td class="paramname">incoming</td><td>Whether this is an incoming or outgoing message. Ver.: always </td></tr>
    <tr><td class="paramname">commandId</td><td>The ZCL command ID being sent/received. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08d06c3736c24a5219b79dce5fac2625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08d06c3736c24a5219b79dce5fac2625">&#9670;&nbsp;</a></span>emberAfConfigureReportingCommandCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfConfigureReportingCommandCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Reporting Command. </p>
<p>This function is called by the application framework when a Configure Reporting command is received from an external device. The Configure Reporting command contains a series of attribute reporting configuration records. The application should return true if the message was processed or false if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0a55474c85defe672362d389e86c25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0a55474c85defe672362d389e86c25e">&#9670;&nbsp;</a></span>emberAfConfigureReportingResponseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfConfigureReportingResponseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>bufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure Reporting Response. </p>
<p>This function is called by the application framework when a Configure Reporting Response command is received from an external device. The application should return true if the message was processed or false if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster identifier of this response. Ver.: always </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer containing the list of attribute status records. Ver.: always </td></tr>
    <tr><td class="paramname">bufLen</td><td>The length in bytes of the list. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a6479692f3576295179d7e73d22de2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a6479692f3576295179d7e73d22de2b">&#9670;&nbsp;</a></span>emberAfDefaultResponseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfDefaultResponseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>commandId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__enums.html#ga6047361ca88bd5c16bb7bb759fa6da9d">EmberAfStatus</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Response. </p>
<p>This function is called by the application framework when a Default Response command is received from an external device. The application should return true if the message was processed or false if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster identifier of this response. Ver.: always </td></tr>
    <tr><td class="paramname">commandId</td><td>The command identifier to which this is a response. Ver.: always </td></tr>
    <tr><td class="paramname">status</td><td>Specifies either SUCCESS or the nature of the error that was detected in the received command. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4ff04fb23a01713b32f93ecef7b75219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ff04fb23a01713b32f93ecef7b75219">&#9670;&nbsp;</a></span>emberAfDiscoverAttributesResponseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfDiscoverAttributesResponseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>discoveryComplete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>bufLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>extended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover Attributes Response. </p>
<p>This function is called by the application framework when a Discover Attributes Response or Discover Attributes Extended Response command is received from an external device. The Discover Attributes Response command contains a bool indicating if discovery is complete and a list of zero or more attribute identifier/type records. The final argument indicates whether the response is in the extended format or not. The application should return true if the message was processed or false if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster identifier of this response. Ver.: always </td></tr>
    <tr><td class="paramname">discoveryComplete</td><td>Indicates whether there are more attributes to be discovered. true if there are no more attributes to be discovered. Ver.: always </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer containing the list of attribute identifier/type records. Ver.: always </td></tr>
    <tr><td class="paramname">bufLen</td><td>The length in bytes of the list. Ver.: always </td></tr>
    <tr><td class="paramname">extended</td><td>Indicates whether the response is in the extended format or not. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3c4b18cdfc674465ee99579be3a4705c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c4b18cdfc674465ee99579be3a4705c">&#9670;&nbsp;</a></span>emberAfDiscoverCommandsGeneratedResponseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfDiscoverCommandsGeneratedResponseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>discoveryComplete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>commandIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>commandIdCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover Commands Generated Response. </p>
<p>This function is called by the framework when Discover Commands Generated Response is received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster identifier of this response. Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Manufacturer code Ver.: always </td></tr>
    <tr><td class="paramname">discoveryComplete</td><td>Indicates whether there are more commands to be discovered. Ver.: always </td></tr>
    <tr><td class="paramname">commandIds</td><td>Buffer containing the list of command identifiers. Ver.: always </td></tr>
    <tr><td class="paramname">commandIdCount</td><td>The length of bytes of the list, whish is the same as the number of identifiers. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24dad599cde20a8b880219fceb426154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24dad599cde20a8b880219fceb426154">&#9670;&nbsp;</a></span>emberAfDiscoverCommandsReceivedResponseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfDiscoverCommandsReceivedResponseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>discoveryComplete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>commandIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>commandIdCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover Commands Received Response. </p>
<p>This function is called by the framework when Discover Commands Received Response is received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster identifier of this response. Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Manufacturer code Ver.: always </td></tr>
    <tr><td class="paramname">discoveryComplete</td><td>Indicates whether there are more commands to be discovered. Ver.: always </td></tr>
    <tr><td class="paramname">commandIds</td><td>Buffer containing the list of command identifiers. Ver.: always </td></tr>
    <tr><td class="paramname">commandIdCount</td><td>The length of bytes of the list, whish is the same as the number of identifiers. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf48005d565f5abffc5ce5a0ce4cc05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf48005d565f5abffc5ce5a0ce4cc05e">&#9670;&nbsp;</a></span>emberAfEepromInitCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfEepromInitCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eeprom Init. </p>
<p>Tells the system to initialize the EEPROM if it is not already initialized. </p>

</div>
</div>
<a id="ga1b375707c38ee7249fd596d005421c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b375707c38ee7249fd596d005421c46">&#9670;&nbsp;</a></span>emberAfEepromNoteInitializedStateCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfEepromNoteInitializedStateCallback </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eeprom Note Initialized State. </p>
<p>Records the state of the EEPROM so that an intelligent driver (like the EEPROM plugin) can re-initialize the driver prior to any calls to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state of the EEPROM, false=re-initalization needed, true=no-re-init needed Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaff17ea7400eb202922146e331369c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaff17ea7400eb202922146e331369c5d">&#9670;&nbsp;</a></span>emberAfEepromShutdownCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfEepromShutdownCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eeprom Shutdown. </p>
<p>Tells the system to shutdown the EEPROM if it is not already shutdown. </p>

</div>
</div>
<a id="ga285ae4ec5dd0f5f02ebea0adb498c92b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga285ae4ec5dd0f5f02ebea0adb498c92b">&#9670;&nbsp;</a></span>emberAfEnergyScanResultCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfEnergyScanResultCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8s&#160;</td>
          <td class="paramname"><em>rssi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Energy Scan Result. </p>
<p>This is called by the low-level stack code when an 802.15.4 energy scan completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The channel where the energy scan took place. Ver.: always </td></tr>
    <tr><td class="paramname">rssi</td><td>The receive signal strength indicator for the channel. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b8273646fe8af6e86913263b3b0f3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8273646fe8af6e86913263b3b0f3ae">&#9670;&nbsp;</a></span>emberAfExternalAttributeReadCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga6047361ca88bd5c16bb7bb759fa6da9d">EmberAfStatus</a> emberAfExternalAttributeReadCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberAfAttributeMetadata.html">EmberAfAttributeMetadata</a> *&#160;</td>
          <td class="paramname"><em>attributeMetadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>maxReadLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External Attribute Read. </p>
<p>Like emberAfExternalAttributeWriteCallback above, this function is called when the framework needs to read an attribute that is not stored within the Application Framework's data structures. All of the important information about the attribute itself is passed as a pointer to an <a class="el" href="structEmberAfAttributeMetadata.html" title="Each attribute has it&#39;s metadata stored in such struct. ">EmberAfAttributeMetadata</a> struct, which is stored within the application and used to manage the attribute. A complete description of the <a class="el" href="structEmberAfAttributeMetadata.html" title="Each attribute has it&#39;s metadata stored in such struct. ">EmberAfAttributeMetadata</a> struct is provided in <a class="el" href="af-types_8h.html" title="The include file for all the types for Ember ApplicationFramework. ">app/framework/include/af-types.h</a> This function assumes that the application is able to read the attribute, write it into the passed buffer, and return immediately. Any attributes that require a state machine for reading and writing are not really candidates for externalization at the present time. The Application Framework does not currently include a state machine for reading or writing attributes that must take place across a series of application ticks. Attributes that cannot be read in a timely manner should be stored within the Application Framework and updated occasionally by the application code from within the emberAfMainTickCallback. If the application was successfully able to read the attribute and write it into the passed buffer, it should return a value of EMBER_ZCL_STATUS_SUCCESS. Ensure that the size of the externally managed attribute value is smaller than what the buffer can hold. In the case of a buffer overflow throw an appropriate error such as EMBER_ZCL_STATUS_INSUFFICIENT_SPACE. Any other return value indicates the application was not able to read the attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">attributeMetadata</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">buffer</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">maxReadLength</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga049a2804a5d9cc3ce7c96884f4160adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga049a2804a5d9cc3ce7c96884f4160adf">&#9670;&nbsp;</a></span>emberAfExternalAttributeWriteCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga6047361ca88bd5c16bb7bb759fa6da9d">EmberAfStatus</a> emberAfExternalAttributeWriteCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberAfAttributeMetadata.html">EmberAfAttributeMetadata</a> *&#160;</td>
          <td class="paramname"><em>attributeMetadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External Attribute Write. </p>
<p>This function is called whenever the Application Framework needs to write an attribute which is not stored within the data structures of the Application Framework itself. One of the new features in Version 2 is the ability to store attributes outside the Framework. This is particularly useful for attributes that do not need to be stored because they can be read off the hardware when they are needed, or are stored in some central location used by many modules within the system. In this case, you can indicate that the attribute is stored externally. When the framework needs to write an external attribute, it makes a call to this callback. This callback is very useful for host micros which need to store attributes in persistent memory. Because each host micro (used with an Ember NCP) has its own type of persistent memory storage, the Application Framework does not include the ability to mark attributes as stored in flash the way that it does for Ember SoCs like the EM35x. On a host micro, any attributes that need to be stored in persistent memory should be marked as external and accessed through the external read and write callbacks. Any host code associated with the persistent storage should be implemented within this callback. All of the important information about the attribute itself is passed as a pointer to an <a class="el" href="structEmberAfAttributeMetadata.html" title="Each attribute has it&#39;s metadata stored in such struct. ">EmberAfAttributeMetadata</a> struct, which is stored within the application and used to manage the attribute. A complete description of the <a class="el" href="structEmberAfAttributeMetadata.html" title="Each attribute has it&#39;s metadata stored in such struct. ">EmberAfAttributeMetadata</a> struct is provided in <a class="el" href="af-types_8h.html" title="The include file for all the types for Ember ApplicationFramework. ">app/framework/include/af-types.h</a>. This function assumes that the application is able to write the attribute and return immediately. Any attributes that require a state machine for reading and writing are not candidates for externalization at the present time. The Application Framework does not currently include a state machine for reading or writing attributes that must take place across a series of application ticks. Attributes that cannot be written immediately should be stored within the Application Framework and updated occasionally by the application code from within the emberAfMainTickCallback. If the application was successfully able to write the attribute, it returns a value of EMBER_ZCL_STATUS_SUCCESS. Any other return value indicates the application was not able to write the attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">attributeMetadata</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">buffer</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad64a82720250a4cb542f3c0d1e79049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad64a82720250a4cb542f3c0d1e79049">&#9670;&nbsp;</a></span>emberAfFindUnusedPanIdAndFormCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfFindUnusedPanIdAndFormCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find Unused Pan Id And Form. </p>
<p>This function is called by the framework to search for an unused PAN id and form a new network. The application should return EMBER_SUCCESS if the operation was initiated successfully. </p>

</div>
</div>
<a id="gad27b880ce5817815221cf83ecd9e3da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad27b880ce5817815221cf83ecd9e3da7">&#9670;&nbsp;</a></span>emberAfGetCurrentAppTasksCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a> emberAfGetCurrentAppTasksCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Current App Tasks. </p>
<p>This function is only useful to sleepy end devices. This function will return the set of tasks the application has outstanding. These tasks affect how the application behaves with regard to sleeping and polling. </p>

</div>
</div>
<a id="ga90ac907c3a64dc77d0f7ec0d3c0a10f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90ac907c3a64dc77d0f7ec0d3c0a10f2">&#9670;&nbsp;</a></span>emberAfGetCurrentPollControlCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#gab3daa30a7fe8edc180c38c109be2551e">EmberAfEventPollControl</a> emberAfGetCurrentPollControlCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Current Poll Control. </p>
<p>This function will retrieve the current poll control that the system is using for the current network. This is determined by examining all the scheduled events and obtaining the most restrictive poll control context across all events. The most restrictive poll control is EMBER_AF_SHORT_POLL followed by EMBER_AF_LONG_POLL. </p>

</div>
</div>
<a id="ga1aba1d55e86c965f4fa76b575dae313c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aba1d55e86c965f4fa76b575dae313c">&#9670;&nbsp;</a></span>emberAfGetCurrentPollIntervalMsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32u emberAfGetCurrentPollIntervalMsCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Current Poll Interval Ms. </p>
<p>This function is only useful to end devices. This function will return the current poll interval (in milliseconds) for the current network. This interval is the maximum amount of time a child is currently waiting between polls of its parent. </p>

</div>
</div>
<a id="gac081eb47e842287eee9660f9ee543774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac081eb47e842287eee9660f9ee543774">&#9670;&nbsp;</a></span>emberAfGetCurrentPollIntervalQsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32u emberAfGetCurrentPollIntervalQsCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Current Poll Interval Qs. </p>
<p>This function is only useful to end devices. This function will return the current poll interval (in quarter seconds) for the current network. This interval is the maximum amount of time a child is currently waiting between polls of its parent. </p>

</div>
</div>
<a id="gae6de87a6b44a1b6377dbbc0eccfffa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6de87a6b44a1b6377dbbc0eccfffa53">&#9670;&nbsp;</a></span>emberAfGetCurrentSleepControlCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="af-ncp_8h.html#a4a612352f4b32cb9713cc3150a04c776">EmberAfEventSleepControl</a> emberAfGetCurrentSleepControlCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Current Sleep Control. </p>
<p>This function will retrieve the current sleep control that the system is using. This is determined by examining all the scheduled events and obtaining the most restrictive sleep control context across all events. The most restrictive sleep control is EMBER_AF_STAY_AWAKE followed by EMBER_AF_OK_TO_SLEEP. </p>

</div>
</div>
<a id="ga9047584e5724c02c98ad08a370c217bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9047584e5724c02c98ad08a370c217bf">&#9670;&nbsp;</a></span>emberAfGetCurrentTimeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32u emberAfGetCurrentTimeCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Current Time. </p>
<p>This callback is called when device attempts to get current time from the hardware. If this device has means to retrieve exact time, then this method should implement it. If the callback can't provide the exact time it should return 0 to indicate failure. Default action is to return 0, which indicates that device does not have access to real time. </p>

</div>
</div>
<a id="ga16f7d8b1edf54a45f9323f979a895eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16f7d8b1edf54a45f9323f979a895eb2">&#9670;&nbsp;</a></span>emberAfGetDefaultPollControlCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#gab3daa30a7fe8edc180c38c109be2551e">EmberAfEventPollControl</a> emberAfGetDefaultPollControlCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Default Poll Control. </p>
<p>This function will retrieve the default poll control for the current network as previously set by <a class="el" href="group__nonClustercallback.html#ga43656aeea835ff0ac82fc419fcae30ba" title="Set Default Poll Control. ">emberAfSetDefaultPollControlCallback()</a>. The default poll control will limit whether the network can long poll. </p>

</div>
</div>
<a id="ga55813ba4f0b9cfd4d460155ae63adfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55813ba4f0b9cfd4d460155ae63adfc0">&#9670;&nbsp;</a></span>emberAfGetDefaultSleepControlCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="af-ncp_8h.html#a4a612352f4b32cb9713cc3150a04c776">EmberAfEventSleepControl</a> emberAfGetDefaultSleepControlCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Default Sleep Control. </p>
<p>This function will retrieve the default sleep control the system is using as previously set by <a class="el" href="group__nonClustercallback.html#ga41d64b25c22fc2c0015e0a257cd05a6a" title="Set Default Sleep Control. ">emberAfSetDefaultSleepControlCallback()</a>. The default sleep control will limit whether the device can sleep. </p>

</div>
</div>
<a id="gaecbe09af36f195d4787bac0cefb867d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecbe09af36f195d4787bac0cefb867d7">&#9670;&nbsp;</a></span>emberAfGetEndpointByIndexCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfGetEndpointByIndexCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>endpointReturn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Endpoint By Index. </p>
<p>Get the endpoint number based on the passed index. By default the framework handles this by managing endpoints based on the precompiled configuration defined in AppBuilder. This callback can override this behavior at runtime and provide additional endpoints or different data than the compiled values. If the index is overridden than the callback shall return true and set the endpointReturn parameter accordingly. A value of 0xFF means the endpoint doesn't exist at that index. Otherwise false must be returned by the callback and the default framework behavior will be executed. This is only applicable to the SOC devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the endpoint. Ver.: always </td></tr>
    <tr><td class="paramname">endpointReturn</td><td>The value of endpoint. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8847c3f3662832ec22b9a9b0da9c3a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8847c3f3662832ec22b9a9b0da9c3a46">&#9670;&nbsp;</a></span>emberAfGetEndpointDescriptionCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfGetEndpointDescriptionCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberEndpointDescription *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Endpoint Description. </p>
<p>This callback is called by the framework whenever it receives a ZDO request to enumerate the details about an endpoint. By default the framework provides the information based on the precompiled endpoint information as defined in AppBuilder. This callback can override that behavior at runtime and return different information. If the endpoint information is being overridden then the callback must return true. Otherwise it should return false, which allows the framework to perform its default behavior. This is only applicable to SOC devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>The endpoint number that is being queried. Ver.: always </td></tr>
    <tr><td class="paramname">result</td><td>This is a pointer to a data structure where the endpoint information is written if the callback is providing the information. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d56d65056d17cabc9167d7ace9d3db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d56d65056d17cabc9167d7ace9d3db3">&#9670;&nbsp;</a></span>emberAfGetEndpointInfoCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfGetEndpointInfoCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>returnNetworkIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberAfEndpointInfoStruct.html">EmberAfEndpointInfoStruct</a> *&#160;</td>
          <td class="paramname"><em>returnEndpointInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Endpoint Info. </p>
<p>This function is a callback to an application implemented endpoint that operates outside the normal application framework. When the framework wishes to perform operations with that endpoint it uses this callback to retrieve the endpoint's information. If the endpoint exists and the application can provide data then true shall be returned. Otherwise the callback must return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>The endpoint to retrieve data for. Ver.: always </td></tr>
    <tr><td class="paramname">returnNetworkIndex</td><td>The index corresponding to the ZigBee network the endpoint belongs to. If not using a multi-network device, 0 must be returned. Otherwise on a multi-network device the stack will switch to this network before sending the message. Ver.: always </td></tr>
    <tr><td class="paramname">returnEndpointInfo</td><td>A pointer to a data struct that will be written with information about the endpoint. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4963bce5e4b1e6a51f8edbb3542c0cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4963bce5e4b1e6a51f8edbb3542c0cc">&#9670;&nbsp;</a></span>emberAfGetFormAndJoinExtendedPanIdCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfGetFormAndJoinExtendedPanIdCallback </td>
          <td>(</td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>resultLocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Form And Join Extended Pan Id. </p>
<p>This callback is called by the framework to get the extended PAN ID used by the current network for forming and joining. The extended PAN ID used for forming and joining is not necessarily the same extended PAN ID actually in use on the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resultLocation</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="network-cli_8c.html#a22aca5b0aff5a5b31b9579aeafbd3643">initNetworkParams()</a>.</p>

</div>
</div>
<a id="ga95c58910c26f2c9728a10b5c5d3aa4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95c58910c26f2c9728a10b5c5d3aa4a2">&#9670;&nbsp;</a></span>emberAfGetLongPollIntervalMsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32u emberAfGetLongPollIntervalMsCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Long Poll Interval Ms. </p>
<p>This function is only useful to end devices. This function will return the long poll interval (in milliseconds) for the current network. This interval is the maximum amount of time a child will wait between polls of its parent when it is not expecting data. </p>

</div>
</div>
<a id="ga21da48d0b8d8a3e58160e8e5d7d43d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21da48d0b8d8a3e58160e8e5d7d43d48">&#9670;&nbsp;</a></span>emberAfGetLongPollIntervalQsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32u emberAfGetLongPollIntervalQsCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Long Poll Interval Qs. </p>
<p>This function is only useful to end devices. This function will return the long poll interval (in quarter seconds) for the current network. This interval is the maximum amount of time a child will wait between polls of its parent when it is not expecting data. </p>

</div>
</div>
<a id="ga86641927dacac3b5f6227de7e75a5f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86641927dacac3b5f6227de7e75a5f35">&#9670;&nbsp;</a></span>emberAfGetShortPollIntervalMsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16u emberAfGetShortPollIntervalMsCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Short Poll Interval Ms. </p>
<p>This function is only useful to sleepy end devices. This function will return the short poll interval (in milliseconds) for the current network. This interval is the maximum amount of time a child will wait between polls of its parent when it is expecting data. </p>

</div>
</div>
<a id="ga41f57211501e91e893fbd3a6e728c1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41f57211501e91e893fbd3a6e728c1e2">&#9670;&nbsp;</a></span>emberAfGetShortPollIntervalQsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16u emberAfGetShortPollIntervalQsCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Short Poll Interval Qs. </p>
<p>This function is only useful to sleepy end devices. This function will return the short poll interval (in quarter seconds) for the current network. This interval is the maximum amount of time a child will wait between polls of its parent when it is expecting data. </p>

</div>
</div>
<a id="gaf5d6c02856c3a52e6945c3718713c10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5d6c02856c3a52e6945c3718713c10e">&#9670;&nbsp;</a></span>emberAfGetSourceRouteOverheadCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8u emberAfGetSourceRouteOverheadCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Source Route Overhead. </p>
<p>This function is called by the framework to determine the overhead required in the network frame for source routing to a particular destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The node id of the destination Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cebec7e54db6fd3860aec29ac786f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cebec7e54db6fd3860aec29ac786f16">&#9670;&nbsp;</a></span>emberAfGetWakeTimeoutBitmaskCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a> emberAfGetWakeTimeoutBitmaskCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Wake Timeout Bitmask. </p>
<p>This function is only useful to sleepy end devices. This function will return the wake timeout bitmask for the current network. The bitmask determines which tasks will timeout automatically and which tasks require manual removal from the task list. </p>

</div>
</div>
<a id="gae45b4348db2a4d7d574573d6e54419a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae45b4348db2a4d7d574573d6e54419a8">&#9670;&nbsp;</a></span>emberAfGetWakeTimeoutMsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16u emberAfGetWakeTimeoutMsCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Wake Timeout Ms. </p>
<p>This function is only useful to sleepy end devices. This function will return the wake timeout (in milliseconds) for the current network. This timeout is the maximum amount of time a child will wait for a task in the wake bitmask to finish. While waiting, the device will short poll. </p>

</div>
</div>
<a id="gadc660fe69cb3b4e7d1948d19e1a17f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc660fe69cb3b4e7d1948d19e1a17f30">&#9670;&nbsp;</a></span>emberAfGetWakeTimeoutQsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16u emberAfGetWakeTimeoutQsCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Wake Timeout Qs. </p>
<p>This function is only useful to sleepy end devices. This function will return the wake timeout (in quarter seconds) for the current network. This timeout is the maximum amount of time a child will wait for a task in the wake bitmask to finish. While waiting, the device will short poll. </p>

</div>
</div>
<a id="ga07ac11dfc464999bb2fd9bf6bbe124e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07ac11dfc464999bb2fd9bf6bbe124e8">&#9670;&nbsp;</a></span>emberAfHalButtonIsrCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfHalButtonIsrCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>button</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hal Button Isr. </p>
<p>This callback is called by the framework whenever a button is pressed on the device. This callback is called within ISR context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">button</td><td>The button which has changed state, either BUTTON0 or BUTTON1 as defined in the appropriate BOARD_HEADER. Ver.: always </td></tr>
    <tr><td class="paramname">state</td><td>The new state of the button referenced by the button parameter, either ::BUTTON_PRESSED if the button has been pressed or ::BUTTON_RELEASED if the button has been released. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90859f0856e4de645eea2d79c15d4125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90859f0856e4de645eea2d79c15d4125">&#9670;&nbsp;</a></span>emberAfIncomingPacketFilterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a> emberAfIncomingPacketFilterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>size_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Incoming Packet Filter. </p>
<p>** REQUIRES INCLUDING THE PACKET-HANDOFF PLUGIN ** </p><pre class="fragment"> This is called by
</pre><p> the Packet Handoff plugin when the stack receives a packet from one of the protocol layers specified in <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a>. </p><pre class="fragment"> The packetType
</pre><p> argument is one of the values of the <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a> enum. If the stack receives an 802.15.4 MAC beacon, it will call this function with the packetType argument set to <a class="el" href="group__ember__types.html#ggabc84c30424c97df09e02b15c5648f73daf1c7763f9a7fcc664e44a823d75a5588">EMBER_ZIGBEE_PACKET_TYPE_BEACON</a>. </p><pre class="fragment"> The
</pre><p> implementation of this callback may alter the data contained in packetData, modify options and flags in the auxillary data, or consume the packet itself, either sending the message, or discarding it as it sees fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>the type of packet and associated protocol layer Ver.: always </td></tr>
    <tr><td class="paramname">packetData</td><td>flat buffer containing the packet data associated with the packet type Ver.: always </td></tr>
    <tr><td class="paramname">size_p</td><td>a pointer containing the size value of the packet Ver.: always </td></tr>
    <tr><td class="paramname">data</td><td>auxillary data included with the packet Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafec49d348615c7d4e1306772f35ed58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafec49d348615c7d4e1306772f35ed58c">&#9670;&nbsp;</a></span>emberAfInitiateInterPanKeyEstablishmentCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfInitiateInterPanKeyEstablishmentCallback </td>
          <td>(</td>
          <td class="paramtype">EmberPanId&#160;</td>
          <td class="paramname"><em>panId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EmberEUI64&#160;</td>
          <td class="paramname"><em>eui64</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate Inter Pan Key Establishment. </p>
<p>This function is called by the framework to initiate key establishment with a remote device on a different PAN. The application should return EMBER_SUCCESS if key establishment was initiated successfully. The application should call <a class="el" href="group__nonClustercallback.html#ga5d413fe9794946636b8af3c82058e027" title="Inter Pan Key Establishment. ">emberAfInterPanKeyEstablishmentCallback</a> as events occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">panId</td><td>The PAN id of the remote device. Ver.: always </td></tr>
    <tr><td class="paramname">eui64</td><td>The EUI64 of the remote device. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0357d8f4c0ee7997c85279ac5c739615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0357d8f4c0ee7997c85279ac5c739615">&#9670;&nbsp;</a></span>emberAfInitiateKeyEstablishmentCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfInitiateKeyEstablishmentCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate Key Establishment. </p>
<p>This function is called by the framework to initiate key establishment with a remote device. The application should return EMBER_SUCCESS if key establishment was initiated successfully. The application should call <a class="el" href="group__nonClustercallback.html#ga64e4318554deac14d8f6e82458b4985c" title="Key Establishment. ">emberAfKeyEstablishmentCallback</a> as events occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeId</td><td>The node id of the remote device. Ver.: always </td></tr>
    <tr><td class="paramname">endpoint</td><td>The endpoint on the remote device. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37af6af4db874e472aebaa7552c9bb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37af6af4db874e472aebaa7552c9bb2f">&#9670;&nbsp;</a></span>emberAfInitiatePartnerLinkKeyExchangeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfInitiatePartnerLinkKeyExchangeCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaca9dd969e62b8b79b29282e161c94449">EmberAfPartnerLinkKeyExchangeCallback</a> *&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiate Partner Link Key Exchange. </p>
<p>This function is called by the framework to initiate a partner link key exchange with a remote device. The application should return EMBER_SUCCESS if the partner link key exchange was initiated successfully. When the partner link key exchange completes, the application should call the given callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The node id of the remote device. Ver.: always </td></tr>
    <tr><td class="paramname">endpoint</td><td>The key establishment endpoint of the remote device. Ver.: always </td></tr>
    <tr><td class="paramname">callback</td><td>The callback that should be called when the partner link key exchange completse. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d413fe9794946636b8af3c82058e027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d413fe9794946636b8af3c82058e027">&#9670;&nbsp;</a></span>emberAfInterPanKeyEstablishmentCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfInterPanKeyEstablishmentCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga908101ba54b5ff8c36bc1129995e8d0d">EmberAfKeyEstablishmentNotifyMessage</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>amInitiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberPanId&#160;</td>
          <td class="paramname"><em>panId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const EmberEUI64&#160;</td>
          <td class="paramname"><em>eui64</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>delayInSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inter Pan Key Establishment. </p>
<p>A callback by the key-establishment code to indicate an event has occurred. For error codes this is purely a notification. For non-error status codes (besides LINK_KEY_ESTABLISHED), it is the application's chance to allow or disallow the operation. If the application returns true then the key establishment is allowed to proceed. If it returns false, then key establishment is aborted. LINK_KEY_ESTABLISHED is a notification of success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">amInitiator</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">panId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">eui64</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">delayInSeconds</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3819468a166d47024d99f513f4f1f7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3819468a166d47024d99f513f4f1f7bf">&#9670;&nbsp;</a></span>emberAfInterpanSendMessageCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfInterpanSendMessageCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberAfInterpanHeader.html">EmberAfInterpanHeader</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>messageLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpan Send Message. </p>
<p>This function will send a raw MAC message with interpan frame format using the passed parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">header</td><td>Interpan header info Ver.: always </td></tr>
    <tr><td class="paramname">messageLength</td><td>The length of the message received or to send Ver.: always </td></tr>
    <tr><td class="paramname">message</td><td>The message data received or to send. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="zcl-cli_8c.html#ad25f52ee58c07658e4e28d6a2a2f36aa">interpanCommand()</a>, and <a class="el" href="zcl-cli_8c.html#a50e5c36dddc83ea547aec224b85202ae">interpanLongCommand()</a>.</p>

</div>
</div>
<a id="ga64e4318554deac14d8f6e82458b4985c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64e4318554deac14d8f6e82458b4985c">&#9670;&nbsp;</a></span>emberAfKeyEstablishmentCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfKeyEstablishmentCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga908101ba54b5ff8c36bc1129995e8d0d">EmberAfKeyEstablishmentNotifyMessage</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>amInitiator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>partnerShortId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>delayInSeconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Key Establishment. </p>
<p>A callback by the key-establishment code to indicate an event has occurred. For error codes this is purely a notification. For non-error status codes (besides LINK_KEY_ESTABLISHED), it is the application's chance to allow or disallow the operation. If the application returns true then the key establishment is allowed to proceed. If it returns false, then key establishment is aborted. LINK_KEY_ESTABLISHED is a notification of success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">amInitiator</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">partnerShortId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">delayInSeconds</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65064a46ee99097caee378717b53a39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65064a46ee99097caee378717b53a39c">&#9670;&nbsp;</a></span>emberAfMainInitCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfMainInitCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main Init. </p>
<p>This function is called from the application's main function. It gives the application a chance to do any initialization required at system startup. Any code that you would normally put into the top of the application's <a class="el" href="group__framework-callbacks.html#ga6a116bdf8c598af7d4c5c8192eee2566" title="Provides the main application entry point. ">main()</a> routine should be put into this function. This is called before the clusters, plugins, and the network are initialized so some functionality is not yet available. Note: No callback in the Application Framework is associated with resource cleanup. If you are implementing your application on a Unix host where resource cleanup is a consideration, we expect that you will use the standard Posix system calls, including the use of atexit() and handlers for signals such as SIGTERM, SIGINT, SIGCHLD, SIGPIPE and so on. If you use the signal() function to register your signal handler, please mind the returned value which may be an Application Framework function. If the return value is non-null, please make sure that you call the returned function from your handler to avoid negating the resource cleanup of the Application Framework itself.</p>
<p>Main Init.</p>
<p>This function is called when the application starts and can be used to perform any additional initialization required at system startup. </p>

</div>
</div>
<a id="ga529b1928a29111f30ad6dd715e4f4436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga529b1928a29111f30ad6dd715e4f4436">&#9670;&nbsp;</a></span>emberAfMainStartCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfMainStartCallback </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>returnCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main Start. </p>
<p>This function is called at the start of main after the HAL has been initialized. The standard main function arguments of argc and argv are passed in. However not all platforms have support for <a class="el" href="group__framework-callbacks.html#ga6a116bdf8c598af7d4c5c8192eee2566" title="Provides the main application entry point. ">main()</a> function arguments. Those that do not are passed NULL for argv, therefore argv should be checked for NULL before using it. If the callback determines that the program must exit, it should return true. The value returned by <a class="el" href="group__framework-callbacks.html#ga6a116bdf8c598af7d4c5c8192eee2566" title="Provides the main application entry point. ">main()</a> will be the value written to the returnCode pointer. Otherwise the callback should return false to let normal execution continue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">returnCode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">argc</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">argv</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5fd5c4d349ee7d830a2c151e9bba0abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fd5c4d349ee7d830a2c151e9bba0abb">&#9670;&nbsp;</a></span>emberAfMainTickCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfMainTickCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main Tick. </p>
<p>Whenever main application tick is called, this callback will be called at the end of the main tick execution.</p>
<p>Main Tick.</p>
<p>This function is called in each iteration of the main application loop and can be used to perform periodic functions. The frequency with which this function is called depends on how quickly the main loop runs. If the application blocks at any time during the main loop, this function will not be called until execution resumes. </p>

</div>
</div>
<a id="ga7f95da0a54225b10a2de6306e339e1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f95da0a54225b10a2de6306e339e1ec">&#9670;&nbsp;</a></span>emberAfMarkBuffersCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfMarkBuffersCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark Buffers. </p>
<p>This function is called when the garbage collector runs. Any buffers held by the application must be marked. </p>

</div>
</div>
<a id="gab5173eae666ae910581d9aa151bdd155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5173eae666ae910581d9aa151bdd155">&#9670;&nbsp;</a></span>emberAfMessageSentCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfMessageSentCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gab77dd07ca7af23a832974d3cc20c94f3">EmberOutgoingMessageType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>indexOrDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>msgLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Message Sent. </p>
<p>This function is called by the application framework from the message sent handler, when it is informed by the stack regarding the message sent status. All of the values passed to the emberMessageSentHandler are passed on to this callback. This provides an opportunity for the application to verify that its message has been sent successfully and take the appropriate action. This callback should return a bool value of true or false. A value of true indicates that the message sent notification has been handled and should not be handled by the application framework.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">indexOrDestination</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">apsFrame</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">msgLen</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">message</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">status</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf844d0651d3c1f8bfe18a582156b5429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf844d0651d3c1f8bfe18a582156b5429">&#9670;&nbsp;</a></span>emberAfNcpInitCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfNcpInitCallback </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>memoryAllocation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ncp Init. </p>
<p>This function is called when the network coprocessor is being initialized, either at startup or upon reset. It provides applications on opportunity to perform additional configuration of the NCP. The function is always called twice when the NCP is initialized. In the first invocation, memoryAllocation will be true and the application should only issue EZSP commands that affect memory allocation on the NCP. For example, tables on the NCP can be resized in the first call. In the second invocation, memoryAllocation will be false and the application should only issue EZSP commands that do not affect memory allocation. For example, tables on the NCP can be populated in the second call. This callback is not called on SoCs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memoryAllocation</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga76fb07fda58f8c8533089fbc8dfc5bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76fb07fda58f8c8533089fbc8dfc5bc7">&#9670;&nbsp;</a></span>emberAfNcpIsAwakeIsrCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfNcpIsAwakeIsrCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ncp Is Awake Isr. </p>
<p>This function is called IN ISR CONTEXT. It notes that the NCP is awake after sleeping. Care should be taken to do minimal processing in this ISR handler function. </p>

</div>
</div>
<a id="gae510f585bbce12a45e47b7b20cdf5336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae510f585bbce12a45e47b7b20cdf5336">&#9670;&nbsp;</a></span>emberAfNetworkFoundCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfNetworkFoundCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberZigbeeNetwork.html">EmberZigbeeNetwork</a> *&#160;</td>
          <td class="paramname"><em>networkFound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>lqi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8s&#160;</td>
          <td class="paramname"><em>rssi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Network Found. </p>
<p>This callback is generated when an active scan finds a 802.15.4 network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">networkFound</td><td>A struct containing information about the network found. Ver.: always </td></tr>
    <tr><td class="paramname">lqi</td><td>The link quality indication of the network found. Ver.: always </td></tr>
    <tr><td class="paramname">rssi</td><td>The received signal strength indication of the network found. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae6a38e497a6db04a44609ef264c72a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6a38e497a6db04a44609ef264c72a78">&#9670;&nbsp;</a></span>emberAfNetworkKeyUpdateCompleteCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfNetworkKeyUpdateCompleteCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Network Key Update Complete. </p>
<p>This is called by the framework when a network key update operation started by the trust center is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaac00c12a70f9aaab0c932ba0979a9f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac00c12a70f9aaab0c932ba0979a9f15">&#9670;&nbsp;</a></span>emberAfOtaBootloadCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8u emberAfOtaBootloadCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>ncpUpgradeTagId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Bootload. </p>
<p>The platform specific routine to bootload the device from a ZigBee over-the-air upgrade file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>A pointer to the structure that contains the information about what OTA image to bootload. Ver.: always </td></tr>
    <tr><td class="paramname">ncpUpgradeTagId</td><td>The tag ID of the upgrade data that will be used to bootload the device. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac4b66d2d410fd5a2b5034e2254fe2766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4b66d2d410fd5a2b5034e2254fe2766">&#9670;&nbsp;</a></span>emberAfOtaClientBootloadCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfOtaClientBootloadCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Client Bootload. </p>
<p>This callback is fired when the OTA Client recevies a command to bootload the newly downloaded OTA image. This callback will perform the platform specific to bootload their device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>This is the identifier relating to the image that has been downloaded and is ready for bootload. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4308f5dbfaf9d2920282836536a9c040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4308f5dbfaf9d2920282836536a9c040">&#9670;&nbsp;</a></span>emberAfOtaClientCustomVerifyCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga1507d91e2449d9042f5b94e044914fc2">EmberAfImageVerifyStatus</a> emberAfOtaClientCustomVerifyCallback </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>newVerification</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Client Custom Verify. </p>
<p>This callback is executed by the OTA client after the signature verification has successfully completed. It allows the device to do its own custom verification of the image (such as verifying that the EBL is intact).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newVerification</td><td>This indicates if a new verification should be started. Ver.: always </td></tr>
    <tr><td class="paramname">id</td><td>This is ID of the image to be verified. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae53bc95b5d5b8ed99af3278ac3067ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae53bc95b5d5b8ed99af3278ac3067ca2">&#9670;&nbsp;</a></span>emberAfOtaClientDownloadCompleteCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfOtaClientDownloadCompleteCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gacd4e96651a3e1c8a4aafa6b5d32ee05a">EmberAfOtaDownloadResult</a>&#160;</td>
          <td class="paramname"><em>success</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Client Download Complete. </p>
<p>This callback indicates that the OTA client has completed the download of a file. If the file has been completely downloaded and cryptographic checks have been turned on, then those will be performed prior to this callback and that outcome included in the 'success' result. On failure, this callback is merely informative, and the return type is ignored. On succesful download, this callback allows the client to perform any additional verification of the downloaded image and return that result to the OTA server.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>This indicates the success or failure of the download and cryptographic verification process (if applicable). Ver.: always </td></tr>
    <tr><td class="paramname">id</td><td>This is the image identifier information that corresponds to the download result. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadf58d4eb52c33e60788b507426e60696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf58d4eb52c33e60788b507426e60696">&#9670;&nbsp;</a></span>emberAfOtaClientIncomingMessageRawCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfOtaClientIncomingMessageRawCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Client Incoming Message Raw. </p>
<p>This callback is for processing incoming messages for the Over-the-air bootload cluster client. ZCL will not process the message and instead hand the raw over the air data to the callback for its own processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>A pointer to the structure containing the message buffer and other information about it. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d84a87643c71e97075447dc2909b977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d84a87643c71e97075447dc2909b977">&#9670;&nbsp;</a></span>emberAfOtaClientStartCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfOtaClientStartCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Client Start. </p>
<p>This callback should be called when the profile specific registration has completed successfully. It will start the client's state machine that will find the OTA server, query it for the next image, download the image, wait for the bootload message, and kick off the bootload. </p>

</div>
</div>
<a id="ga96fe64087e2f63603e2cd76270fe69bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96fe64087e2f63603e2cd76270fe69bb">&#9670;&nbsp;</a></span>emberAfOtaClientVersionInfoCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfOtaClientVersionInfoCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>currentImageInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u *&#160;</td>
          <td class="paramname"><em>hardwareVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Client Version Info. </p>
<p>This function is called by the OTA client when a new query will occur to the server asking what the next version of firmware is. The client can inform the cluster software as to what information to use in the query (and subsequent download).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentImageInfo</td><td>This is the information to use in the next query by the client cluster code. It contains the manufacturer ID, image type ID, and the firmware version to be specified in the query message sent to the server. Ver.: always </td></tr>
    <tr><td class="paramname">hardwareVersion</td><td>This is a pointer to the hardware version to use in the query. If no hardware version should be used, then EMBER_AF_INVALID_HARDWARE_VERSION should be used. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae935294acbb85cfaa41529133723e410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae935294acbb85cfaa41529133723e410">&#9670;&nbsp;</a></span>emberAfOtaPageRequestServerPolicyCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8u emberAfOtaPageRequestServerPolicyCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Page Request Server Policy. </p>
<p>This callback is called by the OTA server page request code when it wants to determine if it is allowed for an OTA client to make a page request. It is only called if page request support has been enabled on the server. It should return EMBER_ZCL_STATUS_SUCCESS if it allows the page request, and EMBER_ZCL_STATUS_UNSUP_CLUSTER_COMMAND if it does not want to allow it. </p>

</div>
</div>
<a id="ga4fdc4d4b364bb5f20e6c790d4c9d6b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fdc4d4b364bb5f20e6c790d4c9d6b55">&#9670;&nbsp;</a></span>emberAfOtaServerBlockSizeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8u emberAfOtaServerBlockSizeCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>clientNodeId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Server Block Size. </p>
<p>This function provides a way for the server to adjust the block size of its response to an Image block request by a client.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clientNodeId</td><td>The node Id of OTA client making an image block request. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacba65584309da13d8e719d5bcb0b87d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacba65584309da13d8e719d5bcb0b87d5">&#9670;&nbsp;</a></span>emberAfOtaServerIncomingMessageRawCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfOtaServerIncomingMessageRawCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Server Incoming Message Raw. </p>
<p>This callback is for processing incoming messages for the Over-the-air bootload cluster server. ZCL will not process the message and instead hand the raw over the air data to the callback for its own processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>A pointer to the structure containing the message buffer and other information about it. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4f4c048c2838e770f93eac2ad8f20adc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f4c048c2838e770f93eac2ad8f20adc">&#9670;&nbsp;</a></span>emberAfOtaServerQueryCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8u emberAfOtaServerQueryCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>currentImageId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u *&#160;</td>
          <td class="paramname"><em>hardwareVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>nextUpgradeImageId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Server Query. </p>
<p>This callback is fired when the OTA server receives a query request by the client. The callback lets the server application indicate to the client what the 'next' version of software is for the device, or if there is not one available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentImageId</td><td>This is the current software image that the client hase. Ver.: always </td></tr>
    <tr><td class="paramname">hardwareVersion</td><td>If this value is non-NULL, it indicates the hardware version of the client device. If NULL, the client did not specify a hardware version. Ver.: always </td></tr>
    <tr><td class="paramname">nextUpgradeImageId</td><td>This is a pointer to a data structure containing the 'next' software version for the client to download. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga738a287be2c11f05f808b7633bf01acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga738a287be2c11f05f808b7633bf01acd">&#9670;&nbsp;</a></span>emberAfOtaServerSendImageNotifyCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfOtaServerSendImageNotifyCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>payloadType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>queryJitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Server Send Image Notify. </p>
<p>This callback is an indication to the OTA server that it should send out notification about an OTA file that is available for download.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination of the image notify message. May be a broadcast address. Ver.: always </td></tr>
    <tr><td class="paramname">endpoint</td><td>The destination endpoint of the image notify message. May be a broadcast endpoint. Ver.: always </td></tr>
    <tr><td class="paramname">payloadType</td><td>The type of data the image notify message will contain. 0 = no data. 1 = Manufacturer ID. 2 = Manufacturer ID and the image type ID. 3 = Manufacturer ID, image type ID, and firmware version. Ver.: always </td></tr>
    <tr><td class="paramname">queryJitter</td><td>The percentage of nodes that should respond to this message, from 1-100. On receipt of this message, each recipient will randomly choose a percentage and only query the server if their percentage is below this value. Ver.: always </td></tr>
    <tr><td class="paramname">id</td><td>The image information that will be put in the message. The data within this struct that will be appended to the message is determined by the previous 'payloadType' argument. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9e6d4c0409da86cc82d408c1977564ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e6d4c0409da86cc82d408c1977564ff">&#9670;&nbsp;</a></span>emberAfOtaServerUpgradeEndRequestCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfOtaServerUpgradeEndRequestCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u *&#160;</td>
          <td class="paramname"><em>returnValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>imageId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Server Upgrade End Request. </p>
<p>This function is called when the OTA server receives a request an upgrade end request. If the request indicated a successful download by the client, the server must tell the client when and if to upgrade to the downloaded image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The node ID of the device that sent the upgrade end request. Ver.: always </td></tr>
    <tr><td class="paramname">status</td><td>This is the ZCL status sent by the client indicating the result of its attempt to download the new upgrade image. If the status is not EMBER_ZCL_STATUS_SUCCESS then this callback is merely informative and no response mesasge will be generated by the server. Ver.: always </td></tr>
    <tr><td class="paramname">returnValue</td><td>If the server returns true indicating that the client should apply the upgrade, this time value indicates when in the future the client should apply the upgrade. Ver.: always </td></tr>
    <tr><td class="paramname">imageId</td><td>This variable indicates the software version that the client successfully downloaded and is asking to upgrade to. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa9d9ad4da635f6002d212c6ccdb93891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9d9ad4da635f6002d212c6ccdb93891">&#9670;&nbsp;</a></span>emberAfOtaStorageCheckTempDataCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a> emberAfOtaStorageCheckTempDataCallback </td>
          <td>(</td>
          <td class="paramtype">int32u *&#160;</td>
          <td class="paramname"><em>currentOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u *&#160;</td>
          <td class="paramname"><em>totalImageSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>newFileInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Check Temp Data. </p>
<p>This callback will validate temporary data in the storage device to determine whether it is a complete file, a partially downloaded file, or there is no file present. When a complete or partial file is found it will return EMBER_AF_OTA_STORAGE_SUCCESS or EMBER_AF_OTA_STORAGE_PARTIAL_FILE_FOUND, respectively. In that case, the currentOffset, totalImageSize, and newFileInfo will be populated with data. When EMBER_AF_OTA_STORAGE_ERROR is returned, no temporary data is present.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentOffset</td><td>A pointer to a value that will be written with the offset within the total file size that has been successfully stored in the storage device. This will indicate how much data has been currently dowloaded. Ver.: always </td></tr>
    <tr><td class="paramname">totalImageSize</td><td>A pointer to a value that will be written with the total image size of the OTA file when a download has completed. This does not indicate how much data has actually been downloaded currently. Ver.: always </td></tr>
    <tr><td class="paramname">newFileInfo</td><td>This is the image id of the temporary file data stored in the storage device. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2a569ac68b77e7486d29f5e2e9b1afe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a569ac68b77e7486d29f5e2e9b1afe7">&#9670;&nbsp;</a></span>emberAfOtaStorageClearTempDataCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a> emberAfOtaStorageClearTempDataCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Clear Temp Data. </p>
<p>This function clears any existing temp data that was downloaed. It is used immediately prior to downloading a raw image over the air. </p>

</div>
</div>
<a id="gaa67fd6ae8b12c49906915cc836dbfcc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa67fd6ae8b12c49906915cc836dbfcc9">&#9670;&nbsp;</a></span>emberAfOtaStorageCloseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfOtaStorageCloseCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Close. </p>
<p>This callback shuts down the ZigBee Over-the-air storage module. </p>

</div>
</div>
<a id="ga7fb936abe9c56adf4c5536bba25d2390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7fb936abe9c56adf4c5536bba25d2390">&#9670;&nbsp;</a></span>emberAfOtaStorageDriverDownloadFinishCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfOtaStorageDriverDownloadFinishCallback </td>
          <td>(</td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Driver Download Finish. </p>
<p>This callback defines the low-level means by which a device records the final offset value of the download image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The value of the final offset of the image download. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54348c69062a44dab273ee140401a31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54348c69062a44dab273ee140401a31b">&#9670;&nbsp;</a></span>emberAfOtaStorageDriverInitCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfOtaStorageDriverInitCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Driver Init. </p>
<p>The initialization code for the OTA storage driver. </p>

</div>
</div>
<a id="gaa95dba4ca71ca2aa4936a352fa23ca07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa95dba4ca71ca2aa4936a352fa23ca07">&#9670;&nbsp;</a></span>emberAfOtaStorageDriverInvalidateImageCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a> emberAfOtaStorageDriverInvalidateImageCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Driver Invalidate Image. </p>
<p>This callback invalidates the image stored on disk so that it will not be bootloaded, and it will not be a valid image that is in the middle of downloading. </p>

</div>
</div>
<a id="ga75dac63f0e4764c9e53d3032200982d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75dac63f0e4764c9e53d3032200982d5">&#9670;&nbsp;</a></span>emberAfOtaStorageDriverPrepareToResumeDownloadCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a> emberAfOtaStorageDriverPrepareToResumeDownloadCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Driver Prepare To Resume Download. </p>
<p>This callback allows the underlying storage driver to prepare to resume the OTA file download. For example, the driver may exceute a page erase to insure the next page is ready to be written to. </p>

</div>
</div>
<a id="gab5242307347b977973d18b38a609cf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5242307347b977973d18b38a609cf49">&#9670;&nbsp;</a></span>emberAfOtaStorageDriverReadCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfOtaStorageDriverReadCallback </td>
          <td>(</td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>returnData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Driver Read. </p>
<p>This callback defines the low-level means by which a device reads from the OTA storage device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The address offset from the start of the storage device where data is to be read. Ver.: always </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data to be read from the storage device. Ver.: always </td></tr>
    <tr><td class="paramname">returnData</td><td>A pointer where the data read from the device should be written to. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3f16934074c547af4aa269105d69779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f16934074c547af4aa269105d69779">&#9670;&nbsp;</a></span>emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32u emberAfOtaStorageDriverRetrieveLastStoredOffsetCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Driver Retrieve Last Stored Offset. </p>
<p>This callback defines the low-level means by which a device retrieves the last persistently recorded download offset. This may be different than last actual download offset. </p>

</div>
</div>
<a id="ga9ab9bad051d6dd80904ebc407be4ea97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ab9bad051d6dd80904ebc407be4ea97">&#9670;&nbsp;</a></span>emberAfOtaStorageDriverWriteCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfOtaStorageDriverWriteCallback </td>
          <td>(</td>
          <td class="paramtype">const int8u *&#160;</td>
          <td class="paramname"><em>dataToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Driver Write. </p>
<p>This callback defines the low-level means by which a device reads from the OTA storage device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataToWrite</td><td>A pointer to the data that will be written to the storage device. Ver.: always </td></tr>
    <tr><td class="paramname">offset</td><td>The address offset from the start of the storage device where data will be written. Ver.: always </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data to be written to the storage device. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15d1ac93268f8077ca3ffb4955c44433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15d1ac93268f8077ca3ffb4955c44433">&#9670;&nbsp;</a></span>emberAfOtaStorageFinishDownloadCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a> emberAfOtaStorageFinishDownloadCallback </td>
          <td>(</td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Finish Download. </p>
<p>This function indicates to the storage module that the download has finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The final offset of the downloaded file (i.e. the total size) Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50bd55a5865e13b40a35f42f5aed0f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50bd55a5865e13b40a35f42f5aed0f08">&#9670;&nbsp;</a></span>emberAfOtaStorageGetCountCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8u emberAfOtaStorageGetCountCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Get Count. </p>
<p>This callback returns the total number of ZigBee Over-the-air upgrade images stored in the storage module. </p>

</div>
</div>
<a id="gae143e396aea8e251297b7cfa61703455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae143e396aea8e251297b7cfa61703455">&#9670;&nbsp;</a></span>emberAfOtaStorageGetFullHeaderCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a> emberAfOtaStorageGetFullHeaderCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberAfOtaHeader.html">EmberAfOtaHeader</a> *&#160;</td>
          <td class="paramname"><em>returnData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Get Full Header. </p>
<p>This callback populates the <a class="el" href="structEmberAfOtaHeader.html" title="This structure is an in-memory representation of the Over-the-air header data that resides on disk...">EmberAfOtaHeader</a> structure pointed to by the returnData with data about the OTA file stored in the storage module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>This is a pointer to the image id for the OTA file to retrieve information about. Ver.: always </td></tr>
    <tr><td class="paramname">returnData</td><td>This is a pointer to the location of the structure that will be populated with data. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1d8abe312f2023984a1ca2b5b81abd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d8abe312f2023984a1ca2b5b81abd35">&#9670;&nbsp;</a></span>emberAfOtaStorageGetTotalImageSizeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32u emberAfOtaStorageGetTotalImageSizeCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Get Total Image Size. </p>
<p>This function returns the total size of the ZigBee Over-the-air file with the passed parameters. If no file is found with those parameters, 0 is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>A pointer to the image identifier for the OTA file to retrieve information for. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38af5865d93348e362d5212d96b5fffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38af5865d93348e362d5212d96b5fffe">&#9670;&nbsp;</a></span>emberAfOtaStorageInitCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a> emberAfOtaStorageInitCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Init. </p>
<p>This callback initializes the ZigBee Over-the-air storage module. </p>

</div>
</div>
<a id="ga036f2ec2145a8d2e7de1b3f5c76ae195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga036f2ec2145a8d2e7de1b3f5c76ae195">&#9670;&nbsp;</a></span>emberAfOtaStorageIteratorFirstCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> emberAfOtaStorageIteratorFirstCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Iterator First. </p>
<p>This callback lets you walk through the list of all OTA files by jumping to the first file in the list maintained by the storage module. If there is no file then emberAfOtaInvalidImageId is returned. </p>

</div>
</div>
<a id="ga59426f6009bccd3e59dedf122573d60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59426f6009bccd3e59dedf122573d60e">&#9670;&nbsp;</a></span>emberAfOtaStorageIteratorNextCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> emberAfOtaStorageIteratorNextCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Iterator Next. </p>
<p>This callback lets you walk through the list of all OTA files by jumping to the next file in the list maintained by the storage module. If there is no next file then emberAfOtaInvalidImageId is returned. </p>

</div>
</div>
<a id="gafa8f353175b38004d23083ae0f028b9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa8f353175b38004d23083ae0f028b9c">&#9670;&nbsp;</a></span>emberAfOtaStorageReadImageDataCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a> emberAfOtaStorageReadImageDataCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>returnData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u *&#160;</td>
          <td class="paramname"><em>returnedLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Read Image Data. </p>
<p>This callback reads data from the specified OTA file and returns that data to the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>This is a pointer to the image id for the OTA file to retrieve data from. Ver.: always </td></tr>
    <tr><td class="paramname">offset</td><td>This is the offset relative to the start of the image where the data should be read from. Ver.: always </td></tr>
    <tr><td class="paramname">length</td><td>This is the length of data that will be read. Ver.: always </td></tr>
    <tr><td class="paramname">returnData</td><td>This is a pointer to where the data read out of the file will be written to Ver.: always </td></tr>
    <tr><td class="paramname">returnedLength</td><td>This is a pointer to a variable where the actual length of data read will be written to. A short read may occur if the end of file was reached. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga112cc89cd7dfcab426b28bcc776f23a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga112cc89cd7dfcab426b28bcc776f23a0">&#9670;&nbsp;</a></span>emberAfOtaStorageSearchCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEmberAfOtaImageId.html">EmberAfOtaImageId</a> emberAfOtaStorageSearchCallback </td>
          <td>(</td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>imageTypeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16u *&#160;</td>
          <td class="paramname"><em>hardwareVersion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Search. </p>
<p>This callback searches through the list of all images for one that matches the passed parameters. On success an image identifier is returned with a matching image. On failure emberAfInvalidImageId is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manufacturerId</td><td>The ZigBee assigned identifier of the manufacturer contained in the OTA image being searched for. Ver.: always </td></tr>
    <tr><td class="paramname">imageTypeId</td><td>The image type identifier contained in the OTA image being searched for. Ver.: always </td></tr>
    <tr><td class="paramname">hardwareVersion</td><td>This is a pointer to the hardware version that will be used in the search. If the pointer is NULL, hardware version will not be considered when searching for matching images. If it points to a value, the search will only consider images where that value falls between the minimum and maxmimum hardware version specified in the OTA file. If no hardware version is present in an OTA file but the other parameters match, the file will be considered a match Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38fee9029d511a3486793be94e1d5c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38fee9029d511a3486793be94e1d5c9e">&#9670;&nbsp;</a></span>emberAfOtaStorageWriteTempDataCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__aftypes.html#ga223fed51289c09452ae48913fa68d2af">EmberAfOtaStorageStatus</a> emberAfOtaStorageWriteTempDataCallback </td>
          <td>(</td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8u *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ota Storage Write Temp Data. </p>
<p>This function writes to the temporary data in the storage device at the specified offset. It is used when downloading a raw image over the air.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The location within the download image file where to write the data. Ver.: always </td></tr>
    <tr><td class="paramname">length</td><td>The length of data to write. Ver.: always </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the temporary data that will be written to the storage device. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac1a0d028ffc7fa8e0ed7271eb89faf86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1a0d028ffc7fa8e0ed7271eb89faf86">&#9670;&nbsp;</a></span>emberAfOutgoingPacketFilterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a> emberAfOutgoingPacketFilterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>size_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outgoing Packet Filter. </p>
<p>** REQUIRES INCLUDING THE PACKET-HANDOFF PLUGIN ** </p><pre class="fragment"> This is called by
</pre><p> the Packet Handoff plugin when the stack prepares to send a packet from one of the protocol layers specified in <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a>. </p><pre class="fragment"> The
</pre><p> packetType argument is one of the values of the <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a> enum. If the stack receives an 802.15.4 MAC beacon, it will call this function with the packetType argument set to <a class="el" href="group__ember__types.html#ggabc84c30424c97df09e02b15c5648f73daf1c7763f9a7fcc664e44a823d75a5588">EMBER_ZIGBEE_PACKET_TYPE_BEACON</a>.</p>
<p>The implementation of this callback may alter the data contained in packetData, modify options and flags in the auxillary data, or consume the packet itself, either sending the message, or discarding it as it sees fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>the type of packet and associated protocol layer Ver.: always </td></tr>
    <tr><td class="paramname">packetData</td><td>flat buffer containing the packet data associated with the packet type Ver.: always </td></tr>
    <tr><td class="paramname">size_p</td><td>a pointer containing the size value of the packet Ver.: always </td></tr>
    <tr><td class="paramname">data</td><td>auxillary data included with the packet Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae5b696b64ec5291caf0d246bfce60fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5b696b64ec5291caf0d246bfce60fce">&#9670;&nbsp;</a></span>emberAfPartnerLinkKeyExchangeRequestCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ember__types.html#gadfde62e4cdd51e13bcf9fc58a2b9d7c7">EmberZdoStatus</a> emberAfPartnerLinkKeyExchangeRequestCallback </td>
          <td>(</td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>partner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partner Link Key Exchange Request. </p>
<p>This function is called by the framework on SOC platforms when a remote node requests a partner link key exchange. The application should return EMBER_SUCCESS to accept the request or any other status to reject it. On network coprocessor platforms, this function will not be called because the NCP handles partner link key exchange requests based on the binding policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partner</td><td>The EUI of the remote node. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga507743f1f7c9e2b825adfca4026cf7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga507743f1f7c9e2b825adfca4026cf7ed">&#9670;&nbsp;</a></span>emberAfPartnerLinkKeyExchangeResponseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfPartnerLinkKeyExchangeResponseCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>sender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gadfde62e4cdd51e13bcf9fc58a2b9d7c7">EmberZdoStatus</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partner Link Key Exchange Response. </p>
<p>This function is called by the framework when a remote node requests a partner link key exchange. The application should return true to accept the request or false to reject it. On network coprocessor platforms, this function will not be called because the NCP handles partner link key exchange requests based on the binding policy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sender</td><td>The EUI of the remote node. Ver.: always </td></tr>
    <tr><td class="paramname">status</td><td>The ZDO response status. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad0c3351b2b3dbf3cb123b4238b5d947d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad0c3351b2b3dbf3cb123b4238b5d947d">&#9670;&nbsp;</a></span>emberAfPerformingKeyEstablishmentCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfPerformingKeyEstablishmentCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performing Key Establishment. </p>
<p>This function is called by the framework to determine if the device is performing key establishment. The application should return true if key establishment is in progress. </p>

</div>
</div>
<a id="ga732594f5f2825ccc4c9ee9c6df873fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga732594f5f2825ccc4c9ee9c6df873fba">&#9670;&nbsp;</a></span>emberAfPostAttributeChangeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfPostAttributeChangeCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga6f3b7c4757642dc04d42b880720416db">EmberAfAttributeId</a>&#160;</td>
          <td class="paramname"><em>attributeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post Attribute Change. </p>
<p>This function is called by the application framework after it changes an attribute value. The value passed into this callback is the value to which the attribute was set by the framework.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">attributeId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">mask</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">type</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">size</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">value</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed382b21c3f06529e7fd50d95e67d21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed382b21c3f06529e7fd50d95e67d21c">&#9670;&nbsp;</a></span>emberAfPostEm4ResetCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfPostEm4ResetCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post Em4 Reset. </p>
<p>A callback called by application framework, and implemented by em4 plugin </p>

</div>
</div>
<a id="ga6a8e86c17374ab8f027eda8a7c12e4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a8e86c17374ab8f027eda8a7c12e4ef">&#9670;&nbsp;</a></span>emberAfPreAttributeChangeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__enums.html#ga6047361ca88bd5c16bb7bb759fa6da9d">EmberAfStatus</a> emberAfPreAttributeChangeCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga6f3b7c4757642dc04d42b880720416db">EmberAfAttributeId</a>&#160;</td>
          <td class="paramname"><em>attributeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre Attribute Change. </p>
<p>This function is called by the application framework before it changes an attribute value. The value passed into this callback is the value to which the attribute is to be set by the framework. The application should return <a class="el" href="group__enums.html#gga6047361ca88bd5c16bb7bb759fa6da9da20778152534b32bf870574ec04c03cd0">EMBER_ZCL_STATUS_SUCCESS</a> to permit the change or any other <a class="el" href="group__enums.html#ga6047361ca88bd5c16bb7bb759fa6da9d">EmberAfStatus</a> to reject it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">attributeId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">mask</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">type</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">size</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">value</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga53c2f48693fe831e3b12dcc376b8af21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga53c2f48693fe831e3b12dcc376b8af21">&#9670;&nbsp;</a></span>emberAfPreCliSendCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfPreCliSendCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>messageLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre Cli Send. </p>
<p>This function is called by the framework when it is about to pass a message constructed over CLI to the stack primitives for sending. If the function returns true it is assumed that the callback has consumed and processed the message. The framework will not do any further processing on the message. </p><pre class="fragment">If the function returns false then it is assumed that the callback has
</pre><p> not processed the message and the framework will continue to process accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apsFrame</td><td>The structure containing the APS frame Ver.: always </td></tr>
    <tr><td class="paramname">source</td><td>Source Node Id Ver.: always </td></tr>
    <tr><td class="paramname">destination</td><td>Destintion Node Id Ver.: always </td></tr>
    <tr><td class="paramname">message</td><td>Pointer to the message payload Ver.: always </td></tr>
    <tr><td class="paramname">messageLength</td><td>Length of the message payload Ver.: always </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="zcl-cli_8h.html#af5ad22db682f82088ccd5eca609319e7">emAfCliSendCommand()</a>.</p>

</div>
</div>
<a id="gaec152832909bba47a43ceaf009dfacc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec152832909bba47a43ceaf009dfacc0">&#9670;&nbsp;</a></span>emberAfPreCommandReceivedCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfPreCommandReceivedCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre Command Received. </p>
<p>This callback is the second in the Application Framework's message processing chain. At this point in the processing of incoming over-the-air messages, the application has determined that the incoming message is a ZCL command. It parses enough of the message to populate an <a class="el" href="structEmberAfClusterCommand.html" title="The EmberAFClusterCommand is a struct wrapper for all the data pertaining to a command which comes in...">EmberAfClusterCommand</a> struct. The Application Framework defines this struct value in a local scope to the command processing but also makes it available through a global pointer called emberAfCurrentCommand, in app/framework/util/util.c. When command processing is complete, this pointer is cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaec79a8993549ad42bd4fa5b7562d99fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec79a8993549ad42bd4fa5b7562d99fb">&#9670;&nbsp;</a></span>emberAfPreMessageReceivedCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfPreMessageReceivedCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberAfIncomingMessage.html">EmberAfIncomingMessage</a> *&#160;</td>
          <td class="paramname"><em>incomingMessage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre Message Received. </p>
<p>This callback is the first in the Application Framework's message processing chain. The Application Framework calls it when a message has been received over the air but has not yet been parsed by the ZCL command-handling code. If you wish to parse some messages that are completely outside the ZCL specification or are not handled by the Application Framework's command handling code, you should intercept them for parsing in this callback.</p>
<p>This callback returns a Boolean value indicating whether or not the message has been handled. If the callback returns a value of true, then the Application Framework assumes that the message has been handled and it does nothing else with it. If the callback returns a value of false, then the application framework continues to process the message as it would with any incoming message. Note: This callback receives a pointer to an incoming message struct. This struct allows the application framework to provide a unified interface between both Host devices, which receive their message through the ezspIncomingMessageHandler, and SoC devices, which receive their message through emberIncomingMessageHandler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">incomingMessage</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae9ee9ee54614df2b5df3dbb8361ba587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9ee9ee54614df2b5df3dbb8361ba587">&#9670;&nbsp;</a></span>emberAfPreMessageSendCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfPreMessageSendCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberAfMessageStruct.html">EmberAfMessageStruct</a> *&#160;</td>
          <td class="paramname"><em>messageStruct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre Message Send. </p>
<p>This function is called by the framework when it is about to pass a message to the stack primitives for sending. This message may or may not be ZCL, ZDO, or some other protocol. This is called prior to any ZigBee fragmentation that may be done. If the function returns true it is assumed the callback has consumed and processed the message. The callback must also set the EmberStatus status code to be passed back to the caller. The framework will do no further processing on the message. If the function returns false then it is assumed that the callback has not processed the mesasge and the framework will continue to process accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">messageStruct</td><td>The structure containing the parameters of the APS message to be sent. Ver.: always </td></tr>
    <tr><td class="paramname">status</td><td>A pointer to the status code value that will be returned to the caller. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3db43d8f532633c7d4111047c5d13967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3db43d8f532633c7d4111047c5d13967">&#9670;&nbsp;</a></span>emberAfPreNcpResetCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfPreNcpResetCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre Ncp Reset. </p>
<p>This function will be called prior to the reset of the NCP by the host. </p>

</div>
</div>
<a id="ga583b72f2cf688811b2599c4736385234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga583b72f2cf688811b2599c4736385234">&#9670;&nbsp;</a></span>emberAfPreZDOMessageReceivedCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfPreZDOMessageReceivedCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>emberNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pre ZDO Message Received. </p>
<p>This function passes the application an incoming ZDO message and gives the appictation the opportunity to handle it. By default, this callback returns false indicating that the incoming ZDO message has not been handled and should be handled by the Application Framework.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">emberNodeId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">apsFrame</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">message</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">length</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga713ebf2fb5a83cd77bde288bac0a72b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga713ebf2fb5a83cd77bde288bac0a72b6">&#9670;&nbsp;</a></span>emberAfReadAttributesResponseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfReadAttributesResponseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>bufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Attributes Response. </p>
<p>This function is called by the application framework when a Read Attributes Response command is received from an external device. The application should return true if the message was processed or false if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster identifier of this response. Ver.: always </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer containing the list of read attribute status records. Ver.: always </td></tr>
    <tr><td class="paramname">bufLen</td><td>The length in bytes of the list. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad50e938adb3fe91c351527060392bf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad50e938adb3fe91c351527060392bf77">&#9670;&nbsp;</a></span>emberAfReadReportingConfigurationCommandCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfReadReportingConfigurationCommandCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEmberAfClusterCommand.html">EmberAfClusterCommand</a> *&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Reporting Configuration Command. </p>
<p>This function is called by the application framework when a Read Reporting Configuration command is received from an external device. The application should return true if the message was processed or false if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga86abbb10f2fd7b6ab952fd234407cc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86abbb10f2fd7b6ab952fd234407cc1f">&#9670;&nbsp;</a></span>emberAfReadReportingConfigurationResponseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfReadReportingConfigurationResponseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>bufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read Reporting Configuration Response. </p>
<p>This function is called by the application framework when a Read Reporting Configuration Response command is received from an external device. The application should return true if the message was processed or false if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster identifier of this response. Ver.: always </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer containing the list of attribute reporting configuration records. Ver.: always </td></tr>
    <tr><td class="paramname">bufLen</td><td>The length in bytes of the list. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga177337a420868bcb18ab4ebb66e1cc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga177337a420868bcb18ab4ebb66e1cc65">&#9670;&nbsp;</a></span>emberAfRegistrationAbortCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfRegistrationAbortCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registration Abort. </p>
<p>This callback is called when the device should abort the registration process. </p>

</div>
</div>
<a id="gaedd106e7582b7e655a6f9406e44efd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedd106e7582b7e655a6f9406e44efd67">&#9670;&nbsp;</a></span>emberAfRegistrationCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfRegistrationCallback </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>success</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registration. </p>
<p>This callback is called when the device joins a network and the process of registration is complete. This callback provides a success value of true if the registration process was successful and a value of false if registration failed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">success</td><td>true if registration succeeded, false otherwise. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41ca0d1b59b5433bd839e8e3835d9b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ca0d1b59b5433bd839e8e3835d9b04">&#9670;&nbsp;</a></span>emberAfRegistrationStartCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfRegistrationStartCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registration Start. </p>
<p>This callback is called when the device joins a network and the registration process should begin. The application should return EMBER_SUCCESS if the registration process started successfully. When registration is complete, the application should call emberAfRegistrationCallback with an indication of success or failure. </p>

<p class="reference">Referenced by <a class="el" href="option-cli_8c.html#aa13e9bc76b02e15775d4a7da55def9c6">optionRegisterCommand()</a>.</p>

</div>
</div>
<a id="gadc003c56b8ec51e55a363f4e6108cde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc003c56b8ec51e55a363f4e6108cde6">&#9670;&nbsp;</a></span>emberAfRemoteDeleteBindingPermissionCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfRemoteDeleteBindingPermissionCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote Delete Binding Permission. </p>
<p>This function is called by the framework to request permission to service the remote delete binding request. Return EMBER_SUCCESS to allow request, anything else to disallow request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index to an Ember binding table entry Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga511fcf6ec05c1196b3ac30f77c6a6784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga511fcf6ec05c1196b3ac30f77c6a6784">&#9670;&nbsp;</a></span>emberAfRemoteSetBindingPermissionCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfRemoteSetBindingPermissionCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structEmberBindingTableEntry.html">EmberBindingTableEntry</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remote Set Binding Permission. </p>
<p>This function is called by the framework to request permission to service the remote set binding request. Return EMBER_SUCCESS to allow request, anything else to disallow request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>Ember Binding Tablet Entry Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa16a06c23b6026d1699c6882c16dfd86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa16a06c23b6026d1699c6882c16dfd86">&#9670;&nbsp;</a></span>emberAfRemoveFromCurrentAppTasksCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfRemoveFromCurrentAppTasksCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a>&#160;</td>
          <td class="paramname"><em>tasks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove From Current App Tasks. </p>
<p>This function is only useful to sleepy end devices. This function will remove the passed item from the set of tasks the application has outstanding (e.g. message sent requiring APS acknwoledgement). This will affect how the application behaves with regard to sleeping and polling. Removing the item from the list of outstanding tasks may allow the device to sleep longer and poll less frequently. If there are other outstanding tasks the system may still have to stay away and poll more often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasks</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4021eb950c44908616c255eb3b244ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4021eb950c44908616c255eb3b244ba">&#9670;&nbsp;</a></span>emberAfReportAttributesCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfReportAttributesCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>bufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report Attributes. </p>
<p>This function is called by the application framework when a Report Attributes command is received from an external device. The application should return true if the message was processed or false if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster identifier of this command. Ver.: always </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer containing the list of attribute report records. Ver.: always </td></tr>
    <tr><td class="paramname">bufLen</td><td>The length in bytes of the list. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga319690719c55a7752b32d4ee6cc15eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga319690719c55a7752b32d4ee6cc15eea">&#9670;&nbsp;</a></span>emberAfReportingAttributeChangeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfReportingAttributeChangeCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga6f3b7c4757642dc04d42b880720416db">EmberAfAttributeId</a>&#160;</td>
          <td class="paramname"><em>attributeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>manufacturerCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gabf10c4a79c0dc5e33c9bea77b892b177">EmberAfAttributeType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reporting Attribute Change. </p>
<p>This function is called by the framework when an attribute managed by the framework changes. The application should call this function when an externally-managed attribute changes. The application should use the change notification to inform its reporting decisions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">endpoint</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">clusterId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">attributeId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">mask</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">manufacturerCode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">type</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">data</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga618aeaa5c0d86fad2ad968197e2234e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga618aeaa5c0d86fad2ad968197e2234e6">&#9670;&nbsp;</a></span>emberAfScanCompleteCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfScanCompleteCallback </td>
          <td>(</td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan Complete. </p>
<p>This is called by the low-level stack code when an 802.15.4 active scan completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>If the status indicates an error, the channel on which the error occurred. Otherwise it is undefined for EMBER_SUCCESS. Ver.: always </td></tr>
    <tr><td class="paramname">status</td><td>The status of the scan. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a75c0ab3724ae27c2823c2e10f73648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a75c0ab3724ae27c2823c2e10f73648">&#9670;&nbsp;</a></span>emberAfScanErrorCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfScanErrorCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan Error. </p>
<p>This is called by the framework on behalf of the form-and-join library to notify the application if an error occurs while scanning. See form-and-join documentation for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The status of the scan. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc453aeea9afafefb02de0df23f4a1b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc453aeea9afafefb02de0df23f4a1b2">&#9670;&nbsp;</a></span>emberAfSecurityInitCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSecurityInitCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberInitialSecurityState.html">EmberInitialSecurityState</a> *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#ga753acda7a446dffa3629ef3cfde83406">EmberExtendedSecurityBitmask</a> *&#160;</td>
          <td class="paramname"><em>extended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>trustCenter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Security Init. </p>
<p>This callback is called by the framework to give the application a chance to modify the security settings of the node during network initialization. Depending on the context when this callback is called, the pointer to the initial security state may be NULL, which means the initial security state can no longer be modified as the node is already operating on the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">extended</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">trustCenter</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga43656aeea835ff0ac82fc419fcae30ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43656aeea835ff0ac82fc419fcae30ba">&#9670;&nbsp;</a></span>emberAfSetDefaultPollControlCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetDefaultPollControlCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gab3daa30a7fe8edc180c38c109be2551e">EmberAfEventPollControl</a>&#160;</td>
          <td class="paramname"><em>control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Default Poll Control. </p>
<p>This function will set the default poll control for the current network to control whether or not it can long poll.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga41d64b25c22fc2c0015e0a257cd05a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41d64b25c22fc2c0015e0a257cd05a6a">&#9670;&nbsp;</a></span>emberAfSetDefaultSleepControlCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetDefaultSleepControlCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="af-ncp_8h.html#a4a612352f4b32cb9713cc3150a04c776">EmberAfEventSleepControl</a>&#160;</td>
          <td class="paramname"><em>control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Default Sleep Control. </p>
<p>This function will set the default behavior of a sleeping device to control whether or not it must stay awake. A device that stays awake does not sleep at all. Otherwise, the device can sleep between events when appropriate.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">control</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3b71f4b0114b6b251d2e489cbd48fa19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b71f4b0114b6b251d2e489cbd48fa19">&#9670;&nbsp;</a></span>emberAfSetFormAndJoinExtendedPanIdCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetFormAndJoinExtendedPanIdCallback </td>
          <td>(</td>
          <td class="paramtype">const int8u *&#160;</td>
          <td class="paramname"><em>extendedPanId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Form And Join Extended Pan Id. </p>
<p>This callback is called by the framework to set the extended PAN ID used by the current network for forming and joining. The extended PAN ID used for forming and joining is not necessarily the same extended PAN ID actually in use on the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extendedPanId</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="network-cli_8c.html#abfc388d2bfe52f1e2ac2702d7d83dfdc">networkExtendedPanIdCommand()</a>.</p>

</div>
</div>
<a id="gadc4138cffb5f703239209d26c17608a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc4138cffb5f703239209d26c17608a1">&#9670;&nbsp;</a></span>emberAfSetLongPollIntervalMsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetLongPollIntervalMsCallback </td>
          <td>(</td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>longPollIntervalMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Long Poll Interval Ms. </p>
<p>This function is only useful to end devices. This function will set the long poll interval (in milliseconds) for the current network. This interval is the maximum amount of time a child will wait between polls of its parent when it is not expecting data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">longPollIntervalMs</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga466f149f3ccb4f4786ade14a1337db89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga466f149f3ccb4f4786ade14a1337db89">&#9670;&nbsp;</a></span>emberAfSetLongPollIntervalQsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetLongPollIntervalQsCallback </td>
          <td>(</td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>longPollIntervalQs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Long Poll Interval Qs. </p>
<p>This function is only useful to end devices. This function will set the long poll interval (in quarter seconds) for the current network. This interval is the maximum amount of time a child will wait between polls of its parent when it is not expecting data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">longPollIntervalQs</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad96a9d103309a992615933d3e2f4d8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad96a9d103309a992615933d3e2f4d8e0">&#9670;&nbsp;</a></span>emberAfSetShortPollIntervalMsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetShortPollIntervalMsCallback </td>
          <td>(</td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>shortPollIntervalMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Short Poll Interval Ms. </p>
<p>This function is only useful to sleepy end devices. This function will set the short poll interval (in milliseconds) for the current network. This interval is the maximum amount of time a child will wait between polls of its parent when it is expecting data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shortPollIntervalMs</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac0b31476adb30b232b6382a503b6d931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b31476adb30b232b6382a503b6d931">&#9670;&nbsp;</a></span>emberAfSetShortPollIntervalQsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetShortPollIntervalQsCallback </td>
          <td>(</td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>shortPollIntervalQs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Short Poll Interval Qs. </p>
<p>This function is only useful to sleepy end devices. This function will set the short poll interval (in quarter seconds) for the current network. This interval is the maximum amount of time a child will wait between polls of its parent when it is expecting data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shortPollIntervalQs</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1a04ff39b1a1f605497467d91b96b9a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a04ff39b1a1f605497467d91b96b9a4">&#9670;&nbsp;</a></span>emberAfSetSourceRouteOverheadCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetSourceRouteOverheadCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>overhead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Source Route Overhead. </p>
<p>This function is called by the framework when it has information about the source route overhead to a particular destination. The application may use this information to cache the source route overhead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The node id of the destination Ver.: always </td></tr>
    <tr><td class="paramname">overhead</td><td>The overhead in bytes Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8cc9adbb010577b1fd7188b9fc049c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cc9adbb010577b1fd7188b9fc049c20">&#9670;&nbsp;</a></span>emberAfSetTimeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetTimeCallback </td>
          <td>(</td>
          <td class="paramtype">int32u&#160;</td>
          <td class="paramname"><em>utcTime</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Time. </p>
<p>This callback should be implemented, if the device has access to real time clock, and has an ability to update that clock. The application framework expects to be passed the utcTime which is the number of seconds since the year 2000. Default implementation does nothing. Note: This function used to take time in year, month, day, hour, min, sec. We have changed this to utcTime in order to conserve code space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">utcTime</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac3ea61cea9ce2d9db35742ee223932d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3ea61cea9ce2d9db35742ee223932d7">&#9670;&nbsp;</a></span>emberAfSetWakeTimeoutBitmaskCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetWakeTimeoutBitmaskCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#ga5fe6fcbee8bfbc13bd0b484bd36c2a08">EmberAfApplicationTask</a>&#160;</td>
          <td class="paramname"><em>tasks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Wake Timeout Bitmask. </p>
<p>This function is only useful to sleepy end devices. This function will set the wake timeout bitmask for the current network. The bitmask determines which tasks will timeout automatically and which tasks require manual removal from the task list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasks</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84745346d7041503b20d1da84e527e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84745346d7041503b20d1da84e527e75">&#9670;&nbsp;</a></span>emberAfSetWakeTimeoutMsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetWakeTimeoutMsCallback </td>
          <td>(</td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>wakeTimeoutMs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Wake Timeout Ms. </p>
<p>This function is only useful to sleepy end devices. This function will set the wake timeout (in milliseconds) for the current network. This timeout is the maximum amount of time a child will wait for a task in the wake bitmask to finish. While waiting, the device will short poll.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakeTimeoutMs</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee3b342d09b5e4101c0b7ef95db96552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3b342d09b5e4101c0b7ef95db96552">&#9670;&nbsp;</a></span>emberAfSetWakeTimeoutQsCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfSetWakeTimeoutQsCallback </td>
          <td>(</td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>wakeTimeoutQs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set Wake Timeout Qs. </p>
<p>This function is only useful to sleepy end devices. This function will set the wake timeout (in quarter seconds) for the current network. This timeout is the maximum amount of time a child will wait for a task in the wake bitmask to finish. While waiting, the device will short poll.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wakeTimeoutQs</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb32a03da52b0139e6eff4cb503c6ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb32a03da52b0139e6eff4cb503c6ed7">&#9670;&nbsp;</a></span>emberAfStackStatusCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfStackStatusCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stack Status. </p>
<p>This function is called by the application framework from the stack status handler. This callbacks provides applications an opportunity to be notified of changes to the stack status and take appropriate action. The return code from this callback is ignored by the framework. The framework will always process the stack status after the callback returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab0bb8331be5aae0d7098ba396436b6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0bb8331be5aae0d7098ba396436b6b5">&#9670;&nbsp;</a></span>emberAfStartMoveCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfStartMoveCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start Move. </p>
<p>This function is called to initiate the process for a device to move (rejoin) to a new parent. </p>

</div>
</div>
<a id="gadfeca148a9f2fe7ba0ca3521bd13e010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfeca148a9f2fe7ba0ca3521bd13e010">&#9670;&nbsp;</a></span>emberAfStartSearchForJoinableNetworkCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberAfStartSearchForJoinableNetworkCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start Search For Joinable Network. </p>
<p>This function is called by the framework to search for joinable networks and join a network. The application should return EMBER_SUCCESS if the operation was initiated successfully. </p>

</div>
</div>
<a id="ga4e859ed026f8548af716446ea880659a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e859ed026f8548af716446ea880659a">&#9670;&nbsp;</a></span>emberAfStopMoveCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfStopMoveCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop Move. </p>
<p>This function is called to cancel a previously scheduled move (rejoin) to a new parent. </p>

</div>
</div>
<a id="ga5ff084e30a38b15dc5ab691b4f41f35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ff084e30a38b15dc5ab691b4f41f35c">&#9670;&nbsp;</a></span>emberAfTrustCenterJoinCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfTrustCenterJoinCallback </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>newNodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>newNodeEui64</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>parentOfNewNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gae85447b46d5b9eae4ebca3e656646659">EmberDeviceUpdate</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#ga395f1f81009b39817c6ad771c398827b">EmberJoinDecision</a>&#160;</td>
          <td class="paramname"><em>decision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trust Center Join. </p>
<p>This callback is called from within the application framework's implementation of emberTrustCenterJoinHandler or ezspTrustCenterJoinHandler. This callback provides the same arguments passed to the TrustCenterJoinHandler. For more information about the TrustCenterJoinHandler please see documentation included in stack/include/trust-center.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newNodeId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">newNodeEui64</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">parentOfNewNode</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">status</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">decision</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1b17b4c0e4e9dd59e5986ea1cc43d7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b17b4c0e4e9dd59e5986ea1cc43d7f6">&#9670;&nbsp;</a></span>emberAfTrustCenterKeepaliveAbortCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfTrustCenterKeepaliveAbortCallback </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trust Center Keepalive Abort. </p>
<p>This callback is called when the device should abort the trust center keepalive process. </p>

</div>
</div>
<a id="ga61e4377ff33ab876ea0238ea0978bac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61e4377ff33ab876ea0238ea0978bac6">&#9670;&nbsp;</a></span>emberAfTrustCenterKeepaliveUpdateCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfTrustCenterKeepaliveUpdateCallback </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>registrationComplete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trust Center Keepalive Update. </p>
<p>This callback is called when the device finishes registration (successfully or otherwise) and the trust center keepalive process must be updated. If the keepalive process has not been started, then it is started. Otherwise if the keepalive is in the process of searching for the TC, it will process the result of that Trust Center search operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">registrationComplete</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1de945082979387aa2f369b62fdc41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1de945082979387aa2f369b62fdc41a">&#9670;&nbsp;</a></span>emberAfUnusedPanIdFoundCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfUnusedPanIdFoundCallback </td>
          <td>(</td>
          <td class="paramtype">EmberPanId&#160;</td>
          <td class="paramname"><em>panId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u&#160;</td>
          <td class="paramname"><em>channel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unused Pan Id Found. </p>
<p>This is called by the framework on behalf of the form-and-join library to notify the application of the PAN id and channel found following a call to ::emberScanForUnusedPanId(). See form-and-join documentation for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">panId</td><td>Ver.: always </td></tr>
    <tr><td class="paramname">channel</td><td>Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad71c19f4df352778fbee455d89ca91ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad71c19f4df352778fbee455d89ca91ab">&#9670;&nbsp;</a></span>emberAfWriteAttributesResponseCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean emberAfWriteAttributesResponseCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__aftypes.html#gaffac400836ff00f9695c7d65f37ee645">EmberAfClusterId</a>&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8u *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16u&#160;</td>
          <td class="paramname"><em>bufLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write Attributes Response. </p>
<p>This function is called by the application framework when a Write Attributes Response command is received from an external device. The application should return true if the message was processed or false if it was not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster identifier of this response. Ver.: always </td></tr>
    <tr><td class="paramname">buffer</td><td>Buffer containing the list of write attribute status records. Ver.: always </td></tr>
    <tr><td class="paramname">bufLen</td><td>The length in bytes of the list. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ac3589b3b019f27f1dffe7f1231451b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ac3589b3b019f27f1dffe7f1231451b">&#9670;&nbsp;</a></span>emberAfZigbeeKeyEstablishmentCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberAfZigbeeKeyEstablishmentCallback </td>
          <td>(</td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>partner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#ga023e020a774781d0819dd1684c9962e1">EmberKeyStatus</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zigbee Key Establishment. </p>
<p>A callback to the application to notify it of the status of the request for a Link Key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partner</td><td>partner The IEEE address of the partner device. Or all zeros if the Key establishment failed. Ver.: always </td></tr>
    <tr><td class="paramname">status</td><td>The status of the key establishment. Ver.: always </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 10 2020 11:32:58 for Zigbee Application Framework API Reference by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
