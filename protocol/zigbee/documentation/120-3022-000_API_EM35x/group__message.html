<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EmberZNet API Reference: For the EM35x SoC Platform: Sending and Receiving Messages</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EmberZNet API Reference: For the EM35x SoC Platform
   &#160;<span id="projectnumber">EmberZNet 6.8.1.0</span>
   </div>
   <div id="projectbrief">For the EFR32 and EM3xx Platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__message.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Sending and Receiving Messages<div class="ingroups"><a class="el" href="group__ember.html">EmberZNet Stack API Reference</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structInterPanHeader.html">InterPanHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for keeping track of all of the header info.  <a href="structInterPanHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab717fa0d4d907c8c305c986eef57680c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gab717fa0d4d907c8c305c986eef57680c">EMBER_APSC_MAX_ACK_WAIT_HOPS_MULTIPLIER_MS</a>&#160;&#160;&#160;50</td></tr>
<tr class="memdesc:gab717fa0d4d907c8c305c986eef57680c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The per-hop delay allowed for in the calculation of the APS ACK timeout value. This is defined in the Zigbee specification. This times the maximum number of hops (EMBER_MAX_HOPS) plus the terminal encrypt/decrypt time is the timeout between retries of an APS ACKed message in milliseconds.  <a href="#gab717fa0d4d907c8c305c986eef57680c">More...</a><br /></td></tr>
<tr class="separator:gab717fa0d4d907c8c305c986eef57680c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc3277354de3ad3883ed8079b7d4fc7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga5cc3277354de3ad3883ed8079b7d4fc7">EMBER_APSC_MAX_ACK_WAIT_TERMINAL_SECURITY_MS</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:ga5cc3277354de3ad3883ed8079b7d4fc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The terminal encrypt/decrypt time allowed for in the calculation of the APS ACK timeout value. This is defined in the ZigBee specification.  <a href="#ga5cc3277354de3ad3883ed8079b7d4fc7">More...</a><br /></td></tr>
<tr class="separator:ga5cc3277354de3ad3883ed8079b7d4fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863e7f1949933404c860e8aef7723dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga863e7f1949933404c860e8aef7723dc2">INTER_PAN_UNICAST</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="separator:ga863e7f1949933404c860e8aef7723dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80b00a03b8376f5325d712b20a2e27a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaa80b00a03b8376f5325d712b20a2e27a">INTER_PAN_BROADCAST</a>&#160;&#160;&#160;0x0B</td></tr>
<tr class="separator:gaa80b00a03b8376f5325d712b20a2e27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba09538bc0e840dfb88a209cf1d4ce46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaba09538bc0e840dfb88a209cf1d4ce46">INTER_PAN_MULTICAST</a>&#160;&#160;&#160;0x0F</td></tr>
<tr class="separator:gaba09538bc0e840dfb88a209cf1d4ce46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51be12efb9e4edc1d0132fc405380d5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga51be12efb9e4edc1d0132fc405380d5c">MAX_INTER_PAN_MAC_SIZE</a>&#160;&#160;&#160;(2 + 1 + 2 + 8 + 2 + 8)</td></tr>
<tr class="separator:ga51be12efb9e4edc1d0132fc405380d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga978c6b4a431e78b9b22d73fc30e8b889"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga978c6b4a431e78b9b22d73fc30e8b889">STUB_NWK_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga978c6b4a431e78b9b22d73fc30e8b889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d7c39bfa1b3bf1385c345b851aca13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga40d7c39bfa1b3bf1385c345b851aca13">STUB_NWK_FRAME_CONTROL</a>&#160;&#160;&#160;0x000B</td></tr>
<tr class="separator:ga40d7c39bfa1b3bf1385c345b851aca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce3b454a51326c63a3a93514648283d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga6ce3b454a51326c63a3a93514648283d">MAX_STUB_APS_SIZE</a>&#160;&#160;&#160;(1 + 2 + 2 + 2)</td></tr>
<tr class="separator:ga6ce3b454a51326c63a3a93514648283d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae536eaf82df040ee023248a974b79953"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gae536eaf82df040ee023248a974b79953">MAX_INTER_PAN_HEADER_SIZE</a>&#160;&#160;&#160;(<a class="el" href="group__message.html#ga51be12efb9e4edc1d0132fc405380d5c">MAX_INTER_PAN_MAC_SIZE</a> + <a class="el" href="group__message.html#ga978c6b4a431e78b9b22d73fc30e8b889">STUB_NWK_SIZE</a> + <a class="el" href="group__message.html#ga6ce3b454a51326c63a3a93514648283d">MAX_STUB_APS_SIZE</a>)</td></tr>
<tr class="separator:gae536eaf82df040ee023248a974b79953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga863e7f1949933404c860e8aef7723dc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga863e7f1949933404c860e8aef7723dc2">INTER_PAN_UNICAST</a>&#160;&#160;&#160;0x03</td></tr>
<tr class="memdesc:ga863e7f1949933404c860e8aef7723dc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The three types of inter-PAN messages. The values are actually the corresponding APS frame controls. 0x03 is the special interPAN message type. Unicast mode is 0x00, broadcast mode is 0x08, and multicast mode is 0x0C.  <a href="#ga863e7f1949933404c860e8aef7723dc2">More...</a><br /></td></tr>
<tr class="separator:ga863e7f1949933404c860e8aef7723dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa80b00a03b8376f5325d712b20a2e27a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaa80b00a03b8376f5325d712b20a2e27a">INTER_PAN_BROADCAST</a>&#160;&#160;&#160;0x0B</td></tr>
<tr class="separator:gaa80b00a03b8376f5325d712b20a2e27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba09538bc0e840dfb88a209cf1d4ce46"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaba09538bc0e840dfb88a209cf1d4ce46">INTER_PAN_MULTICAST</a>&#160;&#160;&#160;0x0F</td></tr>
<tr class="separator:gaba09538bc0e840dfb88a209cf1d4ce46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51be12efb9e4edc1d0132fc405380d5c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga51be12efb9e4edc1d0132fc405380d5c">MAX_INTER_PAN_MAC_SIZE</a>&#160;&#160;&#160;(2 + 1 + 2 + 8 + 2 + 8)</td></tr>
<tr class="separator:ga51be12efb9e4edc1d0132fc405380d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga978c6b4a431e78b9b22d73fc30e8b889"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga978c6b4a431e78b9b22d73fc30e8b889">STUB_NWK_SIZE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga978c6b4a431e78b9b22d73fc30e8b889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40d7c39bfa1b3bf1385c345b851aca13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga40d7c39bfa1b3bf1385c345b851aca13">STUB_NWK_FRAME_CONTROL</a>&#160;&#160;&#160;0x000B</td></tr>
<tr class="separator:ga40d7c39bfa1b3bf1385c345b851aca13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce3b454a51326c63a3a93514648283d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga6ce3b454a51326c63a3a93514648283d">MAX_STUB_APS_SIZE</a>&#160;&#160;&#160;(1 + 2 + 2 + 2)</td></tr>
<tr class="separator:ga6ce3b454a51326c63a3a93514648283d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae536eaf82df040ee023248a974b79953"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gae536eaf82df040ee023248a974b79953">MAX_INTER_PAN_HEADER_SIZE</a>&#160;&#160;&#160;(<a class="el" href="group__message.html#ga51be12efb9e4edc1d0132fc405380d5c">MAX_INTER_PAN_MAC_SIZE</a> + <a class="el" href="group__message.html#ga978c6b4a431e78b9b22d73fc30e8b889">STUB_NWK_SIZE</a> + <a class="el" href="group__message.html#ga6ce3b454a51326c63a3a93514648283d">MAX_STUB_APS_SIZE</a>)</td></tr>
<tr class="separator:gae536eaf82df040ee023248a974b79953"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad236eb939089b00b925c320268d916c2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gad236eb939089b00b925c320268d916c2">emberMaximumApsPayloadLength</a> (void)</td></tr>
<tr class="memdesc:gad236eb939089b00b925c320268d916c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum size of the payload that the Application Support sub-layer will accept.  <a href="#gad236eb939089b00b925c320268d916c2">More...</a><br /></td></tr>
<tr class="separator:gad236eb939089b00b925c320268d916c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga821bd4cd82c2316a1d1cfaaa60d643c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga821bd4cd82c2316a1d1cfaaa60d643c5">emberSendMulticastWithAlias</a> (<a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, uint8_t radius, uint8_t nonmemberRadius, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> message, EmberNodeId alias, uint8_t sequence)</td></tr>
<tr class="memdesc:ga821bd4cd82c2316a1d1cfaaa60d643c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a multicast message for an alias source to all endpoints that share a specific multicast ID and are within a specified number of hops of the sender.  <a href="#ga821bd4cd82c2316a1d1cfaaa60d643c5">More...</a><br /></td></tr>
<tr class="separator:ga821bd4cd82c2316a1d1cfaaa60d643c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa9cc0f9ebba174ce6b94971194a39ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gafa9cc0f9ebba174ce6b94971194a39ef">emberSendMulticast</a> (<a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, uint8_t radius, uint8_t nonmemberRadius, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> message)</td></tr>
<tr class="memdesc:gafa9cc0f9ebba174ce6b94971194a39ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a multicast message to all endpoints that share a specific multicast ID and are within a specified number of hops of the sender.  <a href="#gafa9cc0f9ebba174ce6b94971194a39ef">More...</a><br /></td></tr>
<tr class="separator:gafa9cc0f9ebba174ce6b94971194a39ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436916a25553e6e3ca6267161ed9955c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga436916a25553e6e3ca6267161ed9955c">emberSendUnicast</a> (<a class="el" href="group__ember__types.html#gab77dd07ca7af23a832974d3cc20c94f3">EmberOutgoingMessageType</a> type, uint16_t indexOrDestination, <a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> message)</td></tr>
<tr class="memdesc:ga436916a25553e6e3ca6267161ed9955c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a unicast message per the Zigbee specification.  <a href="#ga436916a25553e6e3ca6267161ed9955c">More...</a><br /></td></tr>
<tr class="separator:ga436916a25553e6e3ca6267161ed9955c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fc8941e6916a147add02b6403e3a27c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga6fc8941e6916a147add02b6403e3a27c">emberSendBroadcast</a> (EmberNodeId destination, <a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, uint8_t radius, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> message)</td></tr>
<tr class="memdesc:ga6fc8941e6916a147add02b6403e3a27c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a broadcast message as per the ZigBee specification.  <a href="#ga6fc8941e6916a147add02b6403e3a27c">More...</a><br /></td></tr>
<tr class="separator:ga6fc8941e6916a147add02b6403e3a27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga603964bbdf9e862f4c5756cc1ce7f81f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga603964bbdf9e862f4c5756cc1ce7f81f">emberProxyBroadcast</a> (EmberNodeId source, EmberNodeId destination, uint8_t sequence, <a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, uint8_t radius, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> message)</td></tr>
<tr class="memdesc:ga603964bbdf9e862f4c5756cc1ce7f81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxies a broadcast message for another node.  <a href="#ga603964bbdf9e862f4c5756cc1ce7f81f">More...</a><br /></td></tr>
<tr class="separator:ga603964bbdf9e862f4c5756cc1ce7f81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae60996531d168a5f928ec1117adc29c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gae60996531d168a5f928ec1117adc29c3">emberProxyNextBroadcastFromLong</a> (uint8_t *euiSource)</td></tr>
<tr class="memdesc:gae60996531d168a5f928ec1117adc29c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxies a broadcast message for another node.  <a href="#gae60996531d168a5f928ec1117adc29c3">More...</a><br /></td></tr>
<tr class="separator:gae60996531d168a5f928ec1117adc29c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf9bc77b5a8edcb3b1d566191417f321"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gacf9bc77b5a8edcb3b1d566191417f321">emberSendManyToOneRouteRequest</a> (uint16_t concentratorType, uint8_t radius)</td></tr>
<tr class="memdesc:gacf9bc77b5a8edcb3b1d566191417f321"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a route request packet that creates routes from every node in the network back to this node.  <a href="#gacf9bc77b5a8edcb3b1d566191417f321">More...</a><br /></td></tr>
<tr class="separator:gacf9bc77b5a8edcb3b1d566191417f321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac39dc6c9c29a0220e6e167696a1793db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gac39dc6c9c29a0220e6e167696a1793db">emberGetSourceRouteTableEntry</a> (uint8_t index, EmberNodeId *destination, uint8_t *closerIndex)</td></tr>
<tr class="memdesc:gac39dc6c9c29a0220e6e167696a1793db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the source route table entry fields.  <a href="#gac39dc6c9c29a0220e6e167696a1793db">More...</a><br /></td></tr>
<tr class="separator:gac39dc6c9c29a0220e6e167696a1793db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e8809dad1b977b68d687618733c6240"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga5e8809dad1b977b68d687618733c6240">emberGetSourceRouteTableFilledSize</a> (void)</td></tr>
<tr class="memdesc:ga5e8809dad1b977b68d687618733c6240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of filled entries in the source route table.  <a href="#ga5e8809dad1b977b68d687618733c6240">More...</a><br /></td></tr>
<tr class="separator:ga5e8809dad1b977b68d687618733c6240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0177609381d8d54a187bcf64b7d2e526"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga0177609381d8d54a187bcf64b7d2e526">emberGetSourceRouteTableTotalSize</a> (void)</td></tr>
<tr class="memdesc:ga0177609381d8d54a187bcf64b7d2e526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the source route table total size.  <a href="#ga0177609381d8d54a187bcf64b7d2e526">More...</a><br /></td></tr>
<tr class="separator:ga0177609381d8d54a187bcf64b7d2e526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23d24be3473255fd3747de84161bc77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaa23d24be3473255fd3747de84161bc77">emberIncomingManyToOneRouteRequestHandler</a> (EmberNodeId source, EmberEUI64 longId, uint8_t cost)</td></tr>
<tr class="memdesc:gaa23d24be3473255fd3747de84161bc77"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback indicating that a many-to-one route to the concentrator with the given short and long ID is available for use.  <a href="#gaa23d24be3473255fd3747de84161bc77">More...</a><br /></td></tr>
<tr class="separator:gaa23d24be3473255fd3747de84161bc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c5d86eaf819247d4f5ab6b66503ec92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga0c5d86eaf819247d4f5ab6b66503ec92">emberIncomingRouteErrorHandler</a> (<a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> status, EmberNodeId target)</td></tr>
<tr class="memdesc:ga0c5d86eaf819247d4f5ab6b66503ec92"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback invoked when a route error message is received.  <a href="#ga0c5d86eaf819247d4f5ab6b66503ec92">More...</a><br /></td></tr>
<tr class="separator:ga0c5d86eaf819247d4f5ab6b66503ec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf68f4589eb595f761c32eb72da25aebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaf68f4589eb595f761c32eb72da25aebf">emberIncomingNetworkStatusHandler</a> (uint8_t errorCode, EmberNodeId target)</td></tr>
<tr class="memdesc:gaf68f4589eb595f761c32eb72da25aebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback invoked when a network status message is received that informs the application of the over-the-air error codes for the specific destination.  <a href="#gaf68f4589eb595f761c32eb72da25aebf">More...</a><br /></td></tr>
<tr class="separator:gaf68f4589eb595f761c32eb72da25aebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d8df86b0964cb9577b1c7705a1ad16e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga2d8df86b0964cb9577b1c7705a1ad16e">emberOverrideIncomingRouteRecordHandler</a> (EmberNodeId source, EmberEUI64 sourceEui, uint8_t relayCount, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> header, uint8_t relayListIndex, bool *consumed)</td></tr>
<tr class="memdesc:ga2d8df86b0964cb9577b1c7705a1ad16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SoC only. It reports the arrival of a route record command frame to the application.  <a href="#ga2d8df86b0964cb9577b1c7705a1ad16e">More...</a><br /></td></tr>
<tr class="separator:ga2d8df86b0964cb9577b1c7705a1ad16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c4d493c420d083aa739e1980ea0bc20"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga9c4d493c420d083aa739e1980ea0bc20">emberOverrideAppendSourceRouteHandler</a> (EmberNodeId destination, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> *header, bool *consumed)</td></tr>
<tr class="memdesc:ga9c4d493c420d083aa739e1980ea0bc20"><td class="mdescLeft">&#160;</td><td class="mdescRight">SoC only. The application can implement this callback to supply source routes to outgoing messages.  <a href="#ga9c4d493c420d083aa739e1980ea0bc20">More...</a><br /></td></tr>
<tr class="separator:ga9c4d493c420d083aa739e1980ea0bc20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f89cedc4b54536289ed478e747702b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga59f89cedc4b54536289ed478e747702b">emberIncomingRouteRecordHandler</a> (EmberNodeId source, EmberEUI64 sourceEui, uint8_t relayCount, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> header, uint8_t relayListIndex)</td></tr>
<tr class="memdesc:ga59f89cedc4b54536289ed478e747702b"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECTAED emberOverrideIncomingRouteRecordHandler should be used Reports the arrival of a route record command frame to the application.  <a href="#ga59f89cedc4b54536289ed478e747702b">More...</a><br /></td></tr>
<tr class="separator:ga59f89cedc4b54536289ed478e747702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf03d05c8e8cdaec6313ea54f5e742931"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaf03d05c8e8cdaec6313ea54f5e742931">emberAppendSourceRouteHandler</a> (EmberNodeId destination, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> header)</td></tr>
<tr class="memdesc:gaf03d05c8e8cdaec6313ea54f5e742931"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED emberOverrideAppendSourceRouteHandler should be used The application can implement this callback to supply source routes to outgoing messages.  <a href="#gaf03d05c8e8cdaec6313ea54f5e742931">More...</a><br /></td></tr>
<tr class="separator:gaf03d05c8e8cdaec6313ea54f5e742931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56aaca72ec377f21b6ae110838df9e5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga56aaca72ec377f21b6ae110838df9e5e">emberCancelMessage</a> (<a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> message)</td></tr>
<tr class="memdesc:ga56aaca72ec377f21b6ae110838df9e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">DEPRECATED.  <a href="#ga56aaca72ec377f21b6ae110838df9e5e">More...</a><br /></td></tr>
<tr class="separator:ga56aaca72ec377f21b6ae110838df9e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf132904d585ce31f4697ed5904b31d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gabf132904d585ce31f4697ed5904b31d4">emberMessageSentHandler</a> (<a class="el" href="group__ember__types.html#gab77dd07ca7af23a832974d3cc20c94f3">EmberOutgoingMessageType</a> type, uint16_t indexOrDestination, <a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> message, <a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> status)</td></tr>
<tr class="memdesc:gabf132904d585ce31f4697ed5904b31d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback invoked by the stack when it has completed sending a message.  <a href="#gabf132904d585ce31f4697ed5904b31d4">More...</a><br /></td></tr>
<tr class="separator:gabf132904d585ce31f4697ed5904b31d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c58e72b74314b649ad0662fa4f0afef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef">emberIncomingMessageHandler</a> (<a class="el" href="group__ember__types.html#ga42567c6bfd58e0161e3c660f99f455da">EmberIncomingMessageType</a> type, <a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *apsFrame, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> message)</td></tr>
<tr class="memdesc:ga9c58e72b74314b649ad0662fa4f0afef"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback invoked by the EmberZNet stack when a message is received.  <a href="#ga9c58e72b74314b649ad0662fa4f0afef">More...</a><br /></td></tr>
<tr class="separator:ga9c58e72b74314b649ad0662fa4f0afef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae677c27ad77d71c6c82f699a9c18895c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gae677c27ad77d71c6c82f699a9c18895c">emberGetLastHopLqi</a> (uint8_t *lastHopLqi)</td></tr>
<tr class="memdesc:gae677c27ad77d71c6c82f699a9c18895c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the link quality from the node that last relayed the current message.  <a href="#gae677c27ad77d71c6c82f699a9c18895c">More...</a><br /></td></tr>
<tr class="separator:gae677c27ad77d71c6c82f699a9c18895c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ffe11b42f9e9753e261ff6e68201c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga7ffe11b42f9e9753e261ff6e68201c3f">emberGetLastHopRssi</a> (int8_t *lastHopRssi)</td></tr>
<tr class="memdesc:ga7ffe11b42f9e9753e261ff6e68201c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the receive signal strength indication (RSSI) for the current message.  <a href="#ga7ffe11b42f9e9753e261ff6e68201c3f">More...</a><br /></td></tr>
<tr class="separator:ga7ffe11b42f9e9753e261ff6e68201c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ba9c0e0cfb5f98269b319a14d9fb8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga58ba9c0e0cfb5f98269b319a14d9fb8f">emberGetLastHopTimestamp</a> (uint32_t *lastHopTimestamp)</td></tr>
<tr class="memdesc:ga58ba9c0e0cfb5f98269b319a14d9fb8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the receive timestamp (value of the MAC timer; ticks since up) of the moment when the Start Frame Delimiter (SFD) was received for the current message.  <a href="#ga58ba9c0e0cfb5f98269b319a14d9fb8f">More...</a><br /></td></tr>
<tr class="separator:ga58ba9c0e0cfb5f98269b319a14d9fb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e7aa86a2bd7358a6bb8183d0b708de5"><td class="memItemLeft" align="right" valign="top">EmberNodeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga2e7aa86a2bd7358a6bb8183d0b708de5">emberGetSender</a> (void)</td></tr>
<tr class="memdesc:ga2e7aa86a2bd7358a6bb8183d0b708de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node ID of the sender of the current incoming message.  <a href="#ga2e7aa86a2bd7358a6bb8183d0b708de5">More...</a><br /></td></tr>
<tr class="separator:ga2e7aa86a2bd7358a6bb8183d0b708de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a7c82bda7e5f6b51c12dff042574be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga20a7c82bda7e5f6b51c12dff042574be">emberGetSenderEui64</a> (EmberEUI64 senderEui64)</td></tr>
<tr class="memdesc:ga20a7c82bda7e5f6b51c12dff042574be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the EUI64 of the sender of the current incoming message if the sender chose to include this information in the message. The <a class="el" href="group__ember__types.html#ggad2a739a76b34fd352df6ef65ffaeaefea3241b6411d6c462067ca066de348680d">EMBER_APS_OPTION_SOURCE_EUI64</a> bit in the options field of the APS frame of the incoming message indicates that the EUI64 is present in the message.  <a href="#ga20a7c82bda7e5f6b51c12dff042574be">More...</a><br /></td></tr>
<tr class="separator:ga20a7c82bda7e5f6b51c12dff042574be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ccf3776c454626315702e379a127fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaf3ccf3776c454626315702e379a127fe">emberSendReply</a> (uint16_t clusterId, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> reply)</td></tr>
<tr class="memdesc:gaf3ccf3776c454626315702e379a127fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a reply for an application that has received a unicast message.  <a href="#gaf3ccf3776c454626315702e379a127fe">More...</a><br /></td></tr>
<tr class="separator:gaf3ccf3776c454626315702e379a127fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe39e1968082581a1d24e2b9a495301c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gabe39e1968082581a1d24e2b9a495301c">emberSetReplyFragmentData</a> (uint16_t fragmentData)</td></tr>
<tr class="memdesc:gabe39e1968082581a1d24e2b9a495301c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fragment data to be used when sending a reply to a unicast message.  <a href="#gabe39e1968082581a1d24e2b9a495301c">More...</a><br /></td></tr>
<tr class="separator:gabe39e1968082581a1d24e2b9a495301c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4b82fa85c82e9a11199ce1fff129102"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaa4b82fa85c82e9a11199ce1fff129102">emberAddressTableEntryIsActive</a> (uint8_t addressTableIndex)</td></tr>
<tr class="memdesc:gaa4b82fa85c82e9a11199ce1fff129102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether any messages are currently being sent using this address table entry.  <a href="#gaa4b82fa85c82e9a11199ce1fff129102">More...</a><br /></td></tr>
<tr class="separator:gaa4b82fa85c82e9a11199ce1fff129102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga900156d5b8bf998d2e33d9ee9e53d9ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga900156d5b8bf998d2e33d9ee9e53d9ef">emberSetAddressTableRemoteEui64</a> (uint8_t addressTableIndex, EmberEUI64 eui64)</td></tr>
<tr class="memdesc:ga900156d5b8bf998d2e33d9ee9e53d9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the EUI64 of an address table entry.  <a href="#ga900156d5b8bf998d2e33d9ee9e53d9ef">More...</a><br /></td></tr>
<tr class="separator:ga900156d5b8bf998d2e33d9ee9e53d9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf071c9ab13d6ecb2f1a7cc69cf3c0b8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaf071c9ab13d6ecb2f1a7cc69cf3c0b8d">emberSetAddressTableRemoteNodeId</a> (uint8_t addressTableIndex, EmberNodeId id)</td></tr>
<tr class="memdesc:gaf071c9ab13d6ecb2f1a7cc69cf3c0b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the short ID of an address table entry.  <a href="#gaf071c9ab13d6ecb2f1a7cc69cf3c0b8d">More...</a><br /></td></tr>
<tr class="separator:gaf071c9ab13d6ecb2f1a7cc69cf3c0b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62d6f7b566b455e51c8719ef5209f962"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga62d6f7b566b455e51c8719ef5209f962">emberGetAddressTableRemoteEui64</a> (uint8_t addressTableIndex, EmberEUI64 eui64)</td></tr>
<tr class="memdesc:ga62d6f7b566b455e51c8719ef5209f962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the EUI64 of an address table entry.  <a href="#ga62d6f7b566b455e51c8719ef5209f962">More...</a><br /></td></tr>
<tr class="separator:ga62d6f7b566b455e51c8719ef5209f962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca5302a2e947d6c12cfdd8beb6331764"><td class="memItemLeft" align="right" valign="top">EmberNodeId&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaca5302a2e947d6c12cfdd8beb6331764">emberGetAddressTableRemoteNodeId</a> (uint8_t addressTableIndex)</td></tr>
<tr class="memdesc:gaca5302a2e947d6c12cfdd8beb6331764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the short ID of an address table entry.  <a href="#gaca5302a2e947d6c12cfdd8beb6331764">More...</a><br /></td></tr>
<tr class="separator:gaca5302a2e947d6c12cfdd8beb6331764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e8ce45e2b325443be7f61bd34d44d1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga1e8ce45e2b325443be7f61bd34d44d1c">emberSetExtendedTimeout</a> (EmberEUI64 remoteEui64, bool extendedTimeout)</td></tr>
<tr class="memdesc:ga1e8ce45e2b325443be7f61bd34d44d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the stack whether or not the normal interval between retransmissions of a retried unicast message should be increased by <a class="el" href="group__configuration.html#gade661ac2bfb536d5fef03b195f927d35" title="The maximum amount of time (in milliseconds) that the MAC will hold a message for indirect transmissi...">EMBER_INDIRECT_TRANSMISSION_TIMEOUT</a>.  <a href="#ga1e8ce45e2b325443be7f61bd34d44d1c">More...</a><br /></td></tr>
<tr class="separator:ga1e8ce45e2b325443be7f61bd34d44d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c00e7162727fb273733b50edb2b49a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga8c00e7162727fb273733b50edb2b49a4">emberGetExtendedTimeout</a> (EmberEUI64 remoteEui64)</td></tr>
<tr class="memdesc:ga8c00e7162727fb273733b50edb2b49a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether or not the stack will extend the normal interval between retransmissions of a retried unicast message by <a class="el" href="group__configuration.html#gade661ac2bfb536d5fef03b195f927d35" title="The maximum amount of time (in milliseconds) that the MAC will hold a message for indirect transmissi...">EMBER_INDIRECT_TRANSMISSION_TIMEOUT</a>.  <a href="#ga8c00e7162727fb273733b50edb2b49a4">More...</a><br /></td></tr>
<tr class="separator:ga8c00e7162727fb273733b50edb2b49a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga634299324a0e05cfaf486ad3cf10c03f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga634299324a0e05cfaf486ad3cf10c03f">emberIdConflictHandler</a> (EmberNodeId conflictingId)</td></tr>
<tr class="memdesc:ga634299324a0e05cfaf486ad3cf10c03f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback invoked by the EmberZNet stack when an ID conflict is discovered, that is, two different nodes in the network were found to be using the same short ID.  <a href="#ga634299324a0e05cfaf486ad3cf10c03f">More...</a><br /></td></tr>
<tr class="separator:ga634299324a0e05cfaf486ad3cf10c03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31ad1d4578175d4c1a45469730f55b88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga31ad1d4578175d4c1a45469730f55b88">emberPendingAckedMessages</a> (void)</td></tr>
<tr class="memdesc:ga31ad1d4578175d4c1a45469730f55b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether there are pending messages in the APS retry queue.  <a href="#ga31ad1d4578175d4c1a45469730f55b88">More...</a><br /></td></tr>
<tr class="separator:ga31ad1d4578175d4c1a45469730f55b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9216ce20fb84518e8d1815332d6da2be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga9216ce20fb84518e8d1815332d6da2be">emberBroadcastSetMinAcksNeeded</a> (uint8_t minAcksNeeded)</td></tr>
<tr class="memdesc:ga9216ce20fb84518e8d1815332d6da2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of broadcast passive acknowledgements required before terminating a broadcast transmission. A value of 0xFF causes the node to wait for all neighbors to re-broadcast the packet before terminating the transmission. The default value is 0xFF.  <a href="#ga9216ce20fb84518e8d1815332d6da2be">More...</a><br /></td></tr>
<tr class="separator:ga9216ce20fb84518e8d1815332d6da2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa955c8bf92dde29132059a635c673ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaa955c8bf92dde29132059a635c673ba9">emberPacketHandoffIncoming</a> (<a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a> packetType, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> packetBuffer, uint8_t index, void *data)</td></tr>
<tr class="memdesc:gaa955c8bf92dde29132059a635c673ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intercepts an incoming packet from the stack and hands off to a plugin for further processing.  <a href="#gaa955c8bf92dde29132059a635c673ba9">More...</a><br /></td></tr>
<tr class="separator:gaa955c8bf92dde29132059a635c673ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga233b61c0cc1c3f2df3792934971c3b43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga233b61c0cc1c3f2df3792934971c3b43">emberPacketHandoffOutgoing</a> (<a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a> packetType, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> packetBuffer, uint8_t index, void *data)</td></tr>
<tr class="memdesc:ga233b61c0cc1c3f2df3792934971c3b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intercepts an outgoing packet from the stack and hands off to a plugin for further processing.  <a href="#ga233b61c0cc1c3f2df3792934971c3b43">More...</a><br /></td></tr>
<tr class="separator:ga233b61c0cc1c3f2df3792934971c3b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga195a002571b90f45b354dc398790274c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga195a002571b90f45b354dc398790274c">emberAfIncomingPacketFilterCallback</a> (<a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a> packetType, uint8_t *packetData, uint8_t *size_p, void *data)</td></tr>
<tr class="memdesc:ga195a002571b90f45b354dc398790274c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A protocol layer packet has been received by the stack.  <a href="#ga195a002571b90f45b354dc398790274c">More...</a><br /></td></tr>
<tr class="separator:ga195a002571b90f45b354dc398790274c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b59d18e5ee87884475914a7ee9a76f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gaa9b59d18e5ee87884475914a7ee9a76f">emberAfOutgoingPacketFilterCallback</a> (<a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a> packetType, uint8_t *packetData, uint8_t *size_p, void *data)</td></tr>
<tr class="memdesc:gaa9b59d18e5ee87884475914a7ee9a76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The stack is preparing to send a protocol layer packet.  <a href="#gaa9b59d18e5ee87884475914a7ee9a76f">More...</a><br /></td></tr>
<tr class="separator:gaa9b59d18e5ee87884475914a7ee9a76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9b486b6a20e47b47f52e2c6fc25b96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga7a9b486b6a20e47b47f52e2c6fc25b96">makeInterPanMessage</a> (<a class="el" href="structInterPanHeader.html">InterPanHeader</a> *headerData, <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> payload)</td></tr>
<tr class="memdesc:ga7a9b486b6a20e47b47f52e2c6fc25b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an interpan message suitable for passing to emberSendRawMessage().  <a href="#ga7a9b486b6a20e47b47f52e2c6fc25b96">More...</a><br /></td></tr>
<tr class="separator:ga7a9b486b6a20e47b47f52e2c6fc25b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3f3ef1af2046407929cf36d51735c7d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gab3f3ef1af2046407929cf36d51735c7d">parseInterPanMessage</a> (<a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> message, uint8_t startOffset, <a class="el" href="structInterPanHeader.html">InterPanHeader</a> *headerData)</td></tr>
<tr class="memdesc:gab3f3ef1af2046407929cf36d51735c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is meant to be called on the message and offset values passed to emberMacPassthroughMessageHandler(...). The header is parsed and the various fields are written to the <a class="el" href="structInterPanHeader.html" title="A struct for keeping track of all of the header info. ">InterPanHeader</a>. The returned value is the offset of the payload in the message, or 0 if the message is not a correctly formed AMI interPAN message.  <a href="#gab3f3ef1af2046407929cf36d51735c7d">More...</a><br /></td></tr>
<tr class="separator:gab3f3ef1af2046407929cf36d51735c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a6954c4aff2ac4ab7ff230be3450022"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga1a6954c4aff2ac4ab7ff230be3450022">makeInterPanMessage</a> (<a class="el" href="structInterPanHeader.html">InterPanHeader</a> *headerData, uint8_t *message, uint8_t maxLength, uint8_t *payload, uint8_t payloadLength)</td></tr>
<tr class="memdesc:ga1a6954c4aff2ac4ab7ff230be3450022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an interpan message. message needs to have enough space for the message contents. Upon return, the return value will be the length of the message, or 0 in case of error.  <a href="#ga1a6954c4aff2ac4ab7ff230be3450022">More...</a><br /></td></tr>
<tr class="separator:ga1a6954c4aff2ac4ab7ff230be3450022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac55d8837933a52ab5d759b2718cbfa96"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gac55d8837933a52ab5d759b2718cbfa96">parseInterPanMessage</a> (uint8_t *message, uint8_t messageLength, <a class="el" href="structInterPanHeader.html">InterPanHeader</a> *headerData)</td></tr>
<tr class="memdesc:gac55d8837933a52ab5d759b2718cbfa96"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is meant to be called on the message passed to emberMacPassthroughMessageHandler(...). The header is parsed and the various fields are written to the <a class="el" href="structInterPanHeader.html" title="A struct for keeping track of all of the header info. ">InterPanHeader</a>. The returned value is the offset of the payload in the message, or 0 if the message is not a correctly formed AMI interPAN message.  <a href="#gac55d8837933a52ab5d759b2718cbfa96">More...</a><br /></td></tr>
<tr class="separator:gac55d8837933a52ab5d759b2718cbfa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga740628a12e72bce15769344afc3e414f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#ga740628a12e72bce15769344afc3e414f">emberApsAckTimeoutMs</a></td></tr>
<tr class="memdesc:ga740628a12e72bce15769344afc3e414f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The APS ACK timeout value. The stack waits this amount of time between resends of APS retried messages. The default value is:  <a href="#ga740628a12e72bce15769344afc3e414f">More...</a><br /></td></tr>
<tr class="separator:ga740628a12e72bce15769344afc3e414f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac00eb4bd42a4c0c5e8ab0cfcf7ce3e19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structEmberMulticastTableEntry.html">EmberMulticastTableEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gac00eb4bd42a4c0c5e8ab0cfcf7ce3e19">emberMulticastTable</a></td></tr>
<tr class="memdesc:gac00eb4bd42a4c0c5e8ab0cfcf7ce3e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multicast table.  <a href="#gac00eb4bd42a4c0c5e8ab0cfcf7ce3e19">More...</a><br /></td></tr>
<tr class="separator:gac00eb4bd42a4c0c5e8ab0cfcf7ce3e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6e3b5c2ede4f56822e2dfac622fc094"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__message.html#gab6e3b5c2ede4f56822e2dfac622fc094">emberMulticastTableSize</a></td></tr>
<tr class="memdesc:gab6e3b5c2ede4f56822e2dfac622fc094"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of entries in the multicast table.  <a href="#gab6e3b5c2ede4f56822e2dfac622fc094">More...</a><br /></td></tr>
<tr class="separator:gab6e3b5c2ede4f56822e2dfac622fc094"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>See <a class="el" href="message_8h.html" title="EmberZNet API for sending and receiving messages. See Sending and Receiving Messages for documentatio...">message.h</a> for source code.</p>
<p>See also <a class="el" href="ami-inter-pan_8h.html" title="Utilities for sending and receiving ZigBee AMI InterPAN messages. See Sending and Receiving Messages ...">ami-inter-pan.h</a> for source code.</p>
<p>See also <a class="el" href="ami-inter-pan-host_8h.html" title="Utilities for sending and receiving ZigBee AMI InterPAN messages. See Sending and Receiving Messages ...">ami-inter-pan-host.h</a> for source code. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gab717fa0d4d907c8c305c986eef57680c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab717fa0d4d907c8c305c986eef57680c">&#9670;&nbsp;</a></span>EMBER_APSC_MAX_ACK_WAIT_HOPS_MULTIPLIER_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EMBER_APSC_MAX_ACK_WAIT_HOPS_MULTIPLIER_MS&#160;&#160;&#160;50</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The per-hop delay allowed for in the calculation of the APS ACK timeout value. This is defined in the Zigbee specification. This times the maximum number of hops (EMBER_MAX_HOPS) plus the terminal encrypt/decrypt time is the timeout between retries of an APS ACKed message in milliseconds. </p>

</div>
</div>
<a id="ga5cc3277354de3ad3883ed8079b7d4fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cc3277354de3ad3883ed8079b7d4fc7">&#9670;&nbsp;</a></span>EMBER_APSC_MAX_ACK_WAIT_TERMINAL_SECURITY_MS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EMBER_APSC_MAX_ACK_WAIT_TERMINAL_SECURITY_MS&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The terminal encrypt/decrypt time allowed for in the calculation of the APS ACK timeout value. This is defined in the ZigBee specification. </p>

</div>
</div>
<a id="gaa80b00a03b8376f5325d712b20a2e27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80b00a03b8376f5325d712b20a2e27a">&#9670;&nbsp;</a></span>INTER_PAN_BROADCAST <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTER_PAN_BROADCAST&#160;&#160;&#160;0x0B</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa80b00a03b8376f5325d712b20a2e27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa80b00a03b8376f5325d712b20a2e27a">&#9670;&nbsp;</a></span>INTER_PAN_BROADCAST <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTER_PAN_BROADCAST&#160;&#160;&#160;0x0B</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaba09538bc0e840dfb88a209cf1d4ce46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba09538bc0e840dfb88a209cf1d4ce46">&#9670;&nbsp;</a></span>INTER_PAN_MULTICAST <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTER_PAN_MULTICAST&#160;&#160;&#160;0x0F</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaba09538bc0e840dfb88a209cf1d4ce46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba09538bc0e840dfb88a209cf1d4ce46">&#9670;&nbsp;</a></span>INTER_PAN_MULTICAST <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTER_PAN_MULTICAST&#160;&#160;&#160;0x0F</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga863e7f1949933404c860e8aef7723dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga863e7f1949933404c860e8aef7723dc2">&#9670;&nbsp;</a></span>INTER_PAN_UNICAST <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTER_PAN_UNICAST&#160;&#160;&#160;0x03</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The three types of inter-PAN messages. The values are actually the corresponding APS frame controls. 0x03 is the special interPAN message type. Unicast mode is 0x00, broadcast mode is 0x08, and multicast mode is 0x0C. </p>

</div>
</div>
<a id="ga863e7f1949933404c860e8aef7723dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga863e7f1949933404c860e8aef7723dc2">&#9670;&nbsp;</a></span>INTER_PAN_UNICAST <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTER_PAN_UNICAST&#160;&#160;&#160;0x03</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae536eaf82df040ee023248a974b79953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae536eaf82df040ee023248a974b79953">&#9670;&nbsp;</a></span>MAX_INTER_PAN_HEADER_SIZE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_INTER_PAN_HEADER_SIZE&#160;&#160;&#160;(<a class="el" href="group__message.html#ga51be12efb9e4edc1d0132fc405380d5c">MAX_INTER_PAN_MAC_SIZE</a> + <a class="el" href="group__message.html#ga978c6b4a431e78b9b22d73fc30e8b889">STUB_NWK_SIZE</a> + <a class="el" href="group__message.html#ga6ce3b454a51326c63a3a93514648283d">MAX_STUB_APS_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gae536eaf82df040ee023248a974b79953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae536eaf82df040ee023248a974b79953">&#9670;&nbsp;</a></span>MAX_INTER_PAN_HEADER_SIZE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_INTER_PAN_HEADER_SIZE&#160;&#160;&#160;(<a class="el" href="group__message.html#ga51be12efb9e4edc1d0132fc405380d5c">MAX_INTER_PAN_MAC_SIZE</a> + <a class="el" href="group__message.html#ga978c6b4a431e78b9b22d73fc30e8b889">STUB_NWK_SIZE</a> + <a class="el" href="group__message.html#ga6ce3b454a51326c63a3a93514648283d">MAX_STUB_APS_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga51be12efb9e4edc1d0132fc405380d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51be12efb9e4edc1d0132fc405380d5c">&#9670;&nbsp;</a></span>MAX_INTER_PAN_MAC_SIZE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_INTER_PAN_MAC_SIZE&#160;&#160;&#160;(2 + 1 + 2 + 8 + 2 + 8)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga51be12efb9e4edc1d0132fc405380d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51be12efb9e4edc1d0132fc405380d5c">&#9670;&nbsp;</a></span>MAX_INTER_PAN_MAC_SIZE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_INTER_PAN_MAC_SIZE&#160;&#160;&#160;(2 + 1 + 2 + 8 + 2 + 8)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6ce3b454a51326c63a3a93514648283d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce3b454a51326c63a3a93514648283d">&#9670;&nbsp;</a></span>MAX_STUB_APS_SIZE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_STUB_APS_SIZE&#160;&#160;&#160;(1 + 2 + 2 + 2)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga6ce3b454a51326c63a3a93514648283d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce3b454a51326c63a3a93514648283d">&#9670;&nbsp;</a></span>MAX_STUB_APS_SIZE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_STUB_APS_SIZE&#160;&#160;&#160;(1 + 2 + 2 + 2)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga40d7c39bfa1b3bf1385c345b851aca13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40d7c39bfa1b3bf1385c345b851aca13">&#9670;&nbsp;</a></span>STUB_NWK_FRAME_CONTROL <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUB_NWK_FRAME_CONTROL&#160;&#160;&#160;0x000B</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga40d7c39bfa1b3bf1385c345b851aca13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40d7c39bfa1b3bf1385c345b851aca13">&#9670;&nbsp;</a></span>STUB_NWK_FRAME_CONTROL <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUB_NWK_FRAME_CONTROL&#160;&#160;&#160;0x000B</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga978c6b4a431e78b9b22d73fc30e8b889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga978c6b4a431e78b9b22d73fc30e8b889">&#9670;&nbsp;</a></span>STUB_NWK_SIZE <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUB_NWK_SIZE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga978c6b4a431e78b9b22d73fc30e8b889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga978c6b4a431e78b9b22d73fc30e8b889">&#9670;&nbsp;</a></span>STUB_NWK_SIZE <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUB_NWK_SIZE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa4b82fa85c82e9a11199ce1fff129102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4b82fa85c82e9a11199ce1fff129102">&#9670;&nbsp;</a></span>emberAddressTableEntryIsActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool emberAddressTableEntryIsActive </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addressTableIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether any messages are currently being sent using this address table entry. </p>
<p>Note that this function does not indicate whether the address table entry is unused. To determine whether an address table entry is unused, check the remote node ID. The remote node ID will have the value <a class="el" href="group__ember__types.html#gaf4a9110ca9be0fb3639dbacedd53f276" title="A distinguished network ID that will never be assigned to any node. ">EMBER_TABLE_ENTRY_UNUSED_NODE_ID</a> when the address table entry is not in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressTableIndex</td><td>The index of an address table entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the address table entry is active, false otherwise. </dd></dl>

</div>
</div>
<a id="ga195a002571b90f45b354dc398790274c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga195a002571b90f45b354dc398790274c">&#9670;&nbsp;</a></span>emberAfIncomingPacketFilterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a> emberAfIncomingPacketFilterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>size_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A protocol layer packet has been received by the stack. </p>
<p>This is called when the stack receives a packet that is meant for one of the protocol layers specified in <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a>.</p>
<p>The packetType argument is one of the values of the <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a> enum. If the stack receives an 802.15.4 MAC beacon, it will call this function with the packetType argument set to <a class="el" href="group__ember__types.html#ggabc84c30424c97df09e02b15c5648f73daf1c7763f9a7fcc664e44a823d75a5588">EMBER_ZIGBEE_PACKET_TYPE_BEACON</a>.</p>
<p>The implementation of this callback may alter the data contained in packetData, modify options and flags in the auxillary data, or consume the packet itself, either sending the message, or discarding it as it sees fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>The type of packet received. See <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a>. </td></tr>
    <tr><td class="paramname">packetData</td><td>A flat buffer containing the packet contents the buffer starts with the command id followed by the payload </td></tr>
    <tr><td class="paramname">size_p</td><td>a pointer to the size of the packet data </td></tr>
    <tr><td class="paramname">data</td><td>This is a pointer to auxiliary data for the command.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7" title="indication of the action taken on a packet ">EmberPacketAction</a> indicating what action should be taken for the packet, EMBER_ACCEPT_PACKET, EMBER_DROP_PACKET, or EMBER_MANGLE_PACKET </dd></dl>

</div>
</div>
<a id="gaa9b59d18e5ee87884475914a7ee9a76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9b59d18e5ee87884475914a7ee9a76f">&#9670;&nbsp;</a></span>emberAfOutgoingPacketFilterCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a> emberAfOutgoingPacketFilterCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>packetData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>size_p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The stack is preparing to send a protocol layer packet. </p>
<p>This is called when the stack is preparing to send a packet from one of the protocol layers specified in <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a>.</p>
<p>The packetType argument is one of the values of the <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a> enum. If the stack is preparing to send an 802.15.4 MAC beacon, it will call this function with the packetType argument set to <a class="el" href="group__ember__types.html#ggabc84c30424c97df09e02b15c5648f73daf1c7763f9a7fcc664e44a823d75a5588">EMBER_ZIGBEE_PACKET_TYPE_BEACON</a>.</p>
<p>The implementation of this callback may alter the data contained in packetData, modify options and flags in the auxillary data, or consume the packet itself, either sending the message, or discarding it as it sees fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>The type of packet received. See <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a>. </td></tr>
    <tr><td class="paramname">packetData</td><td>A flat buffer containing the packet contents the buffer starts with the command id followed by the payload </td></tr>
    <tr><td class="paramname">size_p</td><td>a pointer to the size of the packet data </td></tr>
    <tr><td class="paramname">data</td><td>This is a pointer to auxiliary data for the command. ZDO commands pass the <a class="el" href="structEmberApsFrame.html" title="An in-memory representation of a ZigBee APS frame of an incoming or outgoing message. ">EmberApsFrame</a> associated with the packet here. Otherwise, this value is NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7" title="indication of the action taken on a packet ">EmberPacketAction</a> indicating what action should be taken for the packet, EMBER_ACCEPT_PACKET, EMBER_DROP_PACKET, or EMBER_MANGLE_PACKET </dd></dl>

</div>
</div>
<a id="gaf03d05c8e8cdaec6313ea54f5e742931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf03d05c8e8cdaec6313ea54f5e742931">&#9670;&nbsp;</a></span>emberAppendSourceRouteHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t emberAppendSourceRouteHandler </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED emberOverrideAppendSourceRouteHandler should be used The application can implement this callback to supply source routes to outgoing messages. </p>
<p>The application must define :EMBER_APPLICATION_HAS_SOURCE_ROUTING in its configuration header to use this. The application uses the supplied destination to look up a source route. If available, the application appends the source route to the supplied header using the proper frame format, as described in section 3.4.1.9 "Source Route Subframe Field" of the ZigBee specification. If a source route is appended, the stack takes care of setting the proper flag in the network frame control field. See app/util/source-route.c for a sample implementation.</p>
<p>If header is :EMBER_NULL_MESSAGE_BUFFER the only action is to return the size of the source route frame needed to the destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The network destination of the message. </td></tr>
    <tr><td class="paramname">header</td><td>The message buffer containing the partially complete packet header. The application appends the source route frame to this header.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the source route frame, or zero if there is not one available. </dd></dl>

</div>
</div>
<a id="ga9216ce20fb84518e8d1815332d6da2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9216ce20fb84518e8d1815332d6da2be">&#9670;&nbsp;</a></span>emberBroadcastSetMinAcksNeeded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberBroadcastSetMinAcksNeeded </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>minAcksNeeded</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of broadcast passive acknowledgements required before terminating a broadcast transmission. A value of 0xFF causes the node to wait for all neighbors to re-broadcast the packet before terminating the transmission. The default value is 0xFF. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minAcksNeeded</td><td>The minimum number of acknowledgments (re-broadcasts) to wait for until deeming the broadcast transmission complete.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="ga56aaca72ec377f21b6ae110838df9e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56aaca72ec377f21b6ae110838df9e5e">&#9670;&nbsp;</a></span>emberCancelMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberCancelMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECATED. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>A message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a>. </dd></dl>

</div>
</div>
<a id="ga62d6f7b566b455e51c8719ef5209f962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62d6f7b566b455e51c8719ef5209f962">&#9670;&nbsp;</a></span>emberGetAddressTableRemoteEui64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberGetAddressTableRemoteEui64 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addressTableIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>eui64</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the EUI64 of an address table entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressTableIndex</td><td>The index of an address table entry.</td></tr>
    <tr><td class="paramname">eui64</td><td>The EUI64 of the address table entry is copied to this location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca5302a2e947d6c12cfdd8beb6331764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca5302a2e947d6c12cfdd8beb6331764">&#9670;&nbsp;</a></span>emberGetAddressTableRemoteNodeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EmberNodeId emberGetAddressTableRemoteNodeId </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addressTableIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the short ID of an address table entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressTableIndex</td><td>The index of an address table entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of the following:<ul>
<li>The short ID corresponding to the remote node whose EUI64 is stored in the address table at the given index.</li>
<li><a class="el" href="group__ember__types.html#ga7b441affd0a4ed88b5bf1fb21340a353" title="A distinguished network ID that will never be assigned to any node. This value is used when getting t...">EMBER_UNKNOWN_NODE_ID</a> - Indicates that the EUI64 stored in the address table at the given index is valid but the short ID is currently unknown.</li>
<li><a class="el" href="group__ember__types.html#ga58f47c143fefe2123aae4b2c9825ce3a" title="A distinguished network ID that will never be assigned to any node. This value is used when getting t...">EMBER_DISCOVERY_ACTIVE_NODE_ID</a> - Indicates that the EUI64 stored in the address table at the given location is valid and network address discovery is underway.</li>
<li><a class="el" href="group__ember__types.html#gaf4a9110ca9be0fb3639dbacedd53f276" title="A distinguished network ID that will never be assigned to any node. ">EMBER_TABLE_ENTRY_UNUSED_NODE_ID</a> - Indicates that the entry stored in the address table at the given index is not in use. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga8c00e7162727fb273733b50edb2b49a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c00e7162727fb273733b50edb2b49a4">&#9670;&nbsp;</a></span>emberGetExtendedTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool emberGetExtendedTimeout </td>
          <td>(</td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>remoteEui64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether or not the stack will extend the normal interval between retransmissions of a retried unicast message by <a class="el" href="group__configuration.html#gade661ac2bfb536d5fef03b195f927d35" title="The maximum amount of time (in milliseconds) that the MAC will hold a message for indirect transmissi...">EMBER_INDIRECT_TRANSMISSION_TIMEOUT</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remoteEui64</td><td>The address of the node for which the timeout is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the retry interval will be increased by <a class="el" href="group__configuration.html#gade661ac2bfb536d5fef03b195f927d35" title="The maximum amount of time (in milliseconds) that the MAC will hold a message for indirect transmissi...">EMBER_INDIRECT_TRANSMISSION_TIMEOUT</a> and false if the normal retry interval will be used. </dd></dl>

</div>
</div>
<a id="gae677c27ad77d71c6c82f699a9c18895c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae677c27ad77d71c6c82f699a9c18895c">&#9670;&nbsp;</a></span>emberGetLastHopLqi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberGetLastHopLqi </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>lastHopLqi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the link quality from the node that last relayed the current message. </p>
<dl class="section note"><dt>Note</dt><dd>This function may only be called from within<ul>
<li><a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a></li>
<li><a class="el" href="group__network__formation.html#gaf73a2682fa453a77a9aa2bc8df13dde9" title="Reports that a network was found and gives the network parameters used for deciding which network to ...">emberNetworkFoundHandler()</a></li>
<li>::emIncomingRouteRecord()</li>
<li>::emberMacPassthroughMessageHandler()</li>
<li><a class="el" href="group__znet__bootload.html#gae4bfb983c9c94ac2385c28367e627098" title="A callback invoked by the EmberZNet stack when a bootload message is received. If the application inc...">emberIncomingBootloadMessageHandler()</a></li>
</ul>
When this function is called from within one of these handler functions, the link quality reported corresponds to the header being processed in that hander function. If this function is called outside of these handler functions, the link quality reported will correspond to a message that was processed earlier.</dd></dl>
<p>This function is not available from within <a class="el" href="group__child.html#ga72a0892deafbaf87394c27c070be7341" title="Called to allow the application to send a message in response to a poll from a child. ">emberPollHandler()</a> or <a class="el" href="group__child.html#ga3e680431f942bc2fd1103f1da8671282">emberPollCompleteHandler()</a>. The link quality information of interest during the <a class="el" href="group__child.html#ga72a0892deafbaf87394c27c070be7341" title="Called to allow the application to send a message in response to a poll from a child. ">emberPollHandler()</a> is from the data request packet itself. This message must be handled quickly due to strict 15.4 timing requirements, and the link quality information is not recorded by the stack. The link quality information of interest during the <a class="el" href="group__child.html#ga3e680431f942bc2fd1103f1da8671282">emberPollCompleteHandler()</a> is from the ACK to the data request packet. The ACK is handled by the hardware and the link quality information does not make it up to the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastHopLqi</td><td>The link quality for the last incoming message processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function always returns <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a>. It is not necessary to check this return value. </dd></dl>

</div>
</div>
<a id="ga7ffe11b42f9e9753e261ff6e68201c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ffe11b42f9e9753e261ff6e68201c3f">&#9670;&nbsp;</a></span>emberGetLastHopRssi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberGetLastHopRssi </td>
          <td>(</td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>lastHopRssi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the receive signal strength indication (RSSI) for the current message. </p>
<p>After a successful call to this function, the quantity referenced by lastHopRssi will contain the energy level (in units of dBm) observed during the last packet received. </p><dl class="section note"><dt>Note</dt><dd>This function may only be called from within:<ul>
<li><a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a></li>
<li><a class="el" href="group__network__formation.html#gaf73a2682fa453a77a9aa2bc8df13dde9" title="Reports that a network was found and gives the network parameters used for deciding which network to ...">emberNetworkFoundHandler()</a></li>
<li>::emIncomingRouteRecord()</li>
<li>::emberMacPassthroughMessageHandler()</li>
<li><a class="el" href="group__znet__bootload.html#gae4bfb983c9c94ac2385c28367e627098" title="A callback invoked by the EmberZNet stack when a bootload message is received. If the application inc...">emberIncomingBootloadMessageHandler()</a></li>
</ul>
When this function is called from within one of these handler functions, the RSSI reported corresponds to the header being processed in that handler function. If this function is called outside of these handler functions, the RSSI reported will correspond to a message that was processed earlier.</dd></dl>
<p>This function is not available from within <a class="el" href="group__child.html#ga72a0892deafbaf87394c27c070be7341" title="Called to allow the application to send a message in response to a poll from a child. ">emberPollHandler()</a> or <a class="el" href="group__child.html#ga3e680431f942bc2fd1103f1da8671282">emberPollCompleteHandler()</a>. The RSSI information of interest during the <a class="el" href="group__child.html#ga72a0892deafbaf87394c27c070be7341" title="Called to allow the application to send a message in response to a poll from a child. ">emberPollHandler()</a> is from the data request packet itself. This message must be handled quickly due to strict 15.4 timing requirements, and the RSSI information is not recorded by the stack. The RSSI information of interest during the <a class="el" href="group__child.html#ga3e680431f942bc2fd1103f1da8671282">emberPollCompleteHandler()</a> is from the ACK to the data request packet. The ACK is handled by the hardware and the RSSI information does not make it up to the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastHopRssi</td><td>The RSSI for the last incoming message processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function always returns <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a>. It is not necessary to check this return value. </dd></dl>

</div>
</div>
<a id="ga58ba9c0e0cfb5f98269b319a14d9fb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58ba9c0e0cfb5f98269b319a14d9fb8f">&#9670;&nbsp;</a></span>emberGetLastHopTimestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberGetLastHopTimestamp </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>lastHopTimestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the receive timestamp (value of the MAC timer; ticks since up) of the moment when the Start Frame Delimiter (SFD) was received for the current message. </p>
<p>Note: This API is mainly intended for use on EFR devices.</p>
<p>RAIL timers tick every microsecond. ::RAIL_GetTime can provide the value of the current RAIL timebase (this wraps after ~4095 seconds.)</p>
<p>The timestamp provided by this API is a 24-bit value passed up from the PHY to the MAC layer, with a range of ~16.8 seconds. So, to calculate relative time using this timestamp, make sure to mask off the lower 24 bits provided by ::Rail_GetTime.</p>
<p>(On EM3xx devices, the hardware MAC timer is 20 bits and ticks roughly every microsecond for a range of around 1 second. Dumbo ticks every 2us while other platforms tick at 0.5us rate. Make sure to adjust the relative timestamp value accordingly.)</p>
<p>After a successful call to this function, the quantity referenced by lastHopTimestamp will contain the value of the MAC timer observed during the last packet received. </p><dl class="section note"><dt>Note</dt><dd>This function may only be called from within:<ul>
<li><a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a></li>
<li><a class="el" href="group__network__formation.html#gaf73a2682fa453a77a9aa2bc8df13dde9" title="Reports that a network was found and gives the network parameters used for deciding which network to ...">emberNetworkFoundHandler()</a></li>
<li>::emIncomingRouteRecord()</li>
<li>::emberMacPassthroughMessageHandler()</li>
<li><a class="el" href="group__znet__bootload.html#gae4bfb983c9c94ac2385c28367e627098" title="A callback invoked by the EmberZNet stack when a bootload message is received. If the application inc...">emberIncomingBootloadMessageHandler()</a></li>
</ul>
</dd></dl>
<p>When this function is called from within one of these handler functions, the timestamp reported corresponds to the header being processed in that handler function. If this function is called outside of these handler functions, the timestamp reported will correspond to a message that was processed earlier.</p>
<p>This function is not available from within <a class="el" href="group__child.html#ga72a0892deafbaf87394c27c070be7341" title="Called to allow the application to send a message in response to a poll from a child. ">emberPollHandler()</a> or <a class="el" href="group__child.html#ga3e680431f942bc2fd1103f1da8671282">emberPollCompleteHandler()</a>. The timestamp of interest during the <a class="el" href="group__child.html#ga72a0892deafbaf87394c27c070be7341" title="Called to allow the application to send a message in response to a poll from a child. ">emberPollHandler()</a> is from the data request packet itself. This message must be handled quickly due to strict 15.4 timing requirements, and the timestamp is not recorded by the stack. The timestamp of interest during the <a class="el" href="group__child.html#ga3e680431f942bc2fd1103f1da8671282">emberPollCompleteHandler()</a> is from the ACK to the data request packet. The ACK is handled by the hardware and the timestamp does not make it up to the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastHopTimestamp</td><td>The timestamp for the last incoming message processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function always returns <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a>. It is not necessary to check this return value. </dd></dl>

</div>
</div>
<a id="ga2e7aa86a2bd7358a6bb8183d0b708de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e7aa86a2bd7358a6bb8183d0b708de5">&#9670;&nbsp;</a></span>emberGetSender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EmberNodeId emberGetSender </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the node ID of the sender of the current incoming message. </p>
<dl class="section note"><dt>Note</dt><dd>This function can be called only from within <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The sender of the current incoming message. </dd></dl>

</div>
</div>
<a id="ga20a7c82bda7e5f6b51c12dff042574be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a7c82bda7e5f6b51c12dff042574be">&#9670;&nbsp;</a></span>emberGetSenderEui64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberGetSenderEui64 </td>
          <td>(</td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>senderEui64</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the EUI64 of the sender of the current incoming message if the sender chose to include this information in the message. The <a class="el" href="group__ember__types.html#ggad2a739a76b34fd352df6ef65ffaeaefea3241b6411d6c462067ca066de348680d">EMBER_APS_OPTION_SOURCE_EUI64</a> bit in the options field of the APS frame of the incoming message indicates that the EUI64 is present in the message. </p>
<dl class="section note"><dt>Note</dt><dd>This function can be called only from within <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">senderEui64</td><td>The EUI64 of the sender.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An EmberStatus value:<ul>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a> - senderEui64 has been set to the EUI64 of the sender of the current incoming message.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa7915b02c7053194c017871eb2d92abd8" title="The API call is not allowed given the current state of the stack. ">EMBER_INVALID_CALL</a> - Either:<ol type="1">
<li>This function was called outside of the context of the <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a> callback</li>
<li>It was called in the context of <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a> but the incoming message did not include the EUI64 of the sender. </li>
</ol>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="gac39dc6c9c29a0220e6e167696a1793db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac39dc6c9c29a0220e6e167696a1793db">&#9670;&nbsp;</a></span>emberGetSourceRouteTableEntry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberGetSourceRouteTableEntry </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>closerIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the source route table entry fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the source route table entry. </td></tr>
    <tr><td class="paramname">destination</td><td>The value of the destination field in that entry. </td></tr>
    <tr><td class="paramname">closerIndex</td><td>The value of the closer index entry field in that entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5e8809dad1b977b68d687618733c6240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e8809dad1b977b68d687618733c6240">&#9670;&nbsp;</a></span>emberGetSourceRouteTableFilledSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t emberGetSourceRouteTableFilledSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of filled entries in the source route table. </p>

</div>
</div>
<a id="ga0177609381d8d54a187bcf64b7d2e526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0177609381d8d54a187bcf64b7d2e526">&#9670;&nbsp;</a></span>emberGetSourceRouteTableTotalSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t emberGetSourceRouteTableTotalSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the source route table total size. </p>

</div>
</div>
<a id="ga634299324a0e05cfaf486ad3cf10c03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga634299324a0e05cfaf486ad3cf10c03f">&#9670;&nbsp;</a></span>emberIdConflictHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberIdConflictHandler </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>conflictingId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback invoked by the EmberZNet stack when an ID conflict is discovered, that is, two different nodes in the network were found to be using the same short ID. </p>
<p>The stack automatically removes the conflicting short ID from its internal tables (address, binding, route, neighbor, and child tables). The application should discontinue any other use of the ID. If the application includes this callback, it must define ::EMBER_APPLICATION_HAS_ID_CONFLICT_HANDLER in its configuration header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conflictingId</td><td>The short ID for which a conflict was detected. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa23d24be3473255fd3747de84161bc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa23d24be3473255fd3747de84161bc77">&#9670;&nbsp;</a></span>emberIncomingManyToOneRouteRequestHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberIncomingManyToOneRouteRequestHandler </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>longId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback indicating that a many-to-one route to the concentrator with the given short and long ID is available for use. </p>
<p>The application must define <code>EMBER_APPLICATION_HAS_INCOMING_MANY_TO_ONE_ROUTE_REQUEST_HANDLER</code> in its configuration header to use this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The short ID of the concentrator that initiated the many-to-one route request. </td></tr>
    <tr><td class="paramname">longId</td><td>The EUI64 of the concentrator. </td></tr>
    <tr><td class="paramname">cost</td><td>The path cost to the concentrator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c58e72b74314b649ad0662fa4f0afef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c58e72b74314b649ad0662fa4f0afef">&#9670;&nbsp;</a></span>emberIncomingMessageHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberIncomingMessageHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#ga42567c6bfd58e0161e3c660f99f455da">EmberIncomingMessageType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback invoked by the EmberZNet stack when a message is received. </p>
<p>The following functions may be called from <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a>:</p><ul>
<li><a class="el" href="group__message.html#gae677c27ad77d71c6c82f699a9c18895c" title="Gets the link quality from the node that last relayed the current message. ">emberGetLastHopLqi()</a></li>
<li><a class="el" href="group__message.html#ga7ffe11b42f9e9753e261ff6e68201c3f" title="Gets the receive signal strength indication (RSSI) for the current message. ">emberGetLastHopRssi()</a></li>
<li><a class="el" href="group__message.html#ga58ba9c0e0cfb5f98269b319a14d9fb8f" title="Gets the receive timestamp (value of the MAC timer; ticks since up) of the moment when the Start Fram...">emberGetLastHopTimestamp()</a></li>
<li><a class="el" href="group__message.html#ga2e7aa86a2bd7358a6bb8183d0b708de5" title="Returns the node ID of the sender of the current incoming message. ">emberGetSender()</a></li>
<li><a class="el" href="group__message.html#ga20a7c82bda7e5f6b51c12dff042574be" title="Returns the EUI64 of the sender of the current incoming message if the sender chose to include this i...">emberGetSenderEui64()</a></li>
<li><a class="el" href="group__binding__table.html#ga954e37e8b6448e1b12ef7e728cd524f9" title="Returns a binding index that matches the current incoming message, if known. ">emberGetBindingIndex()</a></li>
<li><a class="el" href="group__message.html#gaf3ccf3776c454626315702e379a127fe" title="Sends a reply for an application that has received a unicast message. ">emberSendReply()</a> (for incoming APS retried unicasts only)</li>
<li><a class="el" href="group__binding__table.html#gaafdc52dcfd29f7aa538f20cb0923d184" title="Creates a binding table entry for the sender of a message, which can be used to send messages to that...">emberSetReplyBinding()</a></li>
<li><a class="el" href="group__binding__table.html#gacd0cc26232141f20b9716b90824d27d7" title="Updates the routing information associated with a binding table entry for the sender of a message...">emberNoteSendersBinding()</a></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the incoming message. One of the following:<ul>
<li><a class="el" href="group__ember__types.html#gga42567c6bfd58e0161e3c660f99f455daaf3214756c91e9ffea1ddef162b1e4492">EMBER_INCOMING_UNICAST</a></li>
<li><a class="el" href="group__ember__types.html#gga42567c6bfd58e0161e3c660f99f455daa176b2160710212bf723ae2b1d0e6accb">EMBER_INCOMING_UNICAST_REPLY</a></li>
<li><a class="el" href="group__ember__types.html#gga42567c6bfd58e0161e3c660f99f455daa895c48152bcc53fee8e3b26330f8e230">EMBER_INCOMING_MULTICAST</a></li>
<li><a class="el" href="group__ember__types.html#gga42567c6bfd58e0161e3c660f99f455daa896babf17ef9a8665cbed65bb10db37c">EMBER_INCOMING_MULTICAST_LOOPBACK</a></li>
<li><a class="el" href="group__ember__types.html#gga42567c6bfd58e0161e3c660f99f455daa3e04b9ade85a7ba75edb3e6382b15339">EMBER_INCOMING_BROADCAST</a></li>
<li><a class="el" href="group__ember__types.html#gga42567c6bfd58e0161e3c660f99f455daa02e2ef8b6c99d5e6ff10951a77b71800">EMBER_INCOMING_BROADCAST_LOOPBACK</a></li>
</ul>
</td></tr>
    <tr><td class="paramname">apsFrame</td><td>The APS frame from the incoming message.</td></tr>
    <tr><td class="paramname">message</td><td>The message that was sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf68f4589eb595f761c32eb72da25aebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf68f4589eb595f761c32eb72da25aebf">&#9670;&nbsp;</a></span>emberIncomingNetworkStatusHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberIncomingNetworkStatusHandler </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>errorCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback invoked when a network status message is received that informs the application of the over-the-air error codes for the specific destination. </p>
<p>Note: Network analyzer may flag this message as "route error" which is the old name for the "network status" command.</p>
<p>This handler is a superset of emberIncomingRouteErrorHandler. The old API was only invoking the handler for a couple of the possible error codes and these were being translated into EmberStatus.</p>
<p>To make the API more generic and extensible in future, the new API emberIncomingNetworkStatusHandler simply copies the OTA error code as is. If the application includes this callback, it must define <code>EMBER_APPLICATION_HAS_INCOMING_NETWORK_STATUS_HANDLER</code> in its configuration header. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errorCode</td><td>uint8_t </td></tr>
    <tr><td class="paramname">target</td><td>The short ID of the remote node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0c5d86eaf819247d4f5ab6b66503ec92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c5d86eaf819247d4f5ab6b66503ec92">&#9670;&nbsp;</a></span>emberIncomingRouteErrorHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberIncomingRouteErrorHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td>
          <td class="paramname"><em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback invoked when a route error message is received. </p>
<p>A status of <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa3352d435568a839fbb0f81b3c1bdf382">EMBER_SOURCE_ROUTE_FAILURE</a> indicates that a source-routed unicast sent from this node encountered a broken link. Note that this case occurs only if this node is a concentrator using many-to-one routing for inbound messages and source-routing for outbound messages. The node prior to the broken link generated the route error message and returned it to us along the many-to-one route.</p>
<p>A status of <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa0dc7325db599b60f9b8dca2f317de6b4">EMBER_MANY_TO_ONE_ROUTE_FAILURE</a> also occurs only if the local device is a concentrator, and indicates that a unicast sent to the local device along a many-to-one route encountered a broken link. The node prior to the broken link generated the route error message and forwarded it to the local device via a randomly chosen neighbor, taking advantage of the many-to-one nature of the route.</p>
<p>A status of <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa36ea683588dbbacc6c6a69209a3ee85b" title="An indirect data message timed out before a poll requested it. ">EMBER_MAC_INDIRECT_TIMEOUT</a> indicates that a message sent to the target end device could not be delivered by the parent because the indirect transaction timer expired. Upon receipt of the route error, the stack sets the extended timeout for the target node in the address table, if present. It then calls this handler to indicate receipt of the error.</p>
<p>Note that if the original unicast data message is sent using the <a class="el" href="group__ember__types.html#ggad2a739a76b34fd352df6ef65ffaeaefeadf025c85318cf67805979223ef321091">EMBER_APS_OPTION_RETRY</a> option, a new route error message is generated for each failed retry. Therefore, it is not unusual to receive three route error messages in succession for a single failed retried APS unicast. On the other hand, it is also not guaranteed that any route error messages will be delivered successfully at all. The only sure way to detect a route failure is to use retried APS messages and to check the status of the <a class="el" href="group__message.html#gabf132904d585ce31f4697ed5904b31d4" title="A callback invoked by the stack when it has completed sending a message. ">emberMessageSentHandler()</a>.</p>
<p>If the application includes this callback, it must define <code>EMBER_APPLICATION_HAS_INCOMING_ROUTE_ERROR_HANDLER</code> in its configuration header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa3352d435568a839fbb0f81b3c1bdf382">EMBER_SOURCE_ROUTE_FAILURE</a>, <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa0dc7325db599b60f9b8dca2f317de6b4">EMBER_MANY_TO_ONE_ROUTE_FAILURE</a>, <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa36ea683588dbbacc6c6a69209a3ee85b" title="An indirect data message timed out before a poll requested it. ">EMBER_MAC_INDIRECT_TIMEOUT</a> </td></tr>
    <tr><td class="paramname">target</td><td>The short ID of the remote node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59f89cedc4b54536289ed478e747702b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59f89cedc4b54536289ed478e747702b">&#9670;&nbsp;</a></span>emberIncomingRouteRecordHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberIncomingRouteRecordHandler </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>sourceEui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>relayCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>relayListIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>DEPRECTAED emberOverrideIncomingRouteRecordHandler should be used Reports the arrival of a route record command frame to the application. </p>
<p>The route record command frame lists the short IDs of the relays that were used along the route from the source to us. This information is used by aggregators to be able to initiate source routed messages. The application must define <code>EMBER_APPLICATION_HAS_SOURCE_ROUTING</code> in its configuration header to use this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The id of the node that initiated the route record. </td></tr>
    <tr><td class="paramname">sourceEui</td><td>The EUI64 of the node that initiated the route record. </td></tr>
    <tr><td class="paramname">relayCount</td><td>The number of relays in the list. </td></tr>
    <tr><td class="paramname">header</td><td>The message buffer containing the route record frame. </td></tr>
    <tr><td class="paramname">relayListIndex</td><td>The starting index of the relay list. The relay closest to the source is listed first, and the relay closest to us is listed last. Short ids are stored low byte first. Be careful to use buffer-boundary-safe APIs to read the list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad236eb939089b00b925c320268d916c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad236eb939089b00b925c320268d916c2">&#9670;&nbsp;</a></span>emberMaximumApsPayloadLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t emberMaximumApsPayloadLength </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum size of the payload that the Application Support sub-layer will accept. </p>
<p>The size depends on the security level in use. The value is the same as that found in the node descriptor.</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum APS payload length. </dd></dl>

</div>
</div>
<a id="gabf132904d585ce31f4697ed5904b31d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf132904d585ce31f4697ed5904b31d4">&#9670;&nbsp;</a></span>emberMessageSentHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberMessageSentHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gab77dd07ca7af23a832974d3cc20c94f3">EmberOutgoingMessageType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>indexOrDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback invoked by the stack when it has completed sending a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of message sent.</td></tr>
    <tr><td class="paramname">indexOrDestination</td><td>The destination to which the message was sent. For direct unicasts, the destination to which the message was sent; for other unicasts, the address table or binding index to which the message was sent. The value is unspecified for multicasts and broadcasts.</td></tr>
    <tr><td class="paramname">apsFrame</td><td>The APS frame for the message.</td></tr>
    <tr><td class="paramname">message</td><td>The message that was sent.</td></tr>
    <tr><td class="paramname">status</td><td>An <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value of <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a> if an ACK was received from the destination or <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa4f464859c757a9baffcf4b7290a7bc8b" title="The APS layer attempted to send or deliver a message and failed. ">EMBER_DELIVERY_FAILED</a> if no ACK was received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c4d493c420d083aa739e1980ea0bc20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c4d493c420d083aa739e1980ea0bc20">&#9670;&nbsp;</a></span>emberOverrideAppendSourceRouteHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t emberOverrideAppendSourceRouteHandler </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>consumed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SoC only. The application can implement this callback to supply source routes to outgoing messages. </p>
<p>The application must define :EMBER_APPLICATION_HAS_OVERRIDE_SOURCE_ROUTING in its configuration header to use this. The application uses the supplied destination to look up a source route. If available, the application appends the source route to the supplied header using the proper frame format, as described in section 3.4.1.9 "Source Route Subframe Field" of the ZigBee specification. If a source route is appended, the stack takes care of setting the proper flag in the network frame control field. See app/util/source-route.c for a sample implementation.</p>
<p>If header is :EMBER_NULL_MESSAGE_BUFFER the only action is to return the size of the source route frame needed to the destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The network destination of the message. </td></tr>
    <tr><td class="paramname">*header</td><td>Pointer to the message buffer containing the partially complete packet header. The application appends the source route frame to this header. </td></tr>
    <tr><td class="paramname">consumed</td><td>if set to true stack would skip appending the existing source route entry from the table</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size in bytes of the source route frame, or zero if there is not one available. </dd></dl>

</div>
</div>
<a id="ga2d8df86b0964cb9577b1c7705a1ad16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d8df86b0964cb9577b1c7705a1ad16e">&#9670;&nbsp;</a></span>emberOverrideIncomingRouteRecordHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberOverrideIncomingRouteRecordHandler </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>sourceEui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>relayCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>relayListIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>consumed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SoC only. It reports the arrival of a route record command frame to the application. </p>
<p>The route record command frame lists the short IDs of the relays that were used along the route from the source to us. This information is used by aggregators to be able to initiate source routed messages. The application must define <code>EMBER_APPLICATION_HAS_OVERRIDE_SOURCE_ROUTING</code> in its configuration header to use this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The id of the node that initiated the route record. </td></tr>
    <tr><td class="paramname">sourceEui</td><td>The EUI64 of the node that initiated the route record. </td></tr>
    <tr><td class="paramname">relayCount</td><td>The number of relays in the list. </td></tr>
    <tr><td class="paramname">header</td><td>The message buffer containing the route record frame. </td></tr>
    <tr><td class="paramname">relayListIndex</td><td>The starting index of the relay list. The relay closest to the source is listed first, and the relay closest to us is listed last. Short ids are stored low byte first. Be careful to use buffer-boundary-safe APIs to read the list. </td></tr>
    <tr><td class="paramname">consumed</td><td>if set to true stack won't process the Incoming route record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa955c8bf92dde29132059a635c673ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa955c8bf92dde29132059a635c673ba9">&#9670;&nbsp;</a></span>emberPacketHandoffIncoming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a> emberPacketHandoffIncoming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>packetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intercepts an incoming packet from the stack and hands off to a plugin for further processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>The type of packet and the target stack layer. See <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a>. </td></tr>
    <tr><td class="paramname">packetBuffer</td><td>The <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> containing the packet.  index The starting index of the relevant packet data. The plugin\ will receive a flat copy of the packet starting from this index. </td></tr>
    <tr><td class="paramname">data</td><td>Auxiliary data pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7" title="indication of the action taken on a packet ">EmberPacketAction</a> </dd></dl>

</div>
</div>
<a id="ga233b61c0cc1c3f2df3792934971c3b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga233b61c0cc1c3f2df3792934971c3b43">&#9670;&nbsp;</a></span>emberPacketHandoffOutgoing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7">EmberPacketAction</a> emberPacketHandoffOutgoing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d">EmberZigbeePacketType</a>&#160;</td>
          <td class="paramname"><em>packetType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>packetBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intercepts an outgoing packet from the stack and hands off to a plugin for further processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packetType</td><td>The type of packet and the source stack layer. See <a class="el" href="group__ember__types.html#gabc84c30424c97df09e02b15c5648f73d" title="A type of packet received by the stack. ">EmberZigbeePacketType</a>. </td></tr>
    <tr><td class="paramname">packetBuffer</td><td>The <a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> containing the packet. </td></tr>
    <tr><td class="paramname">index</td><td>The starting index of the relevant packet data. The plugin\ will receive a flat copy of the packet starting from this index. </td></tr>
    <tr><td class="paramname">data</td><td>Auxiliary data pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>See <a class="el" href="group__ember__types.html#gae782db224b980ef5687a8fae8ec2b6d7" title="indication of the action taken on a packet ">EmberPacketAction</a> </dd></dl>

</div>
</div>
<a id="ga31ad1d4578175d4c1a45469730f55b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31ad1d4578175d4c1a45469730f55b88">&#9670;&nbsp;</a></span>emberPendingAckedMessages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool emberPendingAckedMessages </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether there are pending messages in the APS retry queue. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there is at least a pending message belonging to the current network in the APS retry queue, false otherwise. </dd></dl>

</div>
</div>
<a id="ga603964bbdf9e862f4c5756cc1ce7f81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga603964bbdf9e862f4c5756cc1ce7f81f">&#9670;&nbsp;</a></span>emberProxyBroadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberProxyBroadcast </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Proxies a broadcast message for another node. </p>
<p>The message will be delivered to all nodes within <code>radius</code> hops of the local node. A radius of zero is converted to <a class="el" href="group__configuration.html#ga9d67a6dcfd1a9aa12801b49c2e6b8ac1" title="The maximum number of hops for a message. ">EMBER_MAX_HOPS</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source from which to send the broadcast.</td></tr>
    <tr><td class="paramname">destination</td><td>The destination to which to send the broadcast. This must be one of three ZigBee broadcast addresses.</td></tr>
    <tr><td class="paramname">sequence</td><td>The NWK sequence number for the message.</td></tr>
    <tr><td class="paramname">apsFrame</td><td>The APS frame data to be included in the message.</td></tr>
    <tr><td class="paramname">radius</td><td>The maximum number of hops the message will be relayed.</td></tr>
    <tr><td class="paramname">message</td><td>The actual message to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value. </dd></dl>

</div>
</div>
<a id="gae60996531d168a5f928ec1117adc29c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae60996531d168a5f928ec1117adc29c3">&#9670;&nbsp;</a></span>emberProxyNextBroadcastFromLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberProxyNextBroadcastFromLong </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>euiSource</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Proxies a broadcast message for another node. </p>
<p>The function is used in conjunction with emberProxyBroadcast, which proxies a message from a short ID. This function is used where a long source is also specified in the NWK frame control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">euiSource</td><td>The long source from which to send the broadcast.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value. </dd></dl>

</div>
</div>
<a id="ga6fc8941e6916a147add02b6403e3a27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6fc8941e6916a147add02b6403e3a27c">&#9670;&nbsp;</a></span>emberSendBroadcast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberSendBroadcast </td>
          <td>(</td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a broadcast message as per the ZigBee specification. </p>
<p>The message will be delivered to all nodes within <code>radius</code> hops of the sender. A radius of zero is converted to <a class="el" href="group__configuration.html#ga9d67a6dcfd1a9aa12801b49c2e6b8ac1" title="The maximum number of hops for a message. ">EMBER_MAX_HOPS</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The destination to which to send the broadcast. This must be one of three ZigBee broadcast addresses.</td></tr>
    <tr><td class="paramname">apsFrame</td><td>The APS frame data to be included in the message.</td></tr>
    <tr><td class="paramname">radius</td><td>The maximum number of hops the message will be relayed.</td></tr>
    <tr><td class="paramname">message</td><td>The actual message to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value. </dd></dl>

</div>
</div>
<a id="gacf9bc77b5a8edcb3b1d566191417f321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf9bc77b5a8edcb3b1d566191417f321">&#9670;&nbsp;</a></span>emberSendManyToOneRouteRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberSendManyToOneRouteRequest </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>concentratorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a route request packet that creates routes from every node in the network back to this node. </p>
<p>This function should be called by an application that wishes to communicate with many nodes, for example, a gateway, central monitor, or controller. A device using this function was referred to as an "aggregator" in EmberZNet 2.x and earlier, and is referred to as a "concentrator" in the ZigBee specification and EmberZNet 3.</p>
<p>This function enables large scale networks, because the other devices do not have to individually perform bandwidth-intensive route discoveries. Instead, when a remote node sends an APS unicast to a concentrator, its network layer automatically delivers a special route record packet first, which lists the network IDs of all intermediate relays. The concentrator can then use source routing to send outbound APS unicasts. (A source routed message is one in which the entire route is listed in the network layer header.) This allows the concentrator to communicate with thousands of devices without requiring large route tables on neighboring nodes.</p>
<p>This function is only available in ZigBee Pro (stack profile 2), and cannot be called on end devices. Any router can be a concentrator (not just the coordinator), and there can be multiple concentrators on a network.</p>
<p>Note that a concentrator does not automatically obtain routes to all network nodes after calling this function. Remote applications must first initiate an inbound APS unicast.</p>
<p>Many-to-one routes are not repaired automatically. Instead, the concentrator application must call this function to rediscover the routes as necessary, for example, upon failure of a retried APS message. This is necessary because there is no scalable one-size-fits-all route repair strategy. A common and recommended strategy is for the concentrator application to refresh the routes by calling this function periodically.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">concentratorType</td><td>Must be either <a class="el" href="group__ember__types.html#ga2cbe0323a8a4e42d84d980cd2e0538b4">EMBER_HIGH_RAM_CONCENTRATOR</a> or <a class="el" href="group__ember__types.html#ga8ae0c686fc87c8fe8ffc2a80beb4e85b">EMBER_LOW_RAM_CONCENTRATOR</a>. The former is used when the caller has enough memory to store source routes for the whole network. In that case, remote nodes stop sending route records once the concentrator has successfully received one. The latter is used when the concentrator has insufficient RAM to store all outbound source routes. In that case, route records are sent to the concentrator prior to every inbound APS unicast.</td></tr>
    <tr><td class="paramname">radius</td><td>The maximum number of hops the route request will be relayed. A radius of zero is converted to <a class="el" href="group__configuration.html#ga9d67a6dcfd1a9aa12801b49c2e6b8ac1" title="The maximum number of hops for a message. ">EMBER_MAX_HOPS</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a> if the route request was successfully submitted to the transmit queue, and <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaacce86e680443b7162cf8d0fffd4c990d" title="The generic &quot;fatal error&quot; message. ">EMBER_ERR_FATAL</a> otherwise. </dd></dl>

</div>
</div>
<a id="gafa9cc0f9ebba174ce6b94971194a39ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa9cc0f9ebba174ce6b94971194a39ef">&#9670;&nbsp;</a></span>emberSendMulticast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberSendMulticast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nonmemberRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a multicast message to all endpoints that share a specific multicast ID and are within a specified number of hops of the sender. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apsFrame</td><td>The APS frame for the message. The multicast will be sent to the groupId in this frame.</td></tr>
    <tr><td class="paramname">radius</td><td>The message will be delivered to all nodes within this number of hops of the sender. A value of zero is converted to EMBER_MAX_HOPS.</td></tr>
    <tr><td class="paramname">nonmemberRadius</td><td>The number of hops that the message will be forwarded by devices that are not members of the group. A value of 7 or greater is treated as infinite.</td></tr>
    <tr><td class="paramname">message</td><td>A message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value. For any result other than <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a>, the message will not be sent.<br />
<br />
<ul>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a> - The message has been submitted for transmission.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaab07ea3e7dfac0064e9f435180a84c412" title="An invalid binding table index was given to a function. ">EMBER_INVALID_BINDING_INDEX</a> - The <code>bindingTableIndex</code> refers to a non-multicast binding.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaaf791f89ba5267e4ee08a9f08164647ac" title="The network is not operating. ">EMBER_NETWORK_DOWN</a> - The node is not part of a network.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaae02138a18a70b5d23cccce1461d13b2d" title="The message to be transmitted is too big to fit into a single over-the-air packet. ">EMBER_MESSAGE_TOO_LONG</a> - The message is too large to fit in a MAC layer frame.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa6660189b06bcbedef111e19ee585b741" title="There are no more buffers. ">EMBER_NO_BUFFERS</a> - The free packet buffer pool is empty.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa1b3f3a8ab9cd651aa267185f8460aa90" title="A message cannot be sent because the network is currently overloaded. ">EMBER_NETWORK_BUSY</a> - Insufficient resources available in Network or MAC layers to send message. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga821bd4cd82c2316a1d1cfaaa60d643c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga821bd4cd82c2316a1d1cfaaa60d643c5">&#9670;&nbsp;</a></span>emberSendMulticastWithAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberSendMulticastWithAlias </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>nonmemberRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a multicast message for an alias source to all endpoints that share a specific multicast ID and are within a specified number of hops of the sender. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">apsFrame</td><td>The APS frame for the message. The multicast will be sent to the groupId in this frame.</td></tr>
    <tr><td class="paramname">radius</td><td>The message will be delivered to all nodes within this number of hops of the sender. A value of zero is converted to EMBER_MAX_HOPS.</td></tr>
    <tr><td class="paramname">nonmemberRadius</td><td>The number of hops that the message will be forwarded by devices that are not members of the group. A value of 7 or greater is treated as infinite.</td></tr>
    <tr><td class="paramname">message</td><td>A message.</td></tr>
    <tr><td class="paramname">alias</td><td>The alias from which to send the multicast.</td></tr>
    <tr><td class="paramname">sequence</td><td>The NWK sequence number for the message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value. For any result other than <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a>, the message will not be sent.<br />
<br />
<ul>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a> - The message has been submitted for transmission.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaab07ea3e7dfac0064e9f435180a84c412" title="An invalid binding table index was given to a function. ">EMBER_INVALID_BINDING_INDEX</a> - The <code>bindingTableIndex</code> refers to a non-multicast binding.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaaf791f89ba5267e4ee08a9f08164647ac" title="The network is not operating. ">EMBER_NETWORK_DOWN</a> - The node is not part of a network.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaae02138a18a70b5d23cccce1461d13b2d" title="The message to be transmitted is too big to fit into a single over-the-air packet. ">EMBER_MESSAGE_TOO_LONG</a> - The message is too large to fit in a MAC layer frame.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa6660189b06bcbedef111e19ee585b741" title="There are no more buffers. ">EMBER_NO_BUFFERS</a> - The free packet buffer pool is empty.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa1b3f3a8ab9cd651aa267185f8460aa90" title="A message cannot be sent because the network is currently overloaded. ">EMBER_NETWORK_BUSY</a> - Insufficient resources available in Network or MAC layers to send message. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf3ccf3776c454626315702e379a127fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3ccf3776c454626315702e379a127fe">&#9670;&nbsp;</a></span>emberSendReply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberSendReply </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>clusterId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>reply</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a reply for an application that has received a unicast message. </p>
<p>The reply will be included with the ACK that the stack automatically sends back. </p><dl class="section note"><dt>Note</dt><dd>This function may be called only from within <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clusterId</td><td>The cluster ID to use for the reply.</td></tr>
    <tr><td class="paramname">reply</td><td>A reply message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value. For any result other than <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a>, the message will not be sent.<ul>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a> - The message has been submitted for transmission.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa7915b02c7053194c017871eb2d92abd8" title="The API call is not allowed given the current state of the stack. ">EMBER_INVALID_CALL</a> - Either:<ol type="1">
<li>This function was called outside of the context of the <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a> callback</li>
<li>It was called in the context of <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a> but the incoming message was not a unicast</li>
<li>It was called more than once in the context of <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a>.</li>
</ol>
</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa1b3f3a8ab9cd651aa267185f8460aa90" title="A message cannot be sent because the network is currently overloaded. ">EMBER_NETWORK_BUSY</a> - Either:<ol type="1">
<li>No route available.</li>
<li>Insufficient resources available in Network or MAC layers to send message. </li>
</ol>
</li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga436916a25553e6e3ca6267161ed9955c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga436916a25553e6e3ca6267161ed9955c">&#9670;&nbsp;</a></span>emberSendUnicast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberSendUnicast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__ember__types.html#gab77dd07ca7af23a832974d3cc20c94f3">EmberOutgoingMessageType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>indexOrDestination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structEmberApsFrame.html">EmberApsFrame</a> *&#160;</td>
          <td class="paramname"><em>apsFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a unicast message per the Zigbee specification. </p>
<p>The message will arrive at its destination only if there is a known route to the destination node. Setting the ::ENABLE_ROUTE_DISCOVERY option will cause a route to be discovered if none is known. Setting the ::FORCE_ROUTE_DISCOVERY option will force route discovery. Routes to end-device children of the local node are always known.</p>
<p>Setting the <code>APS_RETRY</code> option will cause the message to be retransmitted until either a matching acknowledgment is received or three transmissions have been made.</p>
<dl class="section note"><dt>Note</dt><dd>Using the ::FORCE_ROUTE_DISCOVERY option will cause the first transmission to be consumed by a route request as part of discovery, so the application payload of this packet will not reach its destination on the first attempt. For the packet to reach its destination, the APS_RETRY option must be set so that another attempt is made to transmit the message with its application payload after the route has been constructed.</dd></dl>
<p>Setting the ::DESTINATION_EUI64 option will cause the long ID of the destination to be included in the network header. This is the only way to absolutely guarantee that the message is delivered to the correct node. Without it, a message may on occasion be delivered to the wrong destination in the event of an ID conflict that has not yet been detected and resolved by the network layer.</p>
<dl class="section note"><dt>Note</dt><dd>When sending fragmented messages, the stack will only assign a new APS sequence number for the first fragment of the message (i.e., <a class="el" href="group__ember__types.html#ggad2a739a76b34fd352df6ef65ffaeaefea103e636181b61ab458da01a6620c3677">EMBER_APS_OPTION_FRAGMENT</a> is set and the low-order byte of the groupId field in the APS frame is zero). For all subsequent fragments of the same message, the application must set the sequence number field in the APS frame to the sequence number assigned by the stack to the first fragment.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Specifies the outgoing message type. Must be one of <a class="el" href="group__ember__types.html#ggab77dd07ca7af23a832974d3cc20c94f3a9bd7967c8235081475a36b4a60a18a89">EMBER_OUTGOING_DIRECT</a>, <a class="el" href="group__ember__types.html#ggab77dd07ca7af23a832974d3cc20c94f3a59161f2c9f34e259c6bacccfc1ff501a">EMBER_OUTGOING_VIA_ADDRESS_TABLE</a>, or <a class="el" href="group__ember__types.html#ggab77dd07ca7af23a832974d3cc20c94f3accd0c60ca71d623a164a538224c9b86f">EMBER_OUTGOING_VIA_BINDING</a>.</td></tr>
    <tr><td class="paramname">indexOrDestination</td><td>Depending on the type of addressing used, this is either the EmberNodeId of the destination, an index into the address table, or an index into the binding table.</td></tr>
    <tr><td class="paramname">apsFrame</td><td>The APS frame which is to be added to the message.</td></tr>
    <tr><td class="paramname">message</td><td>Contents of the message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value. For any result other than <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a>, the message will not be sent.<ul>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a> - The message has been submitted for transmission.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaab07ea3e7dfac0064e9f435180a84c412" title="An invalid binding table index was given to a function. ">EMBER_INVALID_BINDING_INDEX</a> - The <code>bindingTableIndex</code> refers to a non-unicast binding.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaaf791f89ba5267e4ee08a9f08164647ac" title="The network is not operating. ">EMBER_NETWORK_DOWN</a> - The node is not part of a network.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaae02138a18a70b5d23cccce1461d13b2d" title="The message to be transmitted is too big to fit into a single over-the-air packet. ">EMBER_MESSAGE_TOO_LONG</a> - The message is too large to fit in a MAC layer frame.</li>
<li><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa1e5cd8da59d32c85ab6af8e165c13db5" title="The maximum number of in-flight messages = i.e., EMBER_APS_UNICAST_MESSAGE_COUNT, has been reached...">EMBER_MAX_MESSAGE_LIMIT_REACHED</a> - The <a class="el" href="group__configuration.html#ga33eb5f272e018b0abc2e34534392b49b" title="The maximum number of APS retried messages that the stack can be transmitting at any time...">EMBER_APS_UNICAST_MESSAGE_COUNT</a> limit has been reached. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga900156d5b8bf998d2e33d9ee9e53d9ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga900156d5b8bf998d2e33d9ee9e53d9ef">&#9670;&nbsp;</a></span>emberSetAddressTableRemoteEui64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> emberSetAddressTableRemoteEui64 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addressTableIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>eui64</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the EUI64 of an address table entry. </p>
<p>This function will also check other address table entries, the child table and the neighbor table to see if the node ID for the given EUI64 is already known. If known, this function will also set the node ID. If not known, it will set the node ID to <a class="el" href="group__ember__types.html#ga7b441affd0a4ed88b5bf1fb21340a353" title="A distinguished network ID that will never be assigned to any node. This value is used when getting t...">EMBER_UNKNOWN_NODE_ID</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressTableIndex</td><td>The index of an address table entry.</td></tr>
    <tr><td class="paramname">eui64</td><td>The EUI64 to use for the address table entry.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa84c33d706af830b39e7681e4650de33a" title="The generic &quot;no error&quot; message. ">EMBER_SUCCESS</a> if the EUI64 was successfully set, and <a class="el" href="group__status__codes.html#ggabdc825a7bb1ce986862f1566accee9aaa493864c441e2e14a16513be3b8178723" title="The application is trying to overwrite an address table entry that is in use. ">EMBER_ADDRESS_TABLE_ENTRY_IS_ACTIVE</a> otherwise. </dd></dl>

</div>
</div>
<a id="gaf071c9ab13d6ecb2f1a7cc69cf3c0b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf071c9ab13d6ecb2f1a7cc69cf3c0b8d">&#9670;&nbsp;</a></span>emberSetAddressTableRemoteNodeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberSetAddressTableRemoteNodeId </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>addressTableIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EmberNodeId&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the short ID of an address table entry. </p>
<p>Usually the application will not need to set the short ID in the address table. Once the remote EUI64 is set, the stack is capable of figuring out the short ID on its own. However, in cases where the application does set the short ID, the application must set the remote EUI64 prior to setting the short ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addressTableIndex</td><td>The index of an address table entry.</td></tr>
    <tr><td class="paramname">id</td><td>The short ID corresponding to the remote node whose EUI64 is stored in the address table at the given index or <a class="el" href="group__ember__types.html#gaf4a9110ca9be0fb3639dbacedd53f276" title="A distinguished network ID that will never be assigned to any node. ">EMBER_TABLE_ENTRY_UNUSED_NODE_ID</a> which indicates that the entry stored in the address table at the given index is not in use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1e8ce45e2b325443be7f61bd34d44d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e8ce45e2b325443be7f61bd34d44d1c">&#9670;&nbsp;</a></span>emberSetExtendedTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberSetExtendedTimeout </td>
          <td>(</td>
          <td class="paramtype">EmberEUI64&#160;</td>
          <td class="paramname"><em>remoteEui64</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>extendedTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tells the stack whether or not the normal interval between retransmissions of a retried unicast message should be increased by <a class="el" href="group__configuration.html#gade661ac2bfb536d5fef03b195f927d35" title="The maximum amount of time (in milliseconds) that the MAC will hold a message for indirect transmissi...">EMBER_INDIRECT_TRANSMISSION_TIMEOUT</a>. </p>
<p>The interval needs to be increased when sending to a sleepy node so that the message is not retransmitted until the destination has had time to wake up and poll its parent. The stack will automatically extend the timeout:</p><ul>
<li>For our own sleepy children.</li>
<li>When an address response is received from a parent on behalf of its child.</li>
<li>When an indirect transaction expiry route error is received.</li>
<li>When an end device announcement is received from a sleepy node.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">remoteEui64</td><td>The address of the node for which the timeout is to be set.</td></tr>
    <tr><td class="paramname">extendedTimeout</td><td>True if the retry interval should be increased by <a class="el" href="group__configuration.html#gade661ac2bfb536d5fef03b195f927d35" title="The maximum amount of time (in milliseconds) that the MAC will hold a message for indirect transmissi...">EMBER_INDIRECT_TRANSMISSION_TIMEOUT</a>. False if the normal retry interval should be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe39e1968082581a1d24e2b9a495301c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe39e1968082581a1d24e2b9a495301c">&#9670;&nbsp;</a></span>emberSetReplyFragmentData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emberSetReplyFragmentData </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>fragmentData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the fragment data to be used when sending a reply to a unicast message. </p>
<dl class="section note"><dt>Note</dt><dd>This function may be called only from within <a class="el" href="group__message.html#ga9c58e72b74314b649ad0662fa4f0afef" title="A callback invoked by the EmberZNet stack when a message is received. ">emberIncomingMessageHandler()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fragmentData</td><td>The low byte is the block number of the reply. The high byte is the ACK bitfield of the reply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a9b486b6a20e47b47f52e2c6fc25b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a9b486b6a20e47b47f52e2c6fc25b96">&#9670;&nbsp;</a></span>makeInterPanMessage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a> makeInterPanMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInterPanHeader.html">InterPanHeader</a> *&#160;</td>
          <td class="paramname"><em>headerData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>payload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an interpan message suitable for passing to emberSendRawMessage(). </p>

</div>
</div>
<a id="ga1a6954c4aff2ac4ab7ff230be3450022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a6954c4aff2ac4ab7ff230be3450022">&#9670;&nbsp;</a></span>makeInterPanMessage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t makeInterPanMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structInterPanHeader.html">InterPanHeader</a> *&#160;</td>
          <td class="paramname"><em>headerData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>maxLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>payloadLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an interpan message. message needs to have enough space for the message contents. Upon return, the return value will be the length of the message, or 0 in case of error. </p>

</div>
</div>
<a id="gab3f3ef1af2046407929cf36d51735c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3f3ef1af2046407929cf36d51735c7d">&#9670;&nbsp;</a></span>parseInterPanMessage() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t parseInterPanMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__packet__buffer.html#ga6827b9c546e10d127a76d5e68ca14122">EmberMessageBuffer</a>&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInterPanHeader.html">InterPanHeader</a> *&#160;</td>
          <td class="paramname"><em>headerData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is meant to be called on the message and offset values passed to emberMacPassthroughMessageHandler(...). The header is parsed and the various fields are written to the <a class="el" href="structInterPanHeader.html" title="A struct for keeping track of all of the header info. ">InterPanHeader</a>. The returned value is the offset of the payload in the message, or 0 if the message is not a correctly formed AMI interPAN message. </p>

</div>
</div>
<a id="gac55d8837933a52ab5d759b2718cbfa96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac55d8837933a52ab5d759b2718cbfa96">&#9670;&nbsp;</a></span>parseInterPanMessage() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t parseInterPanMessage </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>messageLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structInterPanHeader.html">InterPanHeader</a> *&#160;</td>
          <td class="paramname"><em>headerData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is meant to be called on the message passed to emberMacPassthroughMessageHandler(...). The header is parsed and the various fields are written to the <a class="el" href="structInterPanHeader.html" title="A struct for keeping track of all of the header info. ">InterPanHeader</a>. The returned value is the offset of the payload in the message, or 0 if the message is not a correctly formed AMI interPAN message. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga740628a12e72bce15769344afc3e414f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga740628a12e72bce15769344afc3e414f">&#9670;&nbsp;</a></span>emberApsAckTimeoutMs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t emberApsAckTimeoutMs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The APS ACK timeout value. The stack waits this amount of time between resends of APS retried messages. The default value is: </p>
<pre>
  ((EMBER_APSC_MAX_ACK_WAIT_HOPS_MULTIPLIER_MS
    * EMBER_MAX_HOPS)
   + EMBER_APSC_MAX_ACK_WAIT_TERMINAL_SECURITY_MS)
</pre> 
</div>
</div>
<a id="gac00eb4bd42a4c0c5e8ab0cfcf7ce3e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac00eb4bd42a4c0c5e8ab0cfcf7ce3e19">&#9670;&nbsp;</a></span>emberMulticastTable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structEmberMulticastTableEntry.html">EmberMulticastTableEntry</a>* emberMulticastTable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The multicast table. </p>
<p>Each entry contains a multicast ID and an endpoint, indicating that the endpoint is a member of the multicast group. Only devices with an endpoint in a multicast group will receive messages sent to that multicast group.</p>
<p>Entries with with an endpoint of 0 are ignored (the ZDO does not a member of any multicast groups). All endpoints are initialized to 0 on startup. </p>

</div>
</div>
<a id="gab6e3b5c2ede4f56822e2dfac622fc094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6e3b5c2ede4f56822e2dfac622fc094">&#9670;&nbsp;</a></span>emberMulticastTableSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t emberMulticastTableSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of entries in the multicast table. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 10 2020 11:32:14 for EmberZNet API Reference: For the EM35x SoC Platform by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
