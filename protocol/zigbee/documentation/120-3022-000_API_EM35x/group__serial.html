<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EmberZNet API Reference: For the EM35x SoC Platform: Serial UART Communication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EmberZNet API Reference: For the EM35x SoC Platform
   &#160;<span id="projectnumber">EmberZNet 6.8.1.0</span>
   </div>
   <div id="projectbrief">For the EFR32 and EM3xx Platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__serial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Serial UART Communication<div class="ingroups"><a class="el" href="group__hal.html">Hardware Abstraction Layer (HAL) API Reference</a> &raquo; <a class="el" href="group__peripherals.html">Sample APIs for Peripheral Access</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This API contains the HAL interfaces that applications must implement for the high-level serial code.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga79e9d2305515318a1ae0ab5aaffd6fcb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga79e9d2305515318a1ae0ab5aaffd6fcb">SerialBaudRate</a> { <br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd">DEFINE_BAUD</a> =(300) = 0
<br />
 }<tr class="memdesc:ga79e9d2305515318a1ae0ab5aaffd6fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign numerical values for variables that hold Baud Rate parameters.  <a href="group__serial.html#ga79e9d2305515318a1ae0ab5aaffd6fcb">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga79e9d2305515318a1ae0ab5aaffd6fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c48912c12fd98a4f4faffbc7f20a9f6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga2c48912c12fd98a4f4faffbc7f20a9f6">SerialParity</a> { <br />
&#160;&#160;<a class="el" href="group__serial.html#gga2c48912c12fd98a4f4faffbc7f20a9f6a9569a17323e2dd2a5bb1db6a96621815">DEFINE_PARITY</a> =(NONE) = 0U, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga2c48912c12fd98a4f4faffbc7f20a9f6a9569a17323e2dd2a5bb1db6a96621815">DEFINE_PARITY</a> =(NONE) = 0U, 
<br />
&#160;&#160;<a class="el" href="group__serial.html#gga2c48912c12fd98a4f4faffbc7f20a9f6a9569a17323e2dd2a5bb1db6a96621815">DEFINE_PARITY</a> =(NONE) = 0U
<br />
 }<tr class="memdesc:ga2c48912c12fd98a4f4faffbc7f20a9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">CORTEXM3_EFM32_MICRO.  <a href="group__serial.html#ga2c48912c12fd98a4f4faffbc7f20a9f6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga2c48912c12fd98a4f4faffbc7f20a9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8d2d93d79500c2f106b09e0ac7b49c79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga8d2d93d79500c2f106b09e0ac7b49c79">halHostFlushBuffers</a> (void)</td></tr>
<tr class="separator:ga8d2d93d79500c2f106b09e0ac7b49c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabff9b5c70adebfe64b6d0116d9a155bf"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gabff9b5c70adebfe64b6d0116d9a155bf">halHostEnqueueTx</a> (const uint8_t *data, uint16_t length)</td></tr>
<tr class="separator:gabff9b5c70adebfe64b6d0116d9a155bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga456af71802cd14910d2c4084b2bf27b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga456af71802cd14910d2c4084b2bf27b1">halHostFlushTx</a> (void)</td></tr>
<tr class="separator:ga456af71802cd14910d2c4084b2bf27b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d84751c1d7b33d771378e4732023c6"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga32d84751c1d7b33d771378e4732023c6">serialCopyFromRx</a> (const uint8_t *data, uint16_t length)</td></tr>
<tr class="separator:ga32d84751c1d7b33d771378e4732023c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcfc22a24cfcc5893d2eb2ed97c4fd82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gafcfc22a24cfcc5893d2eb2ed97c4fd82">emLoadSerialTx</a> (void)</td></tr>
<tr class="separator:gafcfc22a24cfcc5893d2eb2ed97c4fd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Serial Mode Definitions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpfdae8bf468c9a4f95acf0cb698dec7df"></a> These are numerical definitions for the possible serial modes so that code can test for the one being used. There may be additional modes defined in the micro-specific micro.h. </p>
</td></tr>
<tr class="memitem:ga44fab93c5555efea947b6e78d28405a4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga44fab93c5555efea947b6e78d28405a4">EMBER_SERIAL_UNUSED</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga44fab93c5555efea947b6e78d28405a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A numerical definition for a possible serial mode the code can test for.  <a href="#ga44fab93c5555efea947b6e78d28405a4">More...</a><br /></td></tr>
<tr class="separator:ga44fab93c5555efea947b6e78d28405a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8305e0960f14a47b6f6e5e68e00b433"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gaa8305e0960f14a47b6f6e5e68e00b433">EMBER_SERIAL_FIFO</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gaa8305e0960f14a47b6f6e5e68e00b433"><td class="mdescLeft">&#160;</td><td class="mdescRight">A numerical definition for a possible serial mode the code can test for.  <a href="#gaa8305e0960f14a47b6f6e5e68e00b433">More...</a><br /></td></tr>
<tr class="separator:gaa8305e0960f14a47b6f6e5e68e00b433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fb0daf83349cf27be1a371776296ff7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga5fb0daf83349cf27be1a371776296ff7">EMBER_SERIAL_LOWLEVEL</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga5fb0daf83349cf27be1a371776296ff7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A numerical definition for a possible serial mode the code can test for.  <a href="#ga5fb0daf83349cf27be1a371776296ff7">More...</a><br /></td></tr>
<tr class="separator:ga5fb0daf83349cf27be1a371776296ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
FIFO Utility Macros</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2d992ecd70f725cef0a4139f2b6441a0"></a> These macros manipulate the FIFO queue data structures to add and remove data. </p>
</td></tr>
<tr class="memitem:ga950bcbeecd3f4118871b596bd2e51a36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga950bcbeecd3f4118871b596bd2e51a36">FIFO_ENQUEUE</a>(queue,  data,  size)</td></tr>
<tr class="memdesc:ga950bcbeecd3f4118871b596bd2e51a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that enqueues a byte of data in a FIFO queue.  <a href="#ga950bcbeecd3f4118871b596bd2e51a36">More...</a><br /></td></tr>
<tr class="separator:ga950bcbeecd3f4118871b596bd2e51a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9ed21755e12d502f03e0fa08618618c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gaa9ed21755e12d502f03e0fa08618618c">FIFO_DEQUEUE</a>(queue,  size)</td></tr>
<tr class="memdesc:gaa9ed21755e12d502f03e0fa08618618c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that de-queues a byte of data from a FIFO queue.  <a href="#gaa9ed21755e12d502f03e0fa08618618c">More...</a><br /></td></tr>
<tr class="separator:gaa9ed21755e12d502f03e0fa08618618c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Serial HAL APIs</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp778efa1e462aba92b3616d2c1883aca1"></a> These functions must be implemented by the HAL in order for the serial code to operate. Only the higher-level serial code uses these functions, so they should not be called directly. The HAL should also implement the appropriate interrupt handlers to drain the TX queues and fill the RX FIFO queue. </p>
</td></tr>
<tr class="memitem:gaab61a51a0303d086e456010e087d9e3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gaab61a51a0303d086e456010e087d9e3e">halInternalUartInit</a> (uint8_t port, <a class="el" href="group__serial.html#ga79e9d2305515318a1ae0ab5aaffd6fcb">SerialBaudRate</a> rate, <a class="el" href="group__serial.html#ga2c48912c12fd98a4f4faffbc7f20a9f6">SerialParity</a> parity, uint8_t stopBits)</td></tr>
<tr class="memdesc:gaab61a51a0303d086e456010e087d9e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the UART to the given settings (same parameters as ::emberSerialInit() ).  <a href="#gaab61a51a0303d086e456010e087d9e3e">More...</a><br /></td></tr>
<tr class="separator:gaab61a51a0303d086e456010e087d9e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ac65cff3fc25dd920ddf870f0128f54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga7ac65cff3fc25dd920ddf870f0128f54">halInternalPowerDownUart</a> (void)</td></tr>
<tr class="memdesc:ga7ac65cff3fc25dd920ddf870f0128f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is typically called by <a class="el" href="group__micro.html#gae13140ae48ea28772b67717f0d28f5e9" title="Powers down microcontroller peripherals and board peripherals. ">halPowerDown()</a> and it is responsible for performing all the work internal to the UART needed to stop the UART before a sleep cycle.  <a href="#ga7ac65cff3fc25dd920ddf870f0128f54">More...</a><br /></td></tr>
<tr class="separator:ga7ac65cff3fc25dd920ddf870f0128f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23c94239635acd17fd1ca42c3e20dea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gaa23c94239635acd17fd1ca42c3e20dea">halInternalPowerUpUart</a> (void)</td></tr>
<tr class="memdesc:gaa23c94239635acd17fd1ca42c3e20dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is typically called by <a class="el" href="group__micro.html#ga467bf8ac5d5964ca282f332f4e394654" title="Powers up microcontroller peripherals and board peripherals. ">halPowerUp()</a> and it is responsible for performing all the work internal to the UART needed to restart the UART after a sleep cycle.  <a href="#gaa23c94239635acd17fd1ca42c3e20dea">More...</a><br /></td></tr>
<tr class="separator:gaa23c94239635acd17fd1ca42c3e20dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57cd95148c6b9421d1084bf27c3133ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga57cd95148c6b9421d1084bf27c3133ec">halInternalStartUartTx</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga57cd95148c6b9421d1084bf27c3133ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by serial code whenever anything is queued for transmission to start any interrupt-driven transmission. May be called when transmission is already in progess.  <a href="#ga57cd95148c6b9421d1084bf27c3133ec">More...</a><br /></td></tr>
<tr class="separator:ga57cd95148c6b9421d1084bf27c3133ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab07f42ec9a362d2729585b91ef38dc41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gab07f42ec9a362d2729585b91ef38dc41">halInternalStopUartTx</a> (uint8_t port)</td></tr>
<tr class="memdesc:gab07f42ec9a362d2729585b91ef38dc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by serial code to stop any interrupt-driven serial transmission currently in progress.  <a href="#gab07f42ec9a362d2729585b91ef38dc41">More...</a><br /></td></tr>
<tr class="separator:gab07f42ec9a362d2729585b91ef38dc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3706baabfda05b7856f71295294ea0a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga3706baabfda05b7856f71295294ea0a4">halInternalForceWriteUartData</a> (uint8_t port, uint8_t *data, uint8_t length)</td></tr>
<tr class="memdesc:ga3706baabfda05b7856f71295294ea0a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly writes a byte to the UART for transmission, regardless of anything currently queued for transmission. Should wait for anything currently in the UART hardware registers to finish transmission first, and block until <code>data</code> is finished being sent.  <a href="#ga3706baabfda05b7856f71295294ea0a4">More...</a><br /></td></tr>
<tr class="separator:ga3706baabfda05b7856f71295294ea0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga731dd7236b357ae604368029cfe3492a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga731dd7236b357ae604368029cfe3492a">halInternalForceReadUartByte</a> (uint8_t port, uint8_t *dataByte)</td></tr>
<tr class="memdesc:ga731dd7236b357ae604368029cfe3492a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly reads a byte from the UART for reception, regardless of anything currently queued for reception. Does not block if a data byte has not been received.  <a href="#ga731dd7236b357ae604368029cfe3492a">More...</a><br /></td></tr>
<tr class="separator:ga731dd7236b357ae604368029cfe3492a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3524b7efe60c7a79938bc14f2bd7e5ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga3524b7efe60c7a79938bc14f2bd7e5ca">halInternalWaitUartTxComplete</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga3524b7efe60c7a79938bc14f2bd7e5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks until the UART has finished transmitting any data in its hardware registers.  <a href="#ga3524b7efe60c7a79938bc14f2bd7e5ca">More...</a><br /></td></tr>
<tr class="separator:ga3524b7efe60c7a79938bc14f2bd7e5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e9274cfa859ea19f66592117742ceef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga5e9274cfa859ea19f66592117742ceef">halInternalRestartUart</a> (void)</td></tr>
<tr class="memdesc:ga5e9274cfa859ea19f66592117742ceef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is typically called by <a class="el" href="dev0680_8h.html#aea23c7d312d9a46eeea6e3d8bfaeea84" title="Power up the board. This function is called from halPowerUp(). ">halInternalPowerUpBoard()</a> and it is responsible for performing all the work internal to the UART needed to restart the UART after a sleep cycle. (For example, resyncing the DMA hardware and the serial FIFO.)  <a href="#ga5e9274cfa859ea19f66592117742ceef">More...</a><br /></td></tr>
<tr class="separator:ga5e9274cfa859ea19f66592117742ceef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2184eb97de15b6738e5ca11b40decdf1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga2184eb97de15b6738e5ca11b40decdf1">halInternalUartFlowControlRxIsEnabled</a> (uint8_t port)</td></tr>
<tr class="memdesc:ga2184eb97de15b6738e5ca11b40decdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if the host is allowed to send serial data to the ncp - i.e., it is not being held off by nCTS or an XOFF. Returns true is the host is able to send.  <a href="#ga2184eb97de15b6738e5ca11b40decdf1">More...</a><br /></td></tr>
<tr class="separator:ga2184eb97de15b6738e5ca11b40decdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffe915169918aa8359b63972126c56f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gaffe915169918aa8359b63972126c56f0">halInternalUartXonRefreshDone</a> (uint8_t port)</td></tr>
<tr class="memdesc:gaffe915169918aa8359b63972126c56f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">When Xon/Xoff flow control is used, returns true if the host is not being held off and XON refreshing is complete.  <a href="#gaffe915169918aa8359b63972126c56f0">More...</a><br /></td></tr>
<tr class="separator:gaffe915169918aa8359b63972126c56f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0dee46577b66b28822d8a0d0f9c39f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gaf0dee46577b66b28822d8a0d0f9c39f8">halInternalUartTxIsIdle</a> (uint8_t port)</td></tr>
<tr class="memdesc:gaf0dee46577b66b28822d8a0d0f9c39f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the uart transmitter is idle, including the transmit shift register.  <a href="#gaf0dee46577b66b28822d8a0d0f9c39f8">More...</a><br /></td></tr>
<tr class="separator:gaf0dee46577b66b28822d8a0d0f9c39f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab994f4b392102158f3632d6fe5e0e4ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gab994f4b392102158f3632d6fe5e0e4ca">serialDropPacket</a> (void)</td></tr>
<tr class="memdesc:gab994f4b392102158f3632d6fe5e0e4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Testing function implemented by the upper layer. Determines whether the next packet should be dropped. Returns true if the next packet should be dropped, false otherwise.  <a href="#gab994f4b392102158f3632d6fe5e0e4ca">More...</a><br /></td></tr>
<tr class="separator:gab994f4b392102158f3632d6fe5e0e4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa980a0d0e1c49f0f043a1f5dd48efa4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gaa980a0d0e1c49f0f043a1f5dd48efa4d">halInternalUartFlowControl</a>(port)&#160;&#160;&#160;do {} while (false)</td></tr>
<tr class="memdesc:gaa980a0d0e1c49f0f043a1f5dd48efa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used in FIFO mode when flow control is enabled. It is called from emberSerialReadByte(), and based on the number of bytes used in the uart receive queue, decides when to tell the host it may resume transmission.  <a href="#gaa980a0d0e1c49f0f043a1f5dd48efa4d">More...</a><br /></td></tr>
<tr class="separator:gaa980a0d0e1c49f0f043a1f5dd48efa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga005ec617ad0592a9bf174f578387ade2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga005ec617ad0592a9bf174f578387ade2">halInternalUartRxPump</a>(port)&#160;&#160;&#160;do {} while (false)</td></tr>
<tr class="memdesc:ga005ec617ad0592a9bf174f578387ade2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exists only in software UART (SOFTUART) mode on the EM3xx. This function is called by ::emberSerialReadByte(). It is responsible for maintaining synchronization between the emSerialRxQueue and the UART DMA.  <a href="#ga005ec617ad0592a9bf174f578387ade2">More...</a><br /></td></tr>
<tr class="separator:ga005ec617ad0592a9bf174f578387ade2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4475715bcb768aba26c89a5c677b9e68"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga4475715bcb768aba26c89a5c677b9e68">halInternalUart1FlowControlRxIsEnabled</a>()&#160;&#160;&#160;<a class="el" href="group__serial.html#ga2184eb97de15b6738e5ca11b40decdf1">halInternalUartFlowControlRxIsEnabled</a>(1)</td></tr>
<tr class="memdesc:ga4475715bcb768aba26c89a5c677b9e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used in FIFO mode when flow control is enabled. It is called from emberSerialReadByte(), and based on the number of bytes used in the uart receive queue, decides when to tell the host it may resume transmission.  <a href="#ga4475715bcb768aba26c89a5c677b9e68">More...</a><br /></td></tr>
<tr class="separator:ga4475715bcb768aba26c89a5c677b9e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac70ec510e77ca4a7efc984471eac879a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gac70ec510e77ca4a7efc984471eac879a">halInternalUart1XonRefreshDone</a>()&#160;&#160;&#160;<a class="el" href="group__serial.html#gaffe915169918aa8359b63972126c56f0">halInternalUartXonRefreshDone</a>(1)</td></tr>
<tr class="memdesc:gac70ec510e77ca4a7efc984471eac879a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used in FIFO mode when flow control is enabled. It is called from emberSerialReadByte(), and based on the number of bytes used in the uart receive queue, decides when to tell the host it may resume transmission.  <a href="#gac70ec510e77ca4a7efc984471eac879a">More...</a><br /></td></tr>
<tr class="separator:gac70ec510e77ca4a7efc984471eac879a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25a98a82cdeddf2f892d0232b864d790"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga25a98a82cdeddf2f892d0232b864d790">halInternalUart1TxIsIdle</a>()&#160;&#160;&#160;<a class="el" href="group__serial.html#gaf0dee46577b66b28822d8a0d0f9c39f8">halInternalUartTxIsIdle</a>(1)</td></tr>
<tr class="memdesc:ga25a98a82cdeddf2f892d0232b864d790"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used in FIFO mode when flow control is enabled. It is called from emberSerialReadByte(), and based on the number of bytes used in the uart receive queue, decides when to tell the host it may resume transmission.  <a href="#ga25a98a82cdeddf2f892d0232b864d790">More...</a><br /></td></tr>
<tr class="separator:ga25a98a82cdeddf2f892d0232b864d790"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Virtual UART API</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp628dfe2dcc7ff07f8a41394104aa6ea7"></a> API used by the stack in debug builds to receive data arriving over the virtual UART. </p>
</td></tr>
<tr class="memitem:gaaa462705765e53133edf705e12e8cfad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gaaa462705765e53133edf705e12e8cfad">halStackReceiveVuartMessage</a> (uint8_t *data, uint8_t length)</td></tr>
<tr class="memdesc:gaaa462705765e53133edf705e12e8cfad"><td class="mdescLeft">&#160;</td><td class="mdescRight">When using a debug build with virtual UART support, this API is called by the stack when virtual UART data has been received over the debug channel.  <a href="#gaaa462705765e53133edf705e12e8cfad">More...</a><br /></td></tr>
<tr class="separator:gaaa462705765e53133edf705e12e8cfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This API contains the HAL interfaces that applications must implement for the high-level serial code. </p>
<p>This header describes the interface between the high-level serial APIs in serial/serial.h and the low level UART implementation.</p>
<p>Some functions in this file return an <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value. See <a class="el" href="error-def_8h.html" title="Return-code definitions for EmberZNet stack API functions. ">error-def.h</a> for definitions of all <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> return values.</p>
<p>See <a class="el" href="serial_8h.html" title="Serial hardware abstraction layer interfaces. See Serial UART Communication for documentation. ">hal/micro/serial.h</a> for source code. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaa8305e0960f14a47b6f6e5e68e00b433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8305e0960f14a47b6f6e5e68e00b433">&#9670;&nbsp;</a></span>EMBER_SERIAL_FIFO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EMBER_SERIAL_FIFO&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A numerical definition for a possible serial mode the code can test for. </p>

</div>
</div>
<a id="ga5fb0daf83349cf27be1a371776296ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fb0daf83349cf27be1a371776296ff7">&#9670;&nbsp;</a></span>EMBER_SERIAL_LOWLEVEL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EMBER_SERIAL_LOWLEVEL&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A numerical definition for a possible serial mode the code can test for. </p>

</div>
</div>
<a id="ga44fab93c5555efea947b6e78d28405a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44fab93c5555efea947b6e78d28405a4">&#9670;&nbsp;</a></span>EMBER_SERIAL_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EMBER_SERIAL_UNUSED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A numerical definition for a possible serial mode the code can test for. </p>

</div>
</div>
<a id="gaa9ed21755e12d502f03e0fa08618618c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9ed21755e12d502f03e0fa08618618c">&#9670;&nbsp;</a></span>FIFO_DEQUEUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIFO_DEQUEUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(queue)-&gt;fifo[(queue)-&gt;tail];                   \</div><div class="line">  (queue)-&gt;tail = (((queue)-&gt;tail + 1) % (size)); \</div><div class="line">  (queue)-&gt;used--</div></div><!-- fragment -->
<p>Macro that de-queues a byte of data from a FIFO queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the FIFO queue.</td></tr>
    <tr><td class="paramname">size</td><td>Size used to control the wrap-around of the FIFO pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga950bcbeecd3f4118871b596bd2e51a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga950bcbeecd3f4118871b596bd2e51a36">&#9670;&nbsp;</a></span>FIFO_ENQUEUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FIFO_ENQUEUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">queue, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                              \</div><div class="line">    (queue)-&gt;fifo[(queue)-&gt;head] = (data);          \</div><div class="line">    (queue)-&gt;head = (((queue)-&gt;head + 1) % (size)); \</div><div class="line">    (queue)-&gt;used++;                                \</div><div class="line">  } <span class="keywordflow">while</span> (0)</div></div><!-- fragment -->
<p>Macro that enqueues a byte of data in a FIFO queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to the FIFO queue.</td></tr>
    <tr><td class="paramname">data</td><td>Data byte to be enqueued.</td></tr>
    <tr><td class="paramname">size</td><td>Size used to control the wrap-around of the FIFO pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4475715bcb768aba26c89a5c677b9e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4475715bcb768aba26c89a5c677b9e68">&#9670;&nbsp;</a></span>halInternalUart1FlowControlRxIsEnabled</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halInternalUart1FlowControlRxIsEnabled</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__serial.html#ga2184eb97de15b6738e5ca11b40decdf1">halInternalUartFlowControlRxIsEnabled</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used in FIFO mode when flow control is enabled. It is called from emberSerialReadByte(), and based on the number of bytes used in the uart receive queue, decides when to tell the host it may resume transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1). (Does nothing for port 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga25a98a82cdeddf2f892d0232b864d790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25a98a82cdeddf2f892d0232b864d790">&#9670;&nbsp;</a></span>halInternalUart1TxIsIdle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halInternalUart1TxIsIdle</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__serial.html#gaf0dee46577b66b28822d8a0d0f9c39f8">halInternalUartTxIsIdle</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used in FIFO mode when flow control is enabled. It is called from emberSerialReadByte(), and based on the number of bytes used in the uart receive queue, decides when to tell the host it may resume transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1). (Does nothing for port 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac70ec510e77ca4a7efc984471eac879a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac70ec510e77ca4a7efc984471eac879a">&#9670;&nbsp;</a></span>halInternalUart1XonRefreshDone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halInternalUart1XonRefreshDone</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__serial.html#gaffe915169918aa8359b63972126c56f0">halInternalUartXonRefreshDone</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used in FIFO mode when flow control is enabled. It is called from emberSerialReadByte(), and based on the number of bytes used in the uart receive queue, decides when to tell the host it may resume transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1). (Does nothing for port 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa980a0d0e1c49f0f043a1f5dd48efa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa980a0d0e1c49f0f043a1f5dd48efa4d">&#9670;&nbsp;</a></span>halInternalUartFlowControl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halInternalUartFlowControl</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">port</td><td>)</td>
          <td>&#160;&#160;&#160;do {} while (false)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used in FIFO mode when flow control is enabled. It is called from emberSerialReadByte(), and based on the number of bytes used in the uart receive queue, decides when to tell the host it may resume transmission. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1). (Does nothing for port 0) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga005ec617ad0592a9bf174f578387ade2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga005ec617ad0592a9bf174f578387ade2">&#9670;&nbsp;</a></span>halInternalUartRxPump</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halInternalUartRxPump</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">port</td><td>)</td>
          <td>&#160;&#160;&#160;do {} while (false)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function exists only in software UART (SOFTUART) mode on the EM3xx. This function is called by ::emberSerialReadByte(). It is responsible for maintaining synchronization between the emSerialRxQueue and the UART DMA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga79e9d2305515318a1ae0ab5aaffd6fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79e9d2305515318a1ae0ab5aaffd6fcb">&#9670;&nbsp;</a></span>SerialBaudRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__serial.html#ga79e9d2305515318a1ae0ab5aaffd6fcb">SerialBaudRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign numerical values for variables that hold Baud Rate parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga79e9d2305515318a1ae0ab5aaffd6fcbaddd7d1b8d46d2e29d36ba073b1ea8dcd"></a>DEFINE_BAUD&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga2c48912c12fd98a4f4faffbc7f20a9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c48912c12fd98a4f4faffbc7f20a9f6">&#9670;&nbsp;</a></span>SerialParity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__serial.html#ga2c48912c12fd98a4f4faffbc7f20a9f6">SerialParity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CORTEXM3_EFM32_MICRO. </p>
<p>Assign numerical values for the types of parity. Use for variables that hold Parity parameters. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2c48912c12fd98a4f4faffbc7f20a9f6a9569a17323e2dd2a5bb1db6a96621815"></a>DEFINE_PARITY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga2c48912c12fd98a4f4faffbc7f20a9f6a9569a17323e2dd2a5bb1db6a96621815"></a>DEFINE_PARITY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga2c48912c12fd98a4f4faffbc7f20a9f6a9569a17323e2dd2a5bb1db6a96621815"></a>DEFINE_PARITY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafcfc22a24cfcc5893d2eb2ed97c4fd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafcfc22a24cfcc5893d2eb2ed97c4fd82">&#9670;&nbsp;</a></span>emLoadSerialTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void emLoadSerialTx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gabff9b5c70adebfe64b6d0116d9a155bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabff9b5c70adebfe64b6d0116d9a155bf">&#9670;&nbsp;</a></span>halHostEnqueueTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t halHostEnqueueTx </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga8d2d93d79500c2f106b09e0ac7b49c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d2d93d79500c2f106b09e0ac7b49c79">&#9670;&nbsp;</a></span>halHostFlushBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halHostFlushBuffers </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga456af71802cd14910d2c4084b2bf27b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga456af71802cd14910d2c4084b2bf27b1">&#9670;&nbsp;</a></span>halHostFlushTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halHostFlushTx </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga731dd7236b357ae604368029cfe3492a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga731dd7236b357ae604368029cfe3492a">&#9670;&nbsp;</a></span>halInternalForceReadUartByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> halInternalForceReadUartByte </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dataByte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly reads a byte from the UART for reception, regardless of anything currently queued for reception. Does not block if a data byte has not been received. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1).</td></tr>
    <tr><td class="paramname">dataByte</td><td>The byte to receive data into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3706baabfda05b7856f71295294ea0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3706baabfda05b7856f71295294ea0a4">&#9670;&nbsp;</a></span>halInternalForceWriteUartData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> halInternalForceWriteUartData </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly writes a byte to the UART for transmission, regardless of anything currently queued for transmission. Should wait for anything currently in the UART hardware registers to finish transmission first, and block until <code>data</code> is finished being sent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1).</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to be transmitted.</td></tr>
    <tr><td class="paramname">length</td><td>The length of data to be transmitted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7ac65cff3fc25dd920ddf870f0128f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ac65cff3fc25dd920ddf870f0128f54">&#9670;&nbsp;</a></span>halInternalPowerDownUart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halInternalPowerDownUart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is typically called by <a class="el" href="group__micro.html#gae13140ae48ea28772b67717f0d28f5e9" title="Powers down microcontroller peripherals and board peripherals. ">halPowerDown()</a> and it is responsible for performing all the work internal to the UART needed to stop the UART before a sleep cycle. </p>

</div>
</div>
<a id="gaa23c94239635acd17fd1ca42c3e20dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa23c94239635acd17fd1ca42c3e20dea">&#9670;&nbsp;</a></span>halInternalPowerUpUart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halInternalPowerUpUart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is typically called by <a class="el" href="group__micro.html#ga467bf8ac5d5964ca282f332f4e394654" title="Powers up microcontroller peripherals and board peripherals. ">halPowerUp()</a> and it is responsible for performing all the work internal to the UART needed to restart the UART after a sleep cycle. </p>

</div>
</div>
<a id="ga5e9274cfa859ea19f66592117742ceef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e9274cfa859ea19f66592117742ceef">&#9670;&nbsp;</a></span>halInternalRestartUart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halInternalRestartUart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is typically called by <a class="el" href="dev0680_8h.html#aea23c7d312d9a46eeea6e3d8bfaeea84" title="Power up the board. This function is called from halPowerUp(). ">halInternalPowerUpBoard()</a> and it is responsible for performing all the work internal to the UART needed to restart the UART after a sleep cycle. (For example, resyncing the DMA hardware and the serial FIFO.) </p>

</div>
</div>
<a id="ga57cd95148c6b9421d1084bf27c3133ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57cd95148c6b9421d1084bf27c3133ec">&#9670;&nbsp;</a></span>halInternalStartUartTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halInternalStartUartTx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by serial code whenever anything is queued for transmission to start any interrupt-driven transmission. May be called when transmission is already in progess. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab07f42ec9a362d2729585b91ef38dc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab07f42ec9a362d2729585b91ef38dc41">&#9670;&nbsp;</a></span>halInternalStopUartTx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halInternalStopUartTx </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called by serial code to stop any interrupt-driven serial transmission currently in progress. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2184eb97de15b6738e5ca11b40decdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2184eb97de15b6738e5ca11b40decdf1">&#9670;&nbsp;</a></span>halInternalUartFlowControlRxIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool halInternalUartFlowControlRxIsEnabled </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if the host is allowed to send serial data to the ncp - i.e., it is not being held off by nCTS or an XOFF. Returns true is the host is able to send. </p>

</div>
</div>
<a id="gaab61a51a0303d086e456010e087d9e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab61a51a0303d086e456010e087d9e3e">&#9670;&nbsp;</a></span>halInternalUartInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> halInternalUartInit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__serial.html#ga79e9d2305515318a1ae0ab5aaffd6fcb">SerialBaudRate</a>&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__serial.html#ga2c48912c12fd98a4f4faffbc7f20a9f6">SerialParity</a>&#160;</td>
          <td class="paramname"><em>parity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>stopBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the UART to the given settings (same parameters as ::emberSerialInit() ). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1).</td></tr>
    <tr><td class="paramname">rate</td><td>Baud rate (see SerialBaudRate).</td></tr>
    <tr><td class="paramname">parity</td><td>Parity value (see SerialParity).</td></tr>
    <tr><td class="paramname">stopBits</td><td>Number of stop bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code if initialization failed (such as invalid baud rate), otherise EMBER_SUCCESS. </dd></dl>

</div>
</div>
<a id="gaf0dee46577b66b28822d8a0d0f9c39f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0dee46577b66b28822d8a0d0f9c39f8">&#9670;&nbsp;</a></span>halInternalUartTxIsIdle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool halInternalUartTxIsIdle </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the uart transmitter is idle, including the transmit shift register. </p>

</div>
</div>
<a id="gaffe915169918aa8359b63972126c56f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffe915169918aa8359b63972126c56f0">&#9670;&nbsp;</a></span>halInternalUartXonRefreshDone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool halInternalUartXonRefreshDone </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When Xon/Xoff flow control is used, returns true if the host is not being held off and XON refreshing is complete. </p>

</div>
</div>
<a id="ga3524b7efe60c7a79938bc14f2bd7e5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3524b7efe60c7a79938bc14f2bd7e5ca">&#9670;&nbsp;</a></span>halInternalWaitUartTxComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halInternalWaitUartTxComplete </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Blocks until the UART has finished transmitting any data in its hardware registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">port</td><td>Serial port number (0 or 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa462705765e53133edf705e12e8cfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa462705765e53133edf705e12e8cfad">&#9670;&nbsp;</a></span>halStackReceiveVuartMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void halStackReceiveVuartMessage </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When using a debug build with virtual UART support, this API is called by the stack when virtual UART data has been received over the debug channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the the data received</td></tr>
    <tr><td class="paramname">length</td><td>Length of the data received </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32d84751c1d7b33d771378e4732023c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32d84751c1d7b33d771378e4732023c6">&#9670;&nbsp;</a></span>serialCopyFromRx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t serialCopyFromRx </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gab994f4b392102158f3632d6fe5e0e4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab994f4b392102158f3632d6fe5e0e4ca">&#9670;&nbsp;</a></span>serialDropPacket()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool serialDropPacket </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Testing function implemented by the upper layer. Determines whether the next packet should be dropped. Returns true if the next packet should be dropped, false otherwise. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 10 2020 11:32:14 for EmberZNet API Reference: For the EM35x SoC Platform by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
