<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EmberZNet API Reference: For the EM35x SoC Platform: Tokens</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EmberZNet API Reference: For the EM35x SoC Platform
   &#160;<span id="projectnumber">EmberZNet 6.8.1.0</span>
   </div>
   <div id="projectbrief">For the EFR32 and EM3xx Platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__token.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tokens<div class="ingroups"><a class="el" href="group__hal.html">Hardware Abstraction Layer (HAL) API Reference</a> &raquo; <a class="el" href="group__tokens.html">Token Access</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga1cdf205aa0e67b9508ce927b52a6875a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#ga1cdf205aa0e67b9508ce927b52a6875a">halCommonGetToken</a>(data,  token)</td></tr>
<tr class="memdesc:ga1cdf205aa0e67b9508ce927b52a6875a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that copies the token value from non-volatile storage into a RAM location. This macro can only be used with tokens that are defined using DEFINE_BASIC_TOKEN.  <a href="#ga1cdf205aa0e67b9508ce927b52a6875a">More...</a><br /></td></tr>
<tr class="separator:ga1cdf205aa0e67b9508ce927b52a6875a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d7937bb8f438d0bd76a6d017d2db2fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#ga7d7937bb8f438d0bd76a6d017d2db2fe">halCommonGetMfgToken</a>(data,  token)</td></tr>
<tr class="memdesc:ga7d7937bb8f438d0bd76a6d017d2db2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that copies the token value from non-volatile storage into a RAM location. This macro can only be used with tokens that are defined using DEFINE_MFG_TOKEN.  <a href="#ga7d7937bb8f438d0bd76a6d017d2db2fe">More...</a><br /></td></tr>
<tr class="separator:ga7d7937bb8f438d0bd76a6d017d2db2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7f03bfb03f29e528d36035ecbf4c23"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#ga8d7f03bfb03f29e528d36035ecbf4c23">halCommonGetIndexedToken</a>(data,  token,  index)</td></tr>
<tr class="memdesc:ga8d7f03bfb03f29e528d36035ecbf4c23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that copies the token value from non-volatile storage into a RAM location. This macro can only be used with tokens that are defined using DEFINE_INDEXED_TOKEN.  <a href="#ga8d7f03bfb03f29e528d36035ecbf4c23">More...</a><br /></td></tr>
<tr class="separator:ga8d7f03bfb03f29e528d36035ecbf4c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b75375d668ed0a061a3351e879a87e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#gab7b75375d668ed0a061a3351e879a87e">halCommonSetToken</a>(token,  data)</td></tr>
<tr class="memdesc:gab7b75375d668ed0a061a3351e879a87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that sets the value of a token in non-volatile storage. This macro can only be used with tokens that are defined using DEFINE_BASIC_TOKEN.  <a href="#gab7b75375d668ed0a061a3351e879a87e">More...</a><br /></td></tr>
<tr class="separator:gab7b75375d668ed0a061a3351e879a87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632ff9591650d5721a447413a5d1505d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#ga632ff9591650d5721a447413a5d1505d">halCommonSetIndexedToken</a>(token,  index,  data)</td></tr>
<tr class="memdesc:ga632ff9591650d5721a447413a5d1505d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that sets the value of a token in non-volatile storage. This macro can only be used with tokens that are defined using DEFINE_INDEXED_TOKEN.  <a href="#ga632ff9591650d5721a447413a5d1505d">More...</a><br /></td></tr>
<tr class="separator:ga632ff9591650d5721a447413a5d1505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93c5e6c239ea037dc42a368b9a875244"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#ga93c5e6c239ea037dc42a368b9a875244">halCommonIncrementCounterToken</a>(token)</td></tr>
<tr class="memdesc:ga93c5e6c239ea037dc42a368b9a875244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that increments the value of a token that is a counter. This macro can only be used with tokens that are defined using either DEFINE_COUNTER_TOKEN.  <a href="#ga93c5e6c239ea037dc42a368b9a875244">More...</a><br /></td></tr>
<tr class="separator:ga93c5e6c239ea037dc42a368b9a875244"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaea9227bf2ad0aba25b9eb01199c7fde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__token.html#gaaea9227bf2ad0aba25b9eb01199c7fde">halStackInitTokens</a> (void)</td></tr>
<tr class="memdesc:gaaea9227bf2ad0aba25b9eb01199c7fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and enables the token system. Checks if the manufacturing and stack non-volatile data versions are correct.  <a href="#gaaea9227bf2ad0aba25b9eb01199c7fde">More...</a><br /></td></tr>
<tr class="separator:gaaea9227bf2ad0aba25b9eb01199c7fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>There are three main types of tokens:</p><ul>
<li><b>Manufacturing tokens:</b> Tokens that are set at the factory and must not be changed through software operations.</li>
<li><b>Stack-level tokens:</b> Tokens that can be changed via the appropriate stack API calls.</li>
<li><b>Application level tokens:</b> Tokens that can be set via the token system API calls in this file.</li>
</ul>
<p>The token system API controls writing tokens to non-volatile data and reading tokens from non-volatile data. If an application wishes to use application specific normal tokens, it must do so by creating its own token header file similar to <a class="el" href="token-stack_8h.html" title="Definitions for stack tokens. See Stack Tokens for documentation. ">token-stack.h</a>. The macro <code>APPLICATION_TOKEN_HEADER</code> should be defined to equal the name of the header file in which application tokens are defined. If an application wishes to use application specific manufacturing tokens, it must do so by creating its own manufacturing token header file similar to <a class="el" href="token-manufacturing_8h.html" title="Definitions for manufacturing tokens. ">token-manufacturing.h</a>. The macro <code>APPLICATION_MFG_TOKEN_HEADER</code> should be defined to equal the name of the header file in which manufacturing tokens are defined.</p>
<p>Because the token system is based on memory locations within non-volatile storage, the token information could become out of sync without some kind of version tracking. The two defines, <code>CURRENT_MFG_TOKEN_VERSION </code> and <code>CURRENT_STACK_TOKEN_VERSION</code>, are used to make sure the stack stays in sync with the proper token set. If the application defines its own tokens, it is recommended that the application also define an application token to be a application version to ensure the application stays in sync with the proper token set.</p>
<p>The most general format of a token definition is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CREATOR_name 16bit_value</span></div><div class="line"><span class="preprocessor">#define NVM3KEY_name 20bit_value</span></div><div class="line"><span class="preprocessor">#ifdef DEFINETYPES</span></div><div class="line">   <span class="keyword">typedef</span> data_type type</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#ifdef DEFINETOKENS</span></div><div class="line">   DEFINE_*_TOKEN(name, type, ... ,defaults)</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>The defined CREATOR is used as a distinct identifier tag for the token when using Simulated EEPROM or with manufacturing tokens. The CREATOR is necessary because the token name is defined differently depending on underlying implementation, so the CREATOR makes sure token definitions and data stay tagged and known. The only requirement on these creator definitions is that they all must be unique. A favorite method for picking creator codes is to use two ASCII characters inorder to make the codes more memorable. The 'name' part of the <code>#define CREATOR_name</code> must match the 'name' provided in the <code>DEFINE_*_TOKEN</code> because the token system uses this name to automatically link the two.</p>
<p>The defined NVM3KEY is used to map the token to an NVM3 key and is needed using NVM3 as the underlying storage mechanism. This key can also be used as an identifier for a token's NVM3 object when using the native NVM3 API. The NVM3 keys must be unique for one instance of the NVM3 backing storage. All tokens share the same NVM3 instance and hence all NVM3KEYS for tokens must be unique. The 'name' part of the <code>#define NVM3KEY_name</code> must match the 'name' provided in the <code>DEFINE_*_TOKEN</code> because the token system uses this name to automatically link the two. For indexed tokens, the 127 NVM3KEY values following the defined NVM3KEY for a token should also be reserved. This is done as one NVM3KEY is used for each index in an indexed token and hence these NVM3KEYS should not collide with the eys of other tokens.</p>
<p>As NVM3 is shared among several stacks and application code, the NVM3KEY values chosen must be defined in the correct region to avoid collisions.</p>
<p>The following NVM3KEY regions are defined: 0x0xxxx : User objects 0x1xxxx : zigbee stack objects 0x2xxxx : Thread stack objects 0x3xxxx : Connect stack objects 0x4xxxx : Bluetooth stack objects</p>
<p>The typedef provides a convenient and efficient abstraction of the token data. Since some tokens are structs with multiple pieces of data inside of them, type defining the token type allows more efficient and readable local copies of the tokens throughout the code.</p>
<p>The typedef is wrapped with an <code>#ifdef DEFINETYPES</code> because the typdefs and token defs live in the same file, and DEFINETYPES is used to select only the typedefs when the file is included. Similarly, the <code>DEFINE_*_TOKEN</code> is wrapped with an <code>#ifdef DEFINETOKENS</code> as a method for selecting only the token definitions when the file is included.</p>
<p>The abstract definition, <code>DEFINE_*_TOKEN(name, type, ... ,defaults)</code>, has seven possible complete definitions:<br />
 <code> </p><ul>
<li>
DEFINE_BASIC_TOKEN(name, type, ...) </li>
<li>
DEFINE_INDEXED_TOKEN(name, type, arraysize, ...) </li>
<li>
DEFINE_COUNTER_TOKEN(name, type, ...) </li>
<li>
DEFINE_MFG_TOKEN(name, type, address, ...) </li>
</ul>
<p></code> The three fields common to all <code>DEFINE_*_TOKEN</code> are:<br />
 name - The name of the token, which all information is tied to.<br />
 type - Type of the token which is the same as the typedef mentioned before.<br />
 ... - The default value to which the token is set upon initialization.</p>
<dl class="section note"><dt>Note</dt><dd>The old DEFINE_FIXED* token definitions are no longer used. They remain defined for backwards compatibility. In current systems, the Simulated EEPROM or NVM3 is used for storing non-manufacturing tokens and the Simulated EEPROM or NVM3 intelligently manages where tokens are stored to provide wear leveling across the flash memory and increase the number of write cycles. Manufacturing tokens live at a fixed address, but they must use DEFINE_MFG_TOKEN so the token system knows they are manufacturing tokens.</dd></dl>
<p><b>DEFINE_BASIC_TOKEN</b> is the simplest definition and will be used for the majority of tokens (tokens that are not indexed, not counters, and not manufacturing). Basic tokens are designed for data storage that is always accessed as a single element.</p>
<p><b>DEFINE_INDEXED_TOKEN</b> should be used on tokens that look like arrays. For example, data storage that looks like:<br />
 </p><pre><code>   uint32_t myData[5]</code></pre><p><br />
 This example data storage can be a token with typedef of uint32_t and defined as INDEXED with arraysize of 5. The extra field in this token definition is: arraysize - The number of elements in the indexed token. Indexed tokens are designed for data storage that is logically grouped together, but elements are accessed individually. Note that when assigning an NVM3KEY for an indexed token, the 126 higher numbered NVM3KEYs following the NVM3KEY that you define are reserved for that token and no other tokens should be defined with NVM3KEYs in this region.</p>
<p><b>DEFINE_COUNTER_TOKEN</b> should be used on tokens that are simple numbers where the majority of operations on the token is to increment the count. The reason for using DEFINE_COUNTER_TOKEN instead of DEFINE_BASIC_TOKEN is the special support that the token system provides for incrementing counters. The function call <code><a class="el" href="group__token.html#ga93c5e6c239ea037dc42a368b9a875244" title="Macro that increments the value of a token that is a counter. This macro can only be used with tokens...">halCommonIncrementCounterToken()</a></code> only operates on counter tokens and is more efficient in terms of speed, data compression, and write cyles for incrementing simple numbers in the token system.</p>
<p><b>DEFINE_MFG_TOKEN</b> is a DEFINE_BASIC_TOKEN token at a specific address and the token is manufacturing data that is written only once. The major difference is this token is designated manufacturing, which means the token system treats it differently from stack or app tokens. Primarily, a manufacturing token is written only once and lives at a fixed address outside of the Simulated EEPROM or NVM3 system. Being a write once token, the token system will also aid in debugging by asserting if there is an attempt to write a manufacturing token.</p>
<p>Here is an example of two application tokens. The definition is compatible with both Simulated EEPROM and NVM3 as both CREATOR and NVM3KEY defines are included.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CREATOR_SENSOR_NAME        0x5354</span></div><div class="line"><span class="preprocessor">#define CREATOR_SENSOR_PARAMETERS  0x5350</span></div><div class="line"><span class="preprocessor">#define NVM3KEY_SENSOR_NAME       0x0AB54</span></div><div class="line"><span class="preprocessor">#define NVM3KEY_SENSOR_PARAMETERS 0x00150</span></div><div class="line"><span class="preprocessor">#ifdef DEFINETYPES</span></div><div class="line">  <span class="keyword">typedef</span> uint8_t tokTypeSensorName[10];</div><div class="line">  <span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    uint8_t initValues[5];</div><div class="line">    uint8_t reportInterval;</div><div class="line">    uint16_t calibrationValue;</div><div class="line">  } tokTypeSensorParameters;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">#ifdef DEFINETOKENS</span></div><div class="line">  <a class="code" href="group__token__stack.html#ga3e10c86994d2a8e0e712683d60797e20">DEFINE_BASIC_TOKEN</a>(SENSOR_NAME,</div><div class="line">                     tokTypeSensorName,</div><div class="line">                     {<span class="charliteral">&#39;U&#39;</span>,<span class="charliteral">&#39;N&#39;</span>,<span class="charliteral">&#39;A&#39;</span>,<span class="charliteral">&#39;M&#39;</span>,<span class="charliteral">&#39;E&#39;</span>,<span class="charliteral">&#39;D&#39;</span>,<span class="charliteral">&#39; &#39;</span>,<span class="charliteral">&#39; &#39;</span>,<span class="charliteral">&#39; &#39;</span>,<span class="charliteral">&#39; &#39;</span>})</div><div class="line">  <a class="code" href="group__token__stack.html#ga3e10c86994d2a8e0e712683d60797e20">DEFINE_BASIC_TOKEN</a>(SENSOR_PARAMETERS,</div><div class="line">                     tokTypeSensorParameters,</div><div class="line">                     {{0x01,0x02,0x03,0x04,0x05},5,0x0000})</div><div class="line">#endif</div></div><!-- fragment --><p>Here is an example of how to use the two application tokens: </p><div class="fragment"><div class="line">{</div><div class="line">  tokTypeSensorName sensor;</div><div class="line">  tokTypeSensorParameters params;</div><div class="line"></div><div class="line">  <a class="code" href="group__token.html#ga1cdf205aa0e67b9508ce927b52a6875a">halCommonGetToken</a>(&amp;sensor, TOKEN_SENSOR_NAME);</div><div class="line">  <a class="code" href="group__token.html#ga1cdf205aa0e67b9508ce927b52a6875a">halCommonGetToken</a>(&amp;params, TOKEN_SENSOR_PARAMETERS);</div><div class="line">  <span class="keywordflow">if</span>(params.calibrationValue == 0xBEEF) {</div><div class="line">    params.reportInterval = 5;</div><div class="line">  }</div><div class="line">  <a class="code" href="group__token.html#gab7b75375d668ed0a061a3351e879a87e">halCommonSetToken</a>(TOKEN_SENSOR_PARAMETERS, &amp;params);</div><div class="line">}</div></div><!-- fragment --><p>See <a class="el" href="token-stack_8h.html" title="Definitions for stack tokens. See Stack Tokens for documentation. ">token-stack.h</a> to see the default set of tokens and their values.</p>
<p>The nodetest utility app can be used for generic manipulation such as loading default token values, viewing tokens, and writing tokens. <b>The nodetest utility cannot work with customer defined application tokens or manufacturing tokens. Using the nodetest utility will erase customer defined application tokens in the Simulated EEPROM and NVM3.</b></p>
<p>The Simulated EEPROM or NVM3 will initialize tokens to their default values if the token does not yet exist, the token's creator code is changed, or the token's size changes.</p>
<p>Changing the number indexes in an INDEXED token will not alter existing entries. If the number of indexes is reduced, the entires that still fit in the token will retain their data and the entries that no longer fit will be erased. If the number of indexes is increased, the existing entries retain their data and the new entries are initialized to the token's defaults.</p>
<p>Further details on exact implementation can be found in code comments in <a class="el" href="token-stack_8h.html" title="Definitions for stack tokens. See Stack Tokens for documentation. ">token-stack.h</a> file, the platform specific <a class="el" href="token-manufacturing_8h.html" title="Definitions for manufacturing tokens. ">token-manufacturing.h</a> file, the platform specific token.h file, and the platform specific token.c file.</p>
<p>Some functions in this file return an <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> value. See <a class="el" href="error-def_8h.html" title="Return-code definitions for EmberZNet stack API functions. ">error-def.h</a> for definitions of all <a class="el" href="error_8h.html#acff561a945530f3039d6715958418ab8">EmberStatus</a> return values.</p>
<p>See <a class="el" href="token_8h.html" title="Token system for storing non-volatile information. See Tokens for documentation. ">hal/micro/token.h</a> for source code. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga8d7f03bfb03f29e528d36035ecbf4c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d7f03bfb03f29e528d36035ecbf4c23">&#9670;&nbsp;</a></span>halCommonGetIndexedToken</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halCommonGetIndexedToken</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">token, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that copies the token value from non-volatile storage into a RAM location. This macro can only be used with tokens that are defined using DEFINE_INDEXED_TOKEN. </p>
<dl class="section note"><dt>Note</dt><dd>To better understand the parameters of this macro, refer to the example of token usage above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to where the token data should be placed.</td></tr>
    <tr><td class="paramname">token</td><td>The token name used in <code>DEFINE_*_TOKEN</code>, prepended with <code>TOKEN_</code>. </td></tr>
    <tr><td class="paramname">index</td><td>The index to access in the indexed token. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d7937bb8f438d0bd76a6d017d2db2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d7937bb8f438d0bd76a6d017d2db2fe">&#9670;&nbsp;</a></span>halCommonGetMfgToken</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halCommonGetMfgToken</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">token&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that copies the token value from non-volatile storage into a RAM location. This macro can only be used with tokens that are defined using DEFINE_MFG_TOKEN. </p>
<dl class="section note"><dt>Note</dt><dd>To better understand the parameters of this macro, refer to the example of token usage above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to where the token data should be placed.</td></tr>
    <tr><td class="paramname">token</td><td>The token name used in <code>DEFINE_*_TOKEN</code>, prepended with <code>TOKEN_</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1cdf205aa0e67b9508ce927b52a6875a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cdf205aa0e67b9508ce927b52a6875a">&#9670;&nbsp;</a></span>halCommonGetToken</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halCommonGetToken</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">token&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that copies the token value from non-volatile storage into a RAM location. This macro can only be used with tokens that are defined using DEFINE_BASIC_TOKEN. </p>
<dl class="section note"><dt>Note</dt><dd>To better understand the parameters of this macro, refer to the example of token usage above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to where the token data should be placed.</td></tr>
    <tr><td class="paramname">token</td><td>The token name used in <code>DEFINE_*_TOKEN</code>, prepended with <code>TOKEN_</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga93c5e6c239ea037dc42a368b9a875244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93c5e6c239ea037dc42a368b9a875244">&#9670;&nbsp;</a></span>halCommonIncrementCounterToken</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halCommonIncrementCounterToken</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">token</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that increments the value of a token that is a counter. This macro can only be used with tokens that are defined using either DEFINE_COUNTER_TOKEN. </p>
<dl class="section note"><dt>Note</dt><dd>To better understand the parameters of this macro, refer to the example of token usage above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token name used in <code>DEFINE_*_TOKEN</code>, prepended with <code>TOKEN_</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga632ff9591650d5721a447413a5d1505d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga632ff9591650d5721a447413a5d1505d">&#9670;&nbsp;</a></span>halCommonSetIndexedToken</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halCommonSetIndexedToken</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">token, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that sets the value of a token in non-volatile storage. This macro can only be used with tokens that are defined using DEFINE_INDEXED_TOKEN. </p>
<dl class="section note"><dt>Note</dt><dd>To better understand the parameters of this macro, refer to the example of token usage above.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token name used in <code>DEFINE_*_TOKEN</code>, prepended with <code>TOKEN_</code>.</td></tr>
    <tr><td class="paramname">index</td><td>The index to access in the indexed token.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to where the token data should be placed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab7b75375d668ed0a061a3351e879a87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7b75375d668ed0a061a3351e879a87e">&#9670;&nbsp;</a></span>halCommonSetToken</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define halCommonSetToken</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">token, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that sets the value of a token in non-volatile storage. This macro can only be used with tokens that are defined using DEFINE_BASIC_TOKEN. </p>
<dl class="section note"><dt>Note</dt><dd>To better understand the parameters of this macro, refer to the example of token usage above. For EFR32 devices this function must not be called in IRQ context as it can cause data corruption.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">token</td><td>The token name used in <code>DEFINE_*_TOKEN</code>, prepended with <code>TOKEN_</code>.</td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the data being written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaea9227bf2ad0aba25b9eb01199c7fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaea9227bf2ad0aba25b9eb01199c7fde">&#9670;&nbsp;</a></span>halStackInitTokens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__status__codes.html#gabdc825a7bb1ce986862f1566accee9aa">EmberStatus</a> halStackInitTokens </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes and enables the token system. Checks if the manufacturing and stack non-volatile data versions are correct. </p>
<dl class="section return"><dt>Returns</dt><dd>An EmberStatus value indicating the success or failure of the command. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Sep 10 2020 11:32:14 for EmberZNet API Reference: For the EM35x SoC Platform by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
